/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";
var $protobuf = require("protobufjs/minimal");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.SC2APIProtocol = (function () {
    /**
     * Namespace SC2APIProtocol.
     * @exports SC2APIProtocol
     * @namespace
     */
    var SC2APIProtocol = {};
    SC2APIProtocol.AvailableAbility = (function () {
        /**
         * Properties of an AvailableAbility.
         * @memberof SC2APIProtocol
         * @interface IAvailableAbility
         * @property {number} [abilityId] AvailableAbility abilityId
         * @property {boolean} [requiresPoint] AvailableAbility requiresPoint
         */
        /**
         * Constructs a new AvailableAbility.
         * @memberof SC2APIProtocol
         * @classdesc Represents an AvailableAbility.
         * @constructor
         * @param {SC2APIProtocol.IAvailableAbility=} [properties] Properties to set
         */
        function AvailableAbility(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AvailableAbility abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.AvailableAbility
         * @instance
         */
        AvailableAbility.prototype.abilityId = 0;
        /**
         * AvailableAbility requiresPoint.
         * @member {boolean}requiresPoint
         * @memberof SC2APIProtocol.AvailableAbility
         * @instance
         */
        AvailableAbility.prototype.requiresPoint = false;
        /**
         * Creates a new AvailableAbility instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {SC2APIProtocol.IAvailableAbility=} [properties] Properties to set
         * @returns {SC2APIProtocol.AvailableAbility} AvailableAbility instance
         */
        AvailableAbility.create = function create(properties) {
            return new AvailableAbility(properties);
        };
        /**
         * Encodes the specified AvailableAbility message. Does not implicitly {@link SC2APIProtocol.AvailableAbility.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {SC2APIProtocol.IAvailableAbility} message AvailableAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvailableAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            if (message.requiresPoint != null && message.hasOwnProperty("requiresPoint"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.requiresPoint);
            return writer;
        };
        /**
         * Encodes the specified AvailableAbility message, length delimited. Does not implicitly {@link SC2APIProtocol.AvailableAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {SC2APIProtocol.IAvailableAbility} message AvailableAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AvailableAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AvailableAbility message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.AvailableAbility} AvailableAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvailableAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.AvailableAbility();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    case 2:
                        message.requiresPoint = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AvailableAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.AvailableAbility} AvailableAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AvailableAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AvailableAbility message.
         * @function verify
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AvailableAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.requiresPoint != null && message.hasOwnProperty("requiresPoint"))
                if (typeof message.requiresPoint !== "boolean")
                    return "requiresPoint: boolean expected";
            return null;
        };
        /**
         * Creates an AvailableAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.AvailableAbility} AvailableAbility
         */
        AvailableAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.AvailableAbility)
                return object;
            var message = new $root.SC2APIProtocol.AvailableAbility();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            if (object.requiresPoint != null)
                message.requiresPoint = Boolean(object.requiresPoint);
            return message;
        };
        /**
         * Creates a plain object from an AvailableAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.AvailableAbility
         * @static
         * @param {SC2APIProtocol.AvailableAbility} message AvailableAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AvailableAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = 0;
                object.requiresPoint = false;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.requiresPoint != null && message.hasOwnProperty("requiresPoint"))
                object.requiresPoint = message.requiresPoint;
            return object;
        };
        /**
         * Converts this AvailableAbility to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.AvailableAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AvailableAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AvailableAbility;
    })();
    SC2APIProtocol.ImageData = (function () {
        /**
         * Properties of an ImageData.
         * @memberof SC2APIProtocol
         * @interface IImageData
         * @property {number} [bitsPerPixel] ImageData bitsPerPixel
         * @property {SC2APIProtocol.ISize2DI} [size] ImageData size
         * @property {Uint8Array} [data] ImageData data
         */
        /**
         * Constructs a new ImageData.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ImageData.
         * @constructor
         * @param {SC2APIProtocol.IImageData=} [properties] Properties to set
         */
        function ImageData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ImageData bitsPerPixel.
         * @member {number}bitsPerPixel
         * @memberof SC2APIProtocol.ImageData
         * @instance
         */
        ImageData.prototype.bitsPerPixel = 0;
        /**
         * ImageData size.
         * @member {(SC2APIProtocol.ISize2DI|null|undefined)}size
         * @memberof SC2APIProtocol.ImageData
         * @instance
         */
        ImageData.prototype.size = null;
        /**
         * ImageData data.
         * @member {Uint8Array}data
         * @memberof SC2APIProtocol.ImageData
         * @instance
         */
        ImageData.prototype.data = $util.newBuffer([]);
        /**
         * Creates a new ImageData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {SC2APIProtocol.IImageData=} [properties] Properties to set
         * @returns {SC2APIProtocol.ImageData} ImageData instance
         */
        ImageData.create = function create(properties) {
            return new ImageData(properties);
        };
        /**
         * Encodes the specified ImageData message. Does not implicitly {@link SC2APIProtocol.ImageData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {SC2APIProtocol.IImageData} message ImageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bitsPerPixel != null && message.hasOwnProperty("bitsPerPixel"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.bitsPerPixel);
            if (message.size != null && message.hasOwnProperty("size"))
                $root.SC2APIProtocol.Size2DI.encode(message.size, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.data);
            return writer;
        };
        /**
         * Encodes the specified ImageData message, length delimited. Does not implicitly {@link SC2APIProtocol.ImageData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {SC2APIProtocol.IImageData} message ImageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ImageData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ImageData} ImageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ImageData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.bitsPerPixel = reader.int32();
                        break;
                    case 2:
                        message.size = $root.SC2APIProtocol.Size2DI.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ImageData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ImageData} ImageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ImageData message.
         * @function verify
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bitsPerPixel != null && message.hasOwnProperty("bitsPerPixel"))
                if (!$util.isInteger(message.bitsPerPixel))
                    return "bitsPerPixel: integer expected";
            if (message.size != null && message.hasOwnProperty("size")) {
                var error = $root.SC2APIProtocol.Size2DI.verify(message.size);
                if (error)
                    return "size." + error;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
        /**
         * Creates an ImageData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ImageData} ImageData
         */
        ImageData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ImageData)
                return object;
            var message = new $root.SC2APIProtocol.ImageData();
            if (object.bitsPerPixel != null)
                message.bitsPerPixel = object.bitsPerPixel | 0;
            if (object.size != null) {
                if (typeof object.size !== "object")
                    throw TypeError(".SC2APIProtocol.ImageData.size: object expected");
                message.size = $root.SC2APIProtocol.Size2DI.fromObject(object.size);
            }
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
        /**
         * Creates a plain object from an ImageData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ImageData
         * @static
         * @param {SC2APIProtocol.ImageData} message ImageData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bitsPerPixel = 0;
                object.size = null;
                object.data = options.bytes === String ? "" : [];
            }
            if (message.bitsPerPixel != null && message.hasOwnProperty("bitsPerPixel"))
                object.bitsPerPixel = message.bitsPerPixel;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = $root.SC2APIProtocol.Size2DI.toObject(message.size, options);
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
        /**
         * Converts this ImageData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ImageData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ImageData;
    })();
    SC2APIProtocol.PointI = (function () {
        /**
         * Properties of a PointI.
         * @memberof SC2APIProtocol
         * @interface IPointI
         * @property {number} [x] PointI x
         * @property {number} [y] PointI y
         */
        /**
         * Constructs a new PointI.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PointI.
         * @constructor
         * @param {SC2APIProtocol.IPointI=} [properties] Properties to set
         */
        function PointI(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PointI x.
         * @member {number}x
         * @memberof SC2APIProtocol.PointI
         * @instance
         */
        PointI.prototype.x = 0;
        /**
         * PointI y.
         * @member {number}y
         * @memberof SC2APIProtocol.PointI
         * @instance
         */
        PointI.prototype.y = 0;
        /**
         * Creates a new PointI instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {SC2APIProtocol.IPointI=} [properties] Properties to set
         * @returns {SC2APIProtocol.PointI} PointI instance
         */
        PointI.create = function create(properties) {
            return new PointI(properties);
        };
        /**
         * Encodes the specified PointI message. Does not implicitly {@link SC2APIProtocol.PointI.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {SC2APIProtocol.IPointI} message PointI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PointI.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.y);
            return writer;
        };
        /**
         * Encodes the specified PointI message, length delimited. Does not implicitly {@link SC2APIProtocol.PointI.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {SC2APIProtocol.IPointI} message PointI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PointI.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PointI message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PointI} PointI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PointI.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PointI();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.y = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PointI message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PointI} PointI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PointI.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PointI message.
         * @function verify
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PointI.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            return null;
        };
        /**
         * Creates a PointI message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PointI} PointI
         */
        PointI.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PointI)
                return object;
            var message = new $root.SC2APIProtocol.PointI();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            return message;
        };
        /**
         * Creates a plain object from a PointI message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PointI
         * @static
         * @param {SC2APIProtocol.PointI} message PointI
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PointI.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            return object;
        };
        /**
         * Converts this PointI to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PointI
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PointI.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PointI;
    })();
    SC2APIProtocol.RectangleI = (function () {
        /**
         * Properties of a RectangleI.
         * @memberof SC2APIProtocol
         * @interface IRectangleI
         * @property {SC2APIProtocol.IPointI} [p0] RectangleI p0
         * @property {SC2APIProtocol.IPointI} [p1] RectangleI p1
         */
        /**
         * Constructs a new RectangleI.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RectangleI.
         * @constructor
         * @param {SC2APIProtocol.IRectangleI=} [properties] Properties to set
         */
        function RectangleI(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RectangleI p0.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}p0
         * @memberof SC2APIProtocol.RectangleI
         * @instance
         */
        RectangleI.prototype.p0 = null;
        /**
         * RectangleI p1.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}p1
         * @memberof SC2APIProtocol.RectangleI
         * @instance
         */
        RectangleI.prototype.p1 = null;
        /**
         * Creates a new RectangleI instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {SC2APIProtocol.IRectangleI=} [properties] Properties to set
         * @returns {SC2APIProtocol.RectangleI} RectangleI instance
         */
        RectangleI.create = function create(properties) {
            return new RectangleI(properties);
        };
        /**
         * Encodes the specified RectangleI message. Does not implicitly {@link SC2APIProtocol.RectangleI.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {SC2APIProtocol.IRectangleI} message RectangleI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RectangleI.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && message.hasOwnProperty("p0"))
                $root.SC2APIProtocol.PointI.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.p1 != null && message.hasOwnProperty("p1"))
                $root.SC2APIProtocol.PointI.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified RectangleI message, length delimited. Does not implicitly {@link SC2APIProtocol.RectangleI.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {SC2APIProtocol.IRectangleI} message RectangleI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RectangleI.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RectangleI message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RectangleI} RectangleI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RectangleI.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RectangleI();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.p0 = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.p1 = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RectangleI message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RectangleI} RectangleI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RectangleI.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RectangleI message.
         * @function verify
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RectangleI.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.SC2APIProtocol.PointI.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                error = $root.SC2APIProtocol.PointI.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            return null;
        };
        /**
         * Creates a RectangleI message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RectangleI} RectangleI
         */
        RectangleI.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RectangleI)
                return object;
            var message = new $root.SC2APIProtocol.RectangleI();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".SC2APIProtocol.RectangleI.p0: object expected");
                message.p0 = $root.SC2APIProtocol.PointI.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".SC2APIProtocol.RectangleI.p1: object expected");
                message.p1 = $root.SC2APIProtocol.PointI.fromObject(object.p1);
            }
            return message;
        };
        /**
         * Creates a plain object from a RectangleI message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RectangleI
         * @static
         * @param {SC2APIProtocol.RectangleI} message RectangleI
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RectangleI.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.SC2APIProtocol.PointI.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.SC2APIProtocol.PointI.toObject(message.p1, options);
            return object;
        };
        /**
         * Converts this RectangleI to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RectangleI
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RectangleI.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RectangleI;
    })();
    SC2APIProtocol.Point2D = (function () {
        /**
         * Properties of a Point2D.
         * @memberof SC2APIProtocol
         * @interface IPoint2D
         * @property {number} [x] Point2D x
         * @property {number} [y] Point2D y
         */
        /**
         * Constructs a new Point2D.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Point2D.
         * @constructor
         * @param {SC2APIProtocol.IPoint2D=} [properties] Properties to set
         */
        function Point2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Point2D x.
         * @member {number}x
         * @memberof SC2APIProtocol.Point2D
         * @instance
         */
        Point2D.prototype.x = 0;
        /**
         * Point2D y.
         * @member {number}y
         * @memberof SC2APIProtocol.Point2D
         * @instance
         */
        Point2D.prototype.y = 0;
        /**
         * Creates a new Point2D instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {SC2APIProtocol.IPoint2D=} [properties] Properties to set
         * @returns {SC2APIProtocol.Point2D} Point2D instance
         */
        Point2D.create = function create(properties) {
            return new Point2D(properties);
        };
        /**
         * Encodes the specified Point2D message. Does not implicitly {@link SC2APIProtocol.Point2D.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {SC2APIProtocol.IPoint2D} message Point2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.y);
            return writer;
        };
        /**
         * Encodes the specified Point2D message, length delimited. Does not implicitly {@link SC2APIProtocol.Point2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {SC2APIProtocol.IPoint2D} message Point2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Point2D message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Point2D} Point2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Point2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.x = reader.float();
                        break;
                    case 2:
                        message.y = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Point2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Point2D} Point2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Point2D message.
         * @function verify
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Point2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
        /**
         * Creates a Point2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Point2D} Point2D
         */
        Point2D.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Point2D)
                return object;
            var message = new $root.SC2APIProtocol.Point2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
        /**
         * Creates a plain object from a Point2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Point2D
         * @static
         * @param {SC2APIProtocol.Point2D} message Point2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Point2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
        /**
         * Converts this Point2D to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Point2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Point2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Point2D;
    })();
    SC2APIProtocol.Point = (function () {
        /**
         * Properties of a Point.
         * @memberof SC2APIProtocol
         * @interface IPoint
         * @property {number} [x] Point x
         * @property {number} [y] Point y
         * @property {number} [z] Point z
         */
        /**
         * Constructs a new Point.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Point.
         * @constructor
         * @param {SC2APIProtocol.IPoint=} [properties] Properties to set
         */
        function Point(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Point x.
         * @member {number}x
         * @memberof SC2APIProtocol.Point
         * @instance
         */
        Point.prototype.x = 0;
        /**
         * Point y.
         * @member {number}y
         * @memberof SC2APIProtocol.Point
         * @instance
         */
        Point.prototype.y = 0;
        /**
         * Point z.
         * @member {number}z
         * @memberof SC2APIProtocol.Point
         * @instance
         */
        Point.prototype.z = 0;
        /**
         * Creates a new Point instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {SC2APIProtocol.IPoint=} [properties] Properties to set
         * @returns {SC2APIProtocol.Point} Point instance
         */
        Point.create = function create(properties) {
            return new Point(properties);
        };
        /**
         * Encodes the specified Point message. Does not implicitly {@link SC2APIProtocol.Point.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {SC2APIProtocol.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.y);
            if (message.z != null && message.hasOwnProperty("z"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.z);
            return writer;
        };
        /**
         * Encodes the specified Point message, length delimited. Does not implicitly {@link SC2APIProtocol.Point.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {SC2APIProtocol.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Point message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Point();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.x = reader.float();
                        break;
                    case 2:
                        message.y = reader.float();
                        break;
                    case 3:
                        message.z = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Point message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Point message.
         * @function verify
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Point.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
        /**
         * Creates a Point message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Point} Point
         */
        Point.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Point)
                return object;
            var message = new $root.SC2APIProtocol.Point();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
        /**
         * Creates a plain object from a Point message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Point
         * @static
         * @param {SC2APIProtocol.Point} message Point
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Point.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
        /**
         * Converts this Point to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Point
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Point.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Point;
    })();
    SC2APIProtocol.Size2DI = (function () {
        /**
         * Properties of a Size2DI.
         * @memberof SC2APIProtocol
         * @interface ISize2DI
         * @property {number} [x] Size2DI x
         * @property {number} [y] Size2DI y
         */
        /**
         * Constructs a new Size2DI.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Size2DI.
         * @constructor
         * @param {SC2APIProtocol.ISize2DI=} [properties] Properties to set
         */
        function Size2DI(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Size2DI x.
         * @member {number}x
         * @memberof SC2APIProtocol.Size2DI
         * @instance
         */
        Size2DI.prototype.x = 0;
        /**
         * Size2DI y.
         * @member {number}y
         * @memberof SC2APIProtocol.Size2DI
         * @instance
         */
        Size2DI.prototype.y = 0;
        /**
         * Creates a new Size2DI instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {SC2APIProtocol.ISize2DI=} [properties] Properties to set
         * @returns {SC2APIProtocol.Size2DI} Size2DI instance
         */
        Size2DI.create = function create(properties) {
            return new Size2DI(properties);
        };
        /**
         * Encodes the specified Size2DI message. Does not implicitly {@link SC2APIProtocol.Size2DI.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {SC2APIProtocol.ISize2DI} message Size2DI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Size2DI.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.y);
            return writer;
        };
        /**
         * Encodes the specified Size2DI message, length delimited. Does not implicitly {@link SC2APIProtocol.Size2DI.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {SC2APIProtocol.ISize2DI} message Size2DI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Size2DI.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Size2DI message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Size2DI} Size2DI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Size2DI.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Size2DI();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.y = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Size2DI message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Size2DI} Size2DI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Size2DI.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Size2DI message.
         * @function verify
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Size2DI.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            return null;
        };
        /**
         * Creates a Size2DI message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Size2DI} Size2DI
         */
        Size2DI.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Size2DI)
                return object;
            var message = new $root.SC2APIProtocol.Size2DI();
            if (object.x != null)
                message.x = object.x | 0;
            if (object.y != null)
                message.y = object.y | 0;
            return message;
        };
        /**
         * Creates a plain object from a Size2DI message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Size2DI
         * @static
         * @param {SC2APIProtocol.Size2DI} message Size2DI
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Size2DI.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            return object;
        };
        /**
         * Converts this Size2DI to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Size2DI
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Size2DI.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Size2DI;
    })();
    /**
     * Race enum.
     * @enum {string}
     * @property {number} NoRace=0 NoRace value
     * @property {number} Terran=1 Terran value
     * @property {number} Zerg=2 Zerg value
     * @property {number} Protoss=3 Protoss value
     * @property {number} Random=4 Random value
     */
    SC2APIProtocol.Race = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoRace"] = 0;
        values[valuesById[1] = "Terran"] = 1;
        values[valuesById[2] = "Zerg"] = 2;
        values[valuesById[3] = "Protoss"] = 3;
        values[valuesById[4] = "Random"] = 4;
        return values;
    })();
    SC2APIProtocol.AbilityData = (function () {
        /**
         * Properties of an AbilityData.
         * @memberof SC2APIProtocol
         * @interface IAbilityData
         * @property {number} [abilityId] AbilityData abilityId
         * @property {string} [linkName] AbilityData linkName
         * @property {number} [linkIndex] AbilityData linkIndex
         * @property {string} [buttonName] AbilityData buttonName
         * @property {string} [friendlyName] AbilityData friendlyName
         * @property {string} [hotkey] AbilityData hotkey
         * @property {number} [remapsToAbilityId] AbilityData remapsToAbilityId
         * @property {boolean} [available] AbilityData available
         * @property {SC2APIProtocol.AbilityData.Target} [target] AbilityData target
         * @property {boolean} [allowMinimap] AbilityData allowMinimap
         * @property {boolean} [allowAutocast] AbilityData allowAutocast
         * @property {boolean} [isBuilding] AbilityData isBuilding
         * @property {number} [footprintRadius] AbilityData footprintRadius
         * @property {boolean} [isInstantPlacement] AbilityData isInstantPlacement
         * @property {number} [castRange] AbilityData castRange
         */
        /**
         * Constructs a new AbilityData.
         * @memberof SC2APIProtocol
         * @classdesc Represents an AbilityData.
         * @constructor
         * @param {SC2APIProtocol.IAbilityData=} [properties] Properties to set
         */
        function AbilityData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * AbilityData abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.abilityId = 0;
        /**
         * AbilityData linkName.
         * @member {string}linkName
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.linkName = "";
        /**
         * AbilityData linkIndex.
         * @member {number}linkIndex
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.linkIndex = 0;
        /**
         * AbilityData buttonName.
         * @member {string}buttonName
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.buttonName = "";
        /**
         * AbilityData friendlyName.
         * @member {string}friendlyName
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.friendlyName = "";
        /**
         * AbilityData hotkey.
         * @member {string}hotkey
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.hotkey = "";
        /**
         * AbilityData remapsToAbilityId.
         * @member {number}remapsToAbilityId
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.remapsToAbilityId = 0;
        /**
         * AbilityData available.
         * @member {boolean}available
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.available = false;
        /**
         * AbilityData target.
         * @member {SC2APIProtocol.AbilityData.Target}target
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.target = 1;
        /**
         * AbilityData allowMinimap.
         * @member {boolean}allowMinimap
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.allowMinimap = false;
        /**
         * AbilityData allowAutocast.
         * @member {boolean}allowAutocast
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.allowAutocast = false;
        /**
         * AbilityData isBuilding.
         * @member {boolean}isBuilding
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.isBuilding = false;
        /**
         * AbilityData footprintRadius.
         * @member {number}footprintRadius
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.footprintRadius = 0;
        /**
         * AbilityData isInstantPlacement.
         * @member {boolean}isInstantPlacement
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.isInstantPlacement = false;
        /**
         * AbilityData castRange.
         * @member {number}castRange
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         */
        AbilityData.prototype.castRange = 0;
        /**
         * Creates a new AbilityData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {SC2APIProtocol.IAbilityData=} [properties] Properties to set
         * @returns {SC2APIProtocol.AbilityData} AbilityData instance
         */
        AbilityData.create = function create(properties) {
            return new AbilityData(properties);
        };
        /**
         * Encodes the specified AbilityData message. Does not implicitly {@link SC2APIProtocol.AbilityData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {SC2APIProtocol.IAbilityData} message AbilityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbilityData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.abilityId);
            if (message.linkName != null && message.hasOwnProperty("linkName"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.linkName);
            if (message.linkIndex != null && message.hasOwnProperty("linkIndex"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.linkIndex);
            if (message.buttonName != null && message.hasOwnProperty("buttonName"))
                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.buttonName);
            if (message.friendlyName != null && message.hasOwnProperty("friendlyName"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.friendlyName);
            if (message.hotkey != null && message.hasOwnProperty("hotkey"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.hotkey);
            if (message.remapsToAbilityId != null && message.hasOwnProperty("remapsToAbilityId"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).uint32(message.remapsToAbilityId);
            if (message.available != null && message.hasOwnProperty("available"))
                writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.available);
            if (message.target != null && message.hasOwnProperty("target"))
                writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.target);
            if (message.allowMinimap != null && message.hasOwnProperty("allowMinimap"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.allowMinimap);
            if (message.allowAutocast != null && message.hasOwnProperty("allowAutocast"))
                writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.allowAutocast);
            if (message.isBuilding != null && message.hasOwnProperty("isBuilding"))
                writer.uint32(/* id 12, wireType 0 =*/ 96).bool(message.isBuilding);
            if (message.footprintRadius != null && message.hasOwnProperty("footprintRadius"))
                writer.uint32(/* id 13, wireType 5 =*/ 109).float(message.footprintRadius);
            if (message.isInstantPlacement != null && message.hasOwnProperty("isInstantPlacement"))
                writer.uint32(/* id 14, wireType 0 =*/ 112).bool(message.isInstantPlacement);
            if (message.castRange != null && message.hasOwnProperty("castRange"))
                writer.uint32(/* id 15, wireType 5 =*/ 125).float(message.castRange);
            return writer;
        };
        /**
         * Encodes the specified AbilityData message, length delimited. Does not implicitly {@link SC2APIProtocol.AbilityData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {SC2APIProtocol.IAbilityData} message AbilityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbilityData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an AbilityData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.AbilityData} AbilityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbilityData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.AbilityData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.uint32();
                        break;
                    case 2:
                        message.linkName = reader.string();
                        break;
                    case 3:
                        message.linkIndex = reader.uint32();
                        break;
                    case 4:
                        message.buttonName = reader.string();
                        break;
                    case 5:
                        message.friendlyName = reader.string();
                        break;
                    case 6:
                        message.hotkey = reader.string();
                        break;
                    case 7:
                        message.remapsToAbilityId = reader.uint32();
                        break;
                    case 8:
                        message.available = reader.bool();
                        break;
                    case 9:
                        message.target = reader.int32();
                        break;
                    case 10:
                        message.allowMinimap = reader.bool();
                        break;
                    case 11:
                        message.allowAutocast = reader.bool();
                        break;
                    case 12:
                        message.isBuilding = reader.bool();
                        break;
                    case 13:
                        message.footprintRadius = reader.float();
                        break;
                    case 14:
                        message.isInstantPlacement = reader.bool();
                        break;
                    case 15:
                        message.castRange = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an AbilityData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.AbilityData} AbilityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbilityData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an AbilityData message.
         * @function verify
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AbilityData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.linkName != null && message.hasOwnProperty("linkName"))
                if (!$util.isString(message.linkName))
                    return "linkName: string expected";
            if (message.linkIndex != null && message.hasOwnProperty("linkIndex"))
                if (!$util.isInteger(message.linkIndex))
                    return "linkIndex: integer expected";
            if (message.buttonName != null && message.hasOwnProperty("buttonName"))
                if (!$util.isString(message.buttonName))
                    return "buttonName: string expected";
            if (message.friendlyName != null && message.hasOwnProperty("friendlyName"))
                if (!$util.isString(message.friendlyName))
                    return "friendlyName: string expected";
            if (message.hotkey != null && message.hasOwnProperty("hotkey"))
                if (!$util.isString(message.hotkey))
                    return "hotkey: string expected";
            if (message.remapsToAbilityId != null && message.hasOwnProperty("remapsToAbilityId"))
                if (!$util.isInteger(message.remapsToAbilityId))
                    return "remapsToAbilityId: integer expected";
            if (message.available != null && message.hasOwnProperty("available"))
                if (typeof message.available !== "boolean")
                    return "available: boolean expected";
            if (message.target != null && message.hasOwnProperty("target"))
                switch (message.target) {
                    default:
                        return "target: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                }
            if (message.allowMinimap != null && message.hasOwnProperty("allowMinimap"))
                if (typeof message.allowMinimap !== "boolean")
                    return "allowMinimap: boolean expected";
            if (message.allowAutocast != null && message.hasOwnProperty("allowAutocast"))
                if (typeof message.allowAutocast !== "boolean")
                    return "allowAutocast: boolean expected";
            if (message.isBuilding != null && message.hasOwnProperty("isBuilding"))
                if (typeof message.isBuilding !== "boolean")
                    return "isBuilding: boolean expected";
            if (message.footprintRadius != null && message.hasOwnProperty("footprintRadius"))
                if (typeof message.footprintRadius !== "number")
                    return "footprintRadius: number expected";
            if (message.isInstantPlacement != null && message.hasOwnProperty("isInstantPlacement"))
                if (typeof message.isInstantPlacement !== "boolean")
                    return "isInstantPlacement: boolean expected";
            if (message.castRange != null && message.hasOwnProperty("castRange"))
                if (typeof message.castRange !== "number")
                    return "castRange: number expected";
            return null;
        };
        /**
         * Creates an AbilityData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.AbilityData} AbilityData
         */
        AbilityData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.AbilityData)
                return object;
            var message = new $root.SC2APIProtocol.AbilityData();
            if (object.abilityId != null)
                message.abilityId = object.abilityId >>> 0;
            if (object.linkName != null)
                message.linkName = String(object.linkName);
            if (object.linkIndex != null)
                message.linkIndex = object.linkIndex >>> 0;
            if (object.buttonName != null)
                message.buttonName = String(object.buttonName);
            if (object.friendlyName != null)
                message.friendlyName = String(object.friendlyName);
            if (object.hotkey != null)
                message.hotkey = String(object.hotkey);
            if (object.remapsToAbilityId != null)
                message.remapsToAbilityId = object.remapsToAbilityId >>> 0;
            if (object.available != null)
                message.available = Boolean(object.available);
            switch (object.target) {
                case "None":
                case 1:
                    message.target = 1;
                    break;
                case "Point":
                case 2:
                    message.target = 2;
                    break;
                case "Unit":
                case 3:
                    message.target = 3;
                    break;
                case "PointOrUnit":
                case 4:
                    message.target = 4;
                    break;
                case "PointOrNone":
                case 5:
                    message.target = 5;
                    break;
            }
            if (object.allowMinimap != null)
                message.allowMinimap = Boolean(object.allowMinimap);
            if (object.allowAutocast != null)
                message.allowAutocast = Boolean(object.allowAutocast);
            if (object.isBuilding != null)
                message.isBuilding = Boolean(object.isBuilding);
            if (object.footprintRadius != null)
                message.footprintRadius = Number(object.footprintRadius);
            if (object.isInstantPlacement != null)
                message.isInstantPlacement = Boolean(object.isInstantPlacement);
            if (object.castRange != null)
                message.castRange = Number(object.castRange);
            return message;
        };
        /**
         * Creates a plain object from an AbilityData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.AbilityData
         * @static
         * @param {SC2APIProtocol.AbilityData} message AbilityData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AbilityData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = 0;
                object.linkName = "";
                object.linkIndex = 0;
                object.buttonName = "";
                object.friendlyName = "";
                object.hotkey = "";
                object.remapsToAbilityId = 0;
                object.available = false;
                object.target = options.enums === String ? "None" : 1;
                object.allowMinimap = false;
                object.allowAutocast = false;
                object.isBuilding = false;
                object.footprintRadius = 0;
                object.isInstantPlacement = false;
                object.castRange = 0;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.linkName != null && message.hasOwnProperty("linkName"))
                object.linkName = message.linkName;
            if (message.linkIndex != null && message.hasOwnProperty("linkIndex"))
                object.linkIndex = message.linkIndex;
            if (message.buttonName != null && message.hasOwnProperty("buttonName"))
                object.buttonName = message.buttonName;
            if (message.friendlyName != null && message.hasOwnProperty("friendlyName"))
                object.friendlyName = message.friendlyName;
            if (message.hotkey != null && message.hasOwnProperty("hotkey"))
                object.hotkey = message.hotkey;
            if (message.remapsToAbilityId != null && message.hasOwnProperty("remapsToAbilityId"))
                object.remapsToAbilityId = message.remapsToAbilityId;
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = options.enums === String ? $root.SC2APIProtocol.AbilityData.Target[message.target] : message.target;
            if (message.allowMinimap != null && message.hasOwnProperty("allowMinimap"))
                object.allowMinimap = message.allowMinimap;
            if (message.allowAutocast != null && message.hasOwnProperty("allowAutocast"))
                object.allowAutocast = message.allowAutocast;
            if (message.isBuilding != null && message.hasOwnProperty("isBuilding"))
                object.isBuilding = message.isBuilding;
            if (message.footprintRadius != null && message.hasOwnProperty("footprintRadius"))
                object.footprintRadius = options.json && !isFinite(message.footprintRadius) ? String(message.footprintRadius) : message.footprintRadius;
            if (message.isInstantPlacement != null && message.hasOwnProperty("isInstantPlacement"))
                object.isInstantPlacement = message.isInstantPlacement;
            if (message.castRange != null && message.hasOwnProperty("castRange"))
                object.castRange = options.json && !isFinite(message.castRange) ? String(message.castRange) : message.castRange;
            return object;
        };
        /**
         * Converts this AbilityData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.AbilityData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AbilityData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Target enum.
         * @enum {string}
         * @property {number} None=1 None value
         * @property {number} Point=2 Point value
         * @property {number} Unit=3 Unit value
         * @property {number} PointOrUnit=4 PointOrUnit value
         * @property {number} PointOrNone=5 PointOrNone value
         */
        AbilityData.Target = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "None"] = 1;
            values[valuesById[2] = "Point"] = 2;
            values[valuesById[3] = "Unit"] = 3;
            values[valuesById[4] = "PointOrUnit"] = 4;
            values[valuesById[5] = "PointOrNone"] = 5;
            return values;
        })();
        return AbilityData;
    })();
    /**
     * Attribute enum.
     * @enum {string}
     * @property {number} Light=1 Light value
     * @property {number} Armored=2 Armored value
     * @property {number} Biological=3 Biological value
     * @property {number} Mechanical=4 Mechanical value
     * @property {number} Robotic=5 Robotic value
     * @property {number} Psionic=6 Psionic value
     * @property {number} Massive=7 Massive value
     * @property {number} Structure=8 Structure value
     * @property {number} Hover=9 Hover value
     * @property {number} Heroic=10 Heroic value
     * @property {number} Summoned=11 Summoned value
     */
    SC2APIProtocol.Attribute = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Light"] = 1;
        values[valuesById[2] = "Armored"] = 2;
        values[valuesById[3] = "Biological"] = 3;
        values[valuesById[4] = "Mechanical"] = 4;
        values[valuesById[5] = "Robotic"] = 5;
        values[valuesById[6] = "Psionic"] = 6;
        values[valuesById[7] = "Massive"] = 7;
        values[valuesById[8] = "Structure"] = 8;
        values[valuesById[9] = "Hover"] = 9;
        values[valuesById[10] = "Heroic"] = 10;
        values[valuesById[11] = "Summoned"] = 11;
        return values;
    })();
    SC2APIProtocol.DamageBonus = (function () {
        /**
         * Properties of a DamageBonus.
         * @memberof SC2APIProtocol
         * @interface IDamageBonus
         * @property {SC2APIProtocol.Attribute} [attribute] DamageBonus attribute
         * @property {number} [bonus] DamageBonus bonus
         */
        /**
         * Constructs a new DamageBonus.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DamageBonus.
         * @constructor
         * @param {SC2APIProtocol.IDamageBonus=} [properties] Properties to set
         */
        function DamageBonus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DamageBonus attribute.
         * @member {SC2APIProtocol.Attribute}attribute
         * @memberof SC2APIProtocol.DamageBonus
         * @instance
         */
        DamageBonus.prototype.attribute = 1;
        /**
         * DamageBonus bonus.
         * @member {number}bonus
         * @memberof SC2APIProtocol.DamageBonus
         * @instance
         */
        DamageBonus.prototype.bonus = 0;
        /**
         * Creates a new DamageBonus instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {SC2APIProtocol.IDamageBonus=} [properties] Properties to set
         * @returns {SC2APIProtocol.DamageBonus} DamageBonus instance
         */
        DamageBonus.create = function create(properties) {
            return new DamageBonus(properties);
        };
        /**
         * Encodes the specified DamageBonus message. Does not implicitly {@link SC2APIProtocol.DamageBonus.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {SC2APIProtocol.IDamageBonus} message DamageBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DamageBonus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attribute != null && message.hasOwnProperty("attribute"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.attribute);
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.bonus);
            return writer;
        };
        /**
         * Encodes the specified DamageBonus message, length delimited. Does not implicitly {@link SC2APIProtocol.DamageBonus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {SC2APIProtocol.IDamageBonus} message DamageBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DamageBonus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DamageBonus message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DamageBonus} DamageBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DamageBonus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DamageBonus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.attribute = reader.int32();
                        break;
                    case 2:
                        message.bonus = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DamageBonus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DamageBonus} DamageBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DamageBonus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DamageBonus message.
         * @function verify
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DamageBonus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attribute != null && message.hasOwnProperty("attribute"))
                switch (message.attribute) {
                    default:
                        return "attribute: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                }
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                if (typeof message.bonus !== "number")
                    return "bonus: number expected";
            return null;
        };
        /**
         * Creates a DamageBonus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DamageBonus} DamageBonus
         */
        DamageBonus.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DamageBonus)
                return object;
            var message = new $root.SC2APIProtocol.DamageBonus();
            switch (object.attribute) {
                case "Light":
                case 1:
                    message.attribute = 1;
                    break;
                case "Armored":
                case 2:
                    message.attribute = 2;
                    break;
                case "Biological":
                case 3:
                    message.attribute = 3;
                    break;
                case "Mechanical":
                case 4:
                    message.attribute = 4;
                    break;
                case "Robotic":
                case 5:
                    message.attribute = 5;
                    break;
                case "Psionic":
                case 6:
                    message.attribute = 6;
                    break;
                case "Massive":
                case 7:
                    message.attribute = 7;
                    break;
                case "Structure":
                case 8:
                    message.attribute = 8;
                    break;
                case "Hover":
                case 9:
                    message.attribute = 9;
                    break;
                case "Heroic":
                case 10:
                    message.attribute = 10;
                    break;
                case "Summoned":
                case 11:
                    message.attribute = 11;
                    break;
            }
            if (object.bonus != null)
                message.bonus = Number(object.bonus);
            return message;
        };
        /**
         * Creates a plain object from a DamageBonus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DamageBonus
         * @static
         * @param {SC2APIProtocol.DamageBonus} message DamageBonus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DamageBonus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attribute = options.enums === String ? "Light" : 1;
                object.bonus = 0;
            }
            if (message.attribute != null && message.hasOwnProperty("attribute"))
                object.attribute = options.enums === String ? $root.SC2APIProtocol.Attribute[message.attribute] : message.attribute;
            if (message.bonus != null && message.hasOwnProperty("bonus"))
                object.bonus = options.json && !isFinite(message.bonus) ? String(message.bonus) : message.bonus;
            return object;
        };
        /**
         * Converts this DamageBonus to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DamageBonus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DamageBonus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DamageBonus;
    })();
    SC2APIProtocol.Weapon = (function () {
        /**
         * Properties of a Weapon.
         * @memberof SC2APIProtocol
         * @interface IWeapon
         * @property {SC2APIProtocol.Weapon.TargetType} [type] Weapon type
         * @property {number} [damage] Weapon damage
         * @property {Array.<SC2APIProtocol.IDamageBonus>} [damageBonus] Weapon damageBonus
         * @property {number} [attacks] Weapon attacks
         * @property {number} [range] Weapon range
         * @property {number} [speed] Weapon speed
         */
        /**
         * Constructs a new Weapon.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Weapon.
         * @constructor
         * @param {SC2APIProtocol.IWeapon=} [properties] Properties to set
         */
        function Weapon(properties) {
            this.damageBonus = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Weapon type.
         * @member {SC2APIProtocol.Weapon.TargetType}type
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.type = 1;
        /**
         * Weapon damage.
         * @member {number}damage
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.damage = 0;
        /**
         * Weapon damageBonus.
         * @member {Array.<SC2APIProtocol.IDamageBonus>}damageBonus
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.damageBonus = $util.emptyArray;
        /**
         * Weapon attacks.
         * @member {number}attacks
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.attacks = 0;
        /**
         * Weapon range.
         * @member {number}range
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.range = 0;
        /**
         * Weapon speed.
         * @member {number}speed
         * @memberof SC2APIProtocol.Weapon
         * @instance
         */
        Weapon.prototype.speed = 0;
        /**
         * Creates a new Weapon instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {SC2APIProtocol.IWeapon=} [properties] Properties to set
         * @returns {SC2APIProtocol.Weapon} Weapon instance
         */
        Weapon.create = function create(properties) {
            return new Weapon(properties);
        };
        /**
         * Encodes the specified Weapon message. Does not implicitly {@link SC2APIProtocol.Weapon.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {SC2APIProtocol.IWeapon} message Weapon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Weapon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
            if (message.damage != null && message.hasOwnProperty("damage"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.damage);
            if (message.damageBonus != null && message.damageBonus.length)
                for (var i = 0; i < message.damageBonus.length; ++i)
                    $root.SC2APIProtocol.DamageBonus.encode(message.damageBonus[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.attacks != null && message.hasOwnProperty("attacks"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.attacks);
            if (message.range != null && message.hasOwnProperty("range"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.range);
            if (message.speed != null && message.hasOwnProperty("speed"))
                writer.uint32(/* id 6, wireType 5 =*/ 53).float(message.speed);
            return writer;
        };
        /**
         * Encodes the specified Weapon message, length delimited. Does not implicitly {@link SC2APIProtocol.Weapon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {SC2APIProtocol.IWeapon} message Weapon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Weapon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Weapon message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Weapon} Weapon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Weapon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Weapon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.damage = reader.float();
                        break;
                    case 3:
                        if (!(message.damageBonus && message.damageBonus.length))
                            message.damageBonus = [];
                        message.damageBonus.push($root.SC2APIProtocol.DamageBonus.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.attacks = reader.uint32();
                        break;
                    case 5:
                        message.range = reader.float();
                        break;
                    case 6:
                        message.speed = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Weapon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Weapon} Weapon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Weapon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Weapon message.
         * @function verify
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Weapon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.damage != null && message.hasOwnProperty("damage"))
                if (typeof message.damage !== "number")
                    return "damage: number expected";
            if (message.damageBonus != null && message.hasOwnProperty("damageBonus")) {
                if (!Array.isArray(message.damageBonus))
                    return "damageBonus: array expected";
                for (var i = 0; i < message.damageBonus.length; ++i) {
                    var error = $root.SC2APIProtocol.DamageBonus.verify(message.damageBonus[i]);
                    if (error)
                        return "damageBonus." + error;
                }
            }
            if (message.attacks != null && message.hasOwnProperty("attacks"))
                if (!$util.isInteger(message.attacks))
                    return "attacks: integer expected";
            if (message.range != null && message.hasOwnProperty("range"))
                if (typeof message.range !== "number")
                    return "range: number expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            return null;
        };
        /**
         * Creates a Weapon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Weapon} Weapon
         */
        Weapon.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Weapon)
                return object;
            var message = new $root.SC2APIProtocol.Weapon();
            switch (object.type) {
                case "Ground":
                case 1:
                    message.type = 1;
                    break;
                case "Air":
                case 2:
                    message.type = 2;
                    break;
                case "Any":
                case 3:
                    message.type = 3;
                    break;
            }
            if (object.damage != null)
                message.damage = Number(object.damage);
            if (object.damageBonus) {
                if (!Array.isArray(object.damageBonus))
                    throw TypeError(".SC2APIProtocol.Weapon.damageBonus: array expected");
                message.damageBonus = [];
                for (var i = 0; i < object.damageBonus.length; ++i) {
                    if (typeof object.damageBonus[i] !== "object")
                        throw TypeError(".SC2APIProtocol.Weapon.damageBonus: object expected");
                    message.damageBonus[i] = $root.SC2APIProtocol.DamageBonus.fromObject(object.damageBonus[i]);
                }
            }
            if (object.attacks != null)
                message.attacks = object.attacks >>> 0;
            if (object.range != null)
                message.range = Number(object.range);
            if (object.speed != null)
                message.speed = Number(object.speed);
            return message;
        };
        /**
         * Creates a plain object from a Weapon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Weapon
         * @static
         * @param {SC2APIProtocol.Weapon} message Weapon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Weapon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.damageBonus = [];
            if (options.defaults) {
                object.type = options.enums === String ? "Ground" : 1;
                object.damage = 0;
                object.attacks = 0;
                object.range = 0;
                object.speed = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.Weapon.TargetType[message.type] : message.type;
            if (message.damage != null && message.hasOwnProperty("damage"))
                object.damage = options.json && !isFinite(message.damage) ? String(message.damage) : message.damage;
            if (message.damageBonus && message.damageBonus.length) {
                object.damageBonus = [];
                for (var j = 0; j < message.damageBonus.length; ++j)
                    object.damageBonus[j] = $root.SC2APIProtocol.DamageBonus.toObject(message.damageBonus[j], options);
            }
            if (message.attacks != null && message.hasOwnProperty("attacks"))
                object.attacks = message.attacks;
            if (message.range != null && message.hasOwnProperty("range"))
                object.range = options.json && !isFinite(message.range) ? String(message.range) : message.range;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            return object;
        };
        /**
         * Converts this Weapon to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Weapon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Weapon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * TargetType enum.
         * @enum {string}
         * @property {number} Ground=1 Ground value
         * @property {number} Air=2 Air value
         * @property {number} Any=3 Any value
         */
        Weapon.TargetType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Ground"] = 1;
            values[valuesById[2] = "Air"] = 2;
            values[valuesById[3] = "Any"] = 3;
            return values;
        })();
        return Weapon;
    })();
    SC2APIProtocol.UnitTypeData = (function () {
        /**
         * Properties of an UnitTypeData.
         * @memberof SC2APIProtocol
         * @interface IUnitTypeData
         * @property {number} [unitId] UnitTypeData unitId
         * @property {string} [name] UnitTypeData name
         * @property {boolean} [available] UnitTypeData available
         * @property {number} [cargoSize] UnitTypeData cargoSize
         * @property {number} [mineralCost] UnitTypeData mineralCost
         * @property {number} [vespeneCost] UnitTypeData vespeneCost
         * @property {number} [foodRequired] UnitTypeData foodRequired
         * @property {number} [foodProvided] UnitTypeData foodProvided
         * @property {number} [abilityId] UnitTypeData abilityId
         * @property {SC2APIProtocol.Race} [race] UnitTypeData race
         * @property {number} [buildTime] UnitTypeData buildTime
         * @property {boolean} [hasVespene] UnitTypeData hasVespene
         * @property {boolean} [hasMinerals] UnitTypeData hasMinerals
         * @property {Array.<number>} [techAlias] UnitTypeData techAlias
         * @property {number} [unitAlias] UnitTypeData unitAlias
         * @property {number} [techRequirement] UnitTypeData techRequirement
         * @property {boolean} [requireAttached] UnitTypeData requireAttached
         * @property {Array.<SC2APIProtocol.Attribute>} [attributes] UnitTypeData attributes
         * @property {number} [movementSpeed] UnitTypeData movementSpeed
         * @property {number} [armor] UnitTypeData armor
         * @property {Array.<SC2APIProtocol.IWeapon>} [weapons] UnitTypeData weapons
         */
        /**
         * Constructs a new UnitTypeData.
         * @memberof SC2APIProtocol
         * @classdesc Represents an UnitTypeData.
         * @constructor
         * @param {SC2APIProtocol.IUnitTypeData=} [properties] Properties to set
         */
        function UnitTypeData(properties) {
            this.techAlias = [];
            this.attributes = [];
            this.weapons = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UnitTypeData unitId.
         * @member {number}unitId
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.unitId = 0;
        /**
         * UnitTypeData name.
         * @member {string}name
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.name = "";
        /**
         * UnitTypeData available.
         * @member {boolean}available
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.available = false;
        /**
         * UnitTypeData cargoSize.
         * @member {number}cargoSize
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.cargoSize = 0;
        /**
         * UnitTypeData mineralCost.
         * @member {number}mineralCost
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.mineralCost = 0;
        /**
         * UnitTypeData vespeneCost.
         * @member {number}vespeneCost
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.vespeneCost = 0;
        /**
         * UnitTypeData foodRequired.
         * @member {number}foodRequired
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.foodRequired = 0;
        /**
         * UnitTypeData foodProvided.
         * @member {number}foodProvided
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.foodProvided = 0;
        /**
         * UnitTypeData abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.abilityId = 0;
        /**
         * UnitTypeData race.
         * @member {SC2APIProtocol.Race}race
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.race = 0;
        /**
         * UnitTypeData buildTime.
         * @member {number}buildTime
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.buildTime = 0;
        /**
         * UnitTypeData hasVespene.
         * @member {boolean}hasVespene
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.hasVespene = false;
        /**
         * UnitTypeData hasMinerals.
         * @member {boolean}hasMinerals
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.hasMinerals = false;
        /**
         * UnitTypeData techAlias.
         * @member {Array.<number>}techAlias
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.techAlias = $util.emptyArray;
        /**
         * UnitTypeData unitAlias.
         * @member {number}unitAlias
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.unitAlias = 0;
        /**
         * UnitTypeData techRequirement.
         * @member {number}techRequirement
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.techRequirement = 0;
        /**
         * UnitTypeData requireAttached.
         * @member {boolean}requireAttached
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.requireAttached = false;
        /**
         * UnitTypeData attributes.
         * @member {Array.<SC2APIProtocol.Attribute>}attributes
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.attributes = $util.emptyArray;
        /**
         * UnitTypeData movementSpeed.
         * @member {number}movementSpeed
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.movementSpeed = 0;
        /**
         * UnitTypeData armor.
         * @member {number}armor
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.armor = 0;
        /**
         * UnitTypeData weapons.
         * @member {Array.<SC2APIProtocol.IWeapon>}weapons
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         */
        UnitTypeData.prototype.weapons = $util.emptyArray;
        /**
         * Creates a new UnitTypeData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {SC2APIProtocol.IUnitTypeData=} [properties] Properties to set
         * @returns {SC2APIProtocol.UnitTypeData} UnitTypeData instance
         */
        UnitTypeData.create = function create(properties) {
            return new UnitTypeData(properties);
        };
        /**
         * Encodes the specified UnitTypeData message. Does not implicitly {@link SC2APIProtocol.UnitTypeData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {SC2APIProtocol.IUnitTypeData} message UnitTypeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitTypeData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.unitId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
            if (message.available != null && message.hasOwnProperty("available"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.available);
            if (message.cargoSize != null && message.hasOwnProperty("cargoSize"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.cargoSize);
            if (message.attributes != null && message.attributes.length)
                for (var i = 0; i < message.attributes.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.attributes[i]);
            if (message.movementSpeed != null && message.hasOwnProperty("movementSpeed"))
                writer.uint32(/* id 9, wireType 5 =*/ 77).float(message.movementSpeed);
            if (message.armor != null && message.hasOwnProperty("armor"))
                writer.uint32(/* id 10, wireType 5 =*/ 85).float(message.armor);
            if (message.weapons != null && message.weapons.length)
                for (var i = 0; i < message.weapons.length; ++i)
                    $root.SC2APIProtocol.Weapon.encode(message.weapons[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                writer.uint32(/* id 12, wireType 0 =*/ 96).uint32(message.mineralCost);
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                writer.uint32(/* id 13, wireType 0 =*/ 104).uint32(message.vespeneCost);
            if (message.foodRequired != null && message.hasOwnProperty("foodRequired"))
                writer.uint32(/* id 14, wireType 5 =*/ 117).float(message.foodRequired);
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 15, wireType 0 =*/ 120).uint32(message.abilityId);
            if (message.race != null && message.hasOwnProperty("race"))
                writer.uint32(/* id 16, wireType 0 =*/ 128).int32(message.race);
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                writer.uint32(/* id 17, wireType 5 =*/ 141).float(message.buildTime);
            if (message.foodProvided != null && message.hasOwnProperty("foodProvided"))
                writer.uint32(/* id 18, wireType 5 =*/ 149).float(message.foodProvided);
            if (message.hasVespene != null && message.hasOwnProperty("hasVespene"))
                writer.uint32(/* id 19, wireType 0 =*/ 152).bool(message.hasVespene);
            if (message.hasMinerals != null && message.hasOwnProperty("hasMinerals"))
                writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.hasMinerals);
            if (message.techAlias != null && message.techAlias.length)
                for (var i = 0; i < message.techAlias.length; ++i)
                    writer.uint32(/* id 21, wireType 0 =*/ 168).uint32(message.techAlias[i]);
            if (message.unitAlias != null && message.hasOwnProperty("unitAlias"))
                writer.uint32(/* id 22, wireType 0 =*/ 176).uint32(message.unitAlias);
            if (message.techRequirement != null && message.hasOwnProperty("techRequirement"))
                writer.uint32(/* id 23, wireType 0 =*/ 184).uint32(message.techRequirement);
            if (message.requireAttached != null && message.hasOwnProperty("requireAttached"))
                writer.uint32(/* id 24, wireType 0 =*/ 192).bool(message.requireAttached);
            return writer;
        };
        /**
         * Encodes the specified UnitTypeData message, length delimited. Does not implicitly {@link SC2APIProtocol.UnitTypeData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {SC2APIProtocol.IUnitTypeData} message UnitTypeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitTypeData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UnitTypeData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.UnitTypeData} UnitTypeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitTypeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.UnitTypeData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitId = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.available = reader.bool();
                        break;
                    case 4:
                        message.cargoSize = reader.uint32();
                        break;
                    case 12:
                        message.mineralCost = reader.uint32();
                        break;
                    case 13:
                        message.vespeneCost = reader.uint32();
                        break;
                    case 14:
                        message.foodRequired = reader.float();
                        break;
                    case 18:
                        message.foodProvided = reader.float();
                        break;
                    case 15:
                        message.abilityId = reader.uint32();
                        break;
                    case 16:
                        message.race = reader.int32();
                        break;
                    case 17:
                        message.buildTime = reader.float();
                        break;
                    case 19:
                        message.hasVespene = reader.bool();
                        break;
                    case 20:
                        message.hasMinerals = reader.bool();
                        break;
                    case 21:
                        if (!(message.techAlias && message.techAlias.length))
                            message.techAlias = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.techAlias.push(reader.uint32());
                        }
                        else
                            message.techAlias.push(reader.uint32());
                        break;
                    case 22:
                        message.unitAlias = reader.uint32();
                        break;
                    case 23:
                        message.techRequirement = reader.uint32();
                        break;
                    case 24:
                        message.requireAttached = reader.bool();
                        break;
                    case 8:
                        if (!(message.attributes && message.attributes.length))
                            message.attributes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.attributes.push(reader.int32());
                        }
                        else
                            message.attributes.push(reader.int32());
                        break;
                    case 9:
                        message.movementSpeed = reader.float();
                        break;
                    case 10:
                        message.armor = reader.float();
                        break;
                    case 11:
                        if (!(message.weapons && message.weapons.length))
                            message.weapons = [];
                        message.weapons.push($root.SC2APIProtocol.Weapon.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UnitTypeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.UnitTypeData} UnitTypeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitTypeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UnitTypeData message.
         * @function verify
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitTypeData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                if (!$util.isInteger(message.unitId))
                    return "unitId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.available != null && message.hasOwnProperty("available"))
                if (typeof message.available !== "boolean")
                    return "available: boolean expected";
            if (message.cargoSize != null && message.hasOwnProperty("cargoSize"))
                if (!$util.isInteger(message.cargoSize))
                    return "cargoSize: integer expected";
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                if (!$util.isInteger(message.mineralCost))
                    return "mineralCost: integer expected";
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                if (!$util.isInteger(message.vespeneCost))
                    return "vespeneCost: integer expected";
            if (message.foodRequired != null && message.hasOwnProperty("foodRequired"))
                if (typeof message.foodRequired !== "number")
                    return "foodRequired: number expected";
            if (message.foodProvided != null && message.hasOwnProperty("foodProvided"))
                if (typeof message.foodProvided !== "number")
                    return "foodProvided: number expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.race != null && message.hasOwnProperty("race"))
                switch (message.race) {
                    default:
                        return "race: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                if (typeof message.buildTime !== "number")
                    return "buildTime: number expected";
            if (message.hasVespene != null && message.hasOwnProperty("hasVespene"))
                if (typeof message.hasVespene !== "boolean")
                    return "hasVespene: boolean expected";
            if (message.hasMinerals != null && message.hasOwnProperty("hasMinerals"))
                if (typeof message.hasMinerals !== "boolean")
                    return "hasMinerals: boolean expected";
            if (message.techAlias != null && message.hasOwnProperty("techAlias")) {
                if (!Array.isArray(message.techAlias))
                    return "techAlias: array expected";
                for (var i = 0; i < message.techAlias.length; ++i)
                    if (!$util.isInteger(message.techAlias[i]))
                        return "techAlias: integer[] expected";
            }
            if (message.unitAlias != null && message.hasOwnProperty("unitAlias"))
                if (!$util.isInteger(message.unitAlias))
                    return "unitAlias: integer expected";
            if (message.techRequirement != null && message.hasOwnProperty("techRequirement"))
                if (!$util.isInteger(message.techRequirement))
                    return "techRequirement: integer expected";
            if (message.requireAttached != null && message.hasOwnProperty("requireAttached"))
                if (typeof message.requireAttached !== "boolean")
                    return "requireAttached: boolean expected";
            if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                for (var i = 0; i < message.attributes.length; ++i)
                    switch (message.attributes[i]) {
                        default:
                            return "attributes: enum value[] expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                            break;
                    }
            }
            if (message.movementSpeed != null && message.hasOwnProperty("movementSpeed"))
                if (typeof message.movementSpeed !== "number")
                    return "movementSpeed: number expected";
            if (message.armor != null && message.hasOwnProperty("armor"))
                if (typeof message.armor !== "number")
                    return "armor: number expected";
            if (message.weapons != null && message.hasOwnProperty("weapons")) {
                if (!Array.isArray(message.weapons))
                    return "weapons: array expected";
                for (var i = 0; i < message.weapons.length; ++i) {
                    var error = $root.SC2APIProtocol.Weapon.verify(message.weapons[i]);
                    if (error)
                        return "weapons." + error;
                }
            }
            return null;
        };
        /**
         * Creates an UnitTypeData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.UnitTypeData} UnitTypeData
         */
        UnitTypeData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.UnitTypeData)
                return object;
            var message = new $root.SC2APIProtocol.UnitTypeData();
            if (object.unitId != null)
                message.unitId = object.unitId >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.available != null)
                message.available = Boolean(object.available);
            if (object.cargoSize != null)
                message.cargoSize = object.cargoSize >>> 0;
            if (object.mineralCost != null)
                message.mineralCost = object.mineralCost >>> 0;
            if (object.vespeneCost != null)
                message.vespeneCost = object.vespeneCost >>> 0;
            if (object.foodRequired != null)
                message.foodRequired = Number(object.foodRequired);
            if (object.foodProvided != null)
                message.foodProvided = Number(object.foodProvided);
            if (object.abilityId != null)
                message.abilityId = object.abilityId >>> 0;
            switch (object.race) {
                case "NoRace":
                case 0:
                    message.race = 0;
                    break;
                case "Terran":
                case 1:
                    message.race = 1;
                    break;
                case "Zerg":
                case 2:
                    message.race = 2;
                    break;
                case "Protoss":
                case 3:
                    message.race = 3;
                    break;
                case "Random":
                case 4:
                    message.race = 4;
                    break;
            }
            if (object.buildTime != null)
                message.buildTime = Number(object.buildTime);
            if (object.hasVespene != null)
                message.hasVespene = Boolean(object.hasVespene);
            if (object.hasMinerals != null)
                message.hasMinerals = Boolean(object.hasMinerals);
            if (object.techAlias) {
                if (!Array.isArray(object.techAlias))
                    throw TypeError(".SC2APIProtocol.UnitTypeData.techAlias: array expected");
                message.techAlias = [];
                for (var i = 0; i < object.techAlias.length; ++i)
                    message.techAlias[i] = object.techAlias[i] >>> 0;
            }
            if (object.unitAlias != null)
                message.unitAlias = object.unitAlias >>> 0;
            if (object.techRequirement != null)
                message.techRequirement = object.techRequirement >>> 0;
            if (object.requireAttached != null)
                message.requireAttached = Boolean(object.requireAttached);
            if (object.attributes) {
                if (!Array.isArray(object.attributes))
                    throw TypeError(".SC2APIProtocol.UnitTypeData.attributes: array expected");
                message.attributes = [];
                for (var i = 0; i < object.attributes.length; ++i)
                    switch (object.attributes[i]) {
                        default:
                        case "Light":
                        case 1:
                            message.attributes[i] = 1;
                            break;
                        case "Armored":
                        case 2:
                            message.attributes[i] = 2;
                            break;
                        case "Biological":
                        case 3:
                            message.attributes[i] = 3;
                            break;
                        case "Mechanical":
                        case 4:
                            message.attributes[i] = 4;
                            break;
                        case "Robotic":
                        case 5:
                            message.attributes[i] = 5;
                            break;
                        case "Psionic":
                        case 6:
                            message.attributes[i] = 6;
                            break;
                        case "Massive":
                        case 7:
                            message.attributes[i] = 7;
                            break;
                        case "Structure":
                        case 8:
                            message.attributes[i] = 8;
                            break;
                        case "Hover":
                        case 9:
                            message.attributes[i] = 9;
                            break;
                        case "Heroic":
                        case 10:
                            message.attributes[i] = 10;
                            break;
                        case "Summoned":
                        case 11:
                            message.attributes[i] = 11;
                            break;
                    }
            }
            if (object.movementSpeed != null)
                message.movementSpeed = Number(object.movementSpeed);
            if (object.armor != null)
                message.armor = Number(object.armor);
            if (object.weapons) {
                if (!Array.isArray(object.weapons))
                    throw TypeError(".SC2APIProtocol.UnitTypeData.weapons: array expected");
                message.weapons = [];
                for (var i = 0; i < object.weapons.length; ++i) {
                    if (typeof object.weapons[i] !== "object")
                        throw TypeError(".SC2APIProtocol.UnitTypeData.weapons: object expected");
                    message.weapons[i] = $root.SC2APIProtocol.Weapon.fromObject(object.weapons[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an UnitTypeData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.UnitTypeData
         * @static
         * @param {SC2APIProtocol.UnitTypeData} message UnitTypeData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitTypeData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.attributes = [];
                object.weapons = [];
                object.techAlias = [];
            }
            if (options.defaults) {
                object.unitId = 0;
                object.name = "";
                object.available = false;
                object.cargoSize = 0;
                object.movementSpeed = 0;
                object.armor = 0;
                object.mineralCost = 0;
                object.vespeneCost = 0;
                object.foodRequired = 0;
                object.abilityId = 0;
                object.race = options.enums === String ? "NoRace" : 0;
                object.buildTime = 0;
                object.foodProvided = 0;
                object.hasVespene = false;
                object.hasMinerals = false;
                object.unitAlias = 0;
                object.techRequirement = 0;
                object.requireAttached = false;
            }
            if (message.unitId != null && message.hasOwnProperty("unitId"))
                object.unitId = message.unitId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.available != null && message.hasOwnProperty("available"))
                object.available = message.available;
            if (message.cargoSize != null && message.hasOwnProperty("cargoSize"))
                object.cargoSize = message.cargoSize;
            if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = options.enums === String ? $root.SC2APIProtocol.Attribute[message.attributes[j]] : message.attributes[j];
            }
            if (message.movementSpeed != null && message.hasOwnProperty("movementSpeed"))
                object.movementSpeed = options.json && !isFinite(message.movementSpeed) ? String(message.movementSpeed) : message.movementSpeed;
            if (message.armor != null && message.hasOwnProperty("armor"))
                object.armor = options.json && !isFinite(message.armor) ? String(message.armor) : message.armor;
            if (message.weapons && message.weapons.length) {
                object.weapons = [];
                for (var j = 0; j < message.weapons.length; ++j)
                    object.weapons[j] = $root.SC2APIProtocol.Weapon.toObject(message.weapons[j], options);
            }
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                object.mineralCost = message.mineralCost;
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                object.vespeneCost = message.vespeneCost;
            if (message.foodRequired != null && message.hasOwnProperty("foodRequired"))
                object.foodRequired = options.json && !isFinite(message.foodRequired) ? String(message.foodRequired) : message.foodRequired;
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = options.enums === String ? $root.SC2APIProtocol.Race[message.race] : message.race;
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                object.buildTime = options.json && !isFinite(message.buildTime) ? String(message.buildTime) : message.buildTime;
            if (message.foodProvided != null && message.hasOwnProperty("foodProvided"))
                object.foodProvided = options.json && !isFinite(message.foodProvided) ? String(message.foodProvided) : message.foodProvided;
            if (message.hasVespene != null && message.hasOwnProperty("hasVespene"))
                object.hasVespene = message.hasVespene;
            if (message.hasMinerals != null && message.hasOwnProperty("hasMinerals"))
                object.hasMinerals = message.hasMinerals;
            if (message.techAlias && message.techAlias.length) {
                object.techAlias = [];
                for (var j = 0; j < message.techAlias.length; ++j)
                    object.techAlias[j] = message.techAlias[j];
            }
            if (message.unitAlias != null && message.hasOwnProperty("unitAlias"))
                object.unitAlias = message.unitAlias;
            if (message.techRequirement != null && message.hasOwnProperty("techRequirement"))
                object.techRequirement = message.techRequirement;
            if (message.requireAttached != null && message.hasOwnProperty("requireAttached"))
                object.requireAttached = message.requireAttached;
            return object;
        };
        /**
         * Converts this UnitTypeData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.UnitTypeData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitTypeData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnitTypeData;
    })();
    SC2APIProtocol.UpgradeData = (function () {
        /**
         * Properties of an UpgradeData.
         * @memberof SC2APIProtocol
         * @interface IUpgradeData
         * @property {number} [upgradeId] UpgradeData upgradeId
         * @property {string} [name] UpgradeData name
         * @property {number} [mineralCost] UpgradeData mineralCost
         * @property {number} [vespeneCost] UpgradeData vespeneCost
         * @property {number} [researchTime] UpgradeData researchTime
         * @property {number} [abilityId] UpgradeData abilityId
         */
        /**
         * Constructs a new UpgradeData.
         * @memberof SC2APIProtocol
         * @classdesc Represents an UpgradeData.
         * @constructor
         * @param {SC2APIProtocol.IUpgradeData=} [properties] Properties to set
         */
        function UpgradeData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UpgradeData upgradeId.
         * @member {number}upgradeId
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.upgradeId = 0;
        /**
         * UpgradeData name.
         * @member {string}name
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.name = "";
        /**
         * UpgradeData mineralCost.
         * @member {number}mineralCost
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.mineralCost = 0;
        /**
         * UpgradeData vespeneCost.
         * @member {number}vespeneCost
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.vespeneCost = 0;
        /**
         * UpgradeData researchTime.
         * @member {number}researchTime
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.researchTime = 0;
        /**
         * UpgradeData abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         */
        UpgradeData.prototype.abilityId = 0;
        /**
         * Creates a new UpgradeData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {SC2APIProtocol.IUpgradeData=} [properties] Properties to set
         * @returns {SC2APIProtocol.UpgradeData} UpgradeData instance
         */
        UpgradeData.create = function create(properties) {
            return new UpgradeData(properties);
        };
        /**
         * Encodes the specified UpgradeData message. Does not implicitly {@link SC2APIProtocol.UpgradeData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {SC2APIProtocol.IUpgradeData} message UpgradeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.upgradeId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.mineralCost);
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.vespeneCost);
            if (message.researchTime != null && message.hasOwnProperty("researchTime"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.researchTime);
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).uint32(message.abilityId);
            return writer;
        };
        /**
         * Encodes the specified UpgradeData message, length delimited. Does not implicitly {@link SC2APIProtocol.UpgradeData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {SC2APIProtocol.IUpgradeData} message UpgradeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UpgradeData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.UpgradeData} UpgradeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.UpgradeData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.upgradeId = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.mineralCost = reader.uint32();
                        break;
                    case 4:
                        message.vespeneCost = reader.uint32();
                        break;
                    case 5:
                        message.researchTime = reader.float();
                        break;
                    case 6:
                        message.abilityId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UpgradeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.UpgradeData} UpgradeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UpgradeData message.
         * @function verify
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpgradeData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                if (!$util.isInteger(message.upgradeId))
                    return "upgradeId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                if (!$util.isInteger(message.mineralCost))
                    return "mineralCost: integer expected";
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                if (!$util.isInteger(message.vespeneCost))
                    return "vespeneCost: integer expected";
            if (message.researchTime != null && message.hasOwnProperty("researchTime"))
                if (typeof message.researchTime !== "number")
                    return "researchTime: number expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            return null;
        };
        /**
         * Creates an UpgradeData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.UpgradeData} UpgradeData
         */
        UpgradeData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.UpgradeData)
                return object;
            var message = new $root.SC2APIProtocol.UpgradeData();
            if (object.upgradeId != null)
                message.upgradeId = object.upgradeId >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.mineralCost != null)
                message.mineralCost = object.mineralCost >>> 0;
            if (object.vespeneCost != null)
                message.vespeneCost = object.vespeneCost >>> 0;
            if (object.researchTime != null)
                message.researchTime = Number(object.researchTime);
            if (object.abilityId != null)
                message.abilityId = object.abilityId >>> 0;
            return message;
        };
        /**
         * Creates a plain object from an UpgradeData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.UpgradeData
         * @static
         * @param {SC2APIProtocol.UpgradeData} message UpgradeData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpgradeData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.upgradeId = 0;
                object.name = "";
                object.mineralCost = 0;
                object.vespeneCost = 0;
                object.researchTime = 0;
                object.abilityId = 0;
            }
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                object.upgradeId = message.upgradeId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.mineralCost != null && message.hasOwnProperty("mineralCost"))
                object.mineralCost = message.mineralCost;
            if (message.vespeneCost != null && message.hasOwnProperty("vespeneCost"))
                object.vespeneCost = message.vespeneCost;
            if (message.researchTime != null && message.hasOwnProperty("researchTime"))
                object.researchTime = options.json && !isFinite(message.researchTime) ? String(message.researchTime) : message.researchTime;
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            return object;
        };
        /**
         * Converts this UpgradeData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.UpgradeData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpgradeData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UpgradeData;
    })();
    SC2APIProtocol.BuffData = (function () {
        /**
         * Properties of a BuffData.
         * @memberof SC2APIProtocol
         * @interface IBuffData
         * @property {number} [buffId] BuffData buffId
         * @property {string} [name] BuffData name
         */
        /**
         * Constructs a new BuffData.
         * @memberof SC2APIProtocol
         * @classdesc Represents a BuffData.
         * @constructor
         * @param {SC2APIProtocol.IBuffData=} [properties] Properties to set
         */
        function BuffData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * BuffData buffId.
         * @member {number}buffId
         * @memberof SC2APIProtocol.BuffData
         * @instance
         */
        BuffData.prototype.buffId = 0;
        /**
         * BuffData name.
         * @member {string}name
         * @memberof SC2APIProtocol.BuffData
         * @instance
         */
        BuffData.prototype.name = "";
        /**
         * Creates a new BuffData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {SC2APIProtocol.IBuffData=} [properties] Properties to set
         * @returns {SC2APIProtocol.BuffData} BuffData instance
         */
        BuffData.create = function create(properties) {
            return new BuffData(properties);
        };
        /**
         * Encodes the specified BuffData message. Does not implicitly {@link SC2APIProtocol.BuffData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {SC2APIProtocol.IBuffData} message BuffData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuffData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.buffId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
            return writer;
        };
        /**
         * Encodes the specified BuffData message, length delimited. Does not implicitly {@link SC2APIProtocol.BuffData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {SC2APIProtocol.IBuffData} message BuffData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuffData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a BuffData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.BuffData} BuffData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuffData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.BuffData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.buffId = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a BuffData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.BuffData} BuffData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuffData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a BuffData message.
         * @function verify
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuffData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                if (!$util.isInteger(message.buffId))
                    return "buffId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };
        /**
         * Creates a BuffData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.BuffData} BuffData
         */
        BuffData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.BuffData)
                return object;
            var message = new $root.SC2APIProtocol.BuffData();
            if (object.buffId != null)
                message.buffId = object.buffId >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
        /**
         * Creates a plain object from a BuffData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.BuffData
         * @static
         * @param {SC2APIProtocol.BuffData} message BuffData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuffData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.buffId = 0;
                object.name = "";
            }
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                object.buffId = message.buffId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
        /**
         * Converts this BuffData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.BuffData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuffData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BuffData;
    })();
    SC2APIProtocol.DebugCommand = (function () {
        /**
         * Properties of a DebugCommand.
         * @memberof SC2APIProtocol
         * @interface IDebugCommand
         * @property {SC2APIProtocol.IDebugDraw} [draw] DebugCommand draw
         * @property {SC2APIProtocol.DebugGameState} [gameState] DebugCommand gameState
         * @property {SC2APIProtocol.IDebugCreateUnit} [createUnit] DebugCommand createUnit
         * @property {SC2APIProtocol.IDebugKillUnit} [killUnit] DebugCommand killUnit
         * @property {SC2APIProtocol.IDebugTestProcess} [testProcess] DebugCommand testProcess
         * @property {SC2APIProtocol.IDebugSetScore} [score] DebugCommand score
         * @property {SC2APIProtocol.IDebugEndGame} [endGame] DebugCommand endGame
         * @property {SC2APIProtocol.IDebugSetUnitValue} [unitValue] DebugCommand unitValue
         * @property {SC2APIProtocol.IDebugChat} [chat] DebugCommand chat
         */
        /**
         * Constructs a new DebugCommand.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugCommand.
         * @constructor
         * @param {SC2APIProtocol.IDebugCommand=} [properties] Properties to set
         */
        function DebugCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugCommand draw.
         * @member {(SC2APIProtocol.IDebugDraw|null|undefined)}draw
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.draw = null;
        /**
         * DebugCommand gameState.
         * @member {SC2APIProtocol.DebugGameState}gameState
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.gameState = 1;
        /**
         * DebugCommand createUnit.
         * @member {(SC2APIProtocol.IDebugCreateUnit|null|undefined)}createUnit
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.createUnit = null;
        /**
         * DebugCommand killUnit.
         * @member {(SC2APIProtocol.IDebugKillUnit|null|undefined)}killUnit
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.killUnit = null;
        /**
         * DebugCommand testProcess.
         * @member {(SC2APIProtocol.IDebugTestProcess|null|undefined)}testProcess
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.testProcess = null;
        /**
         * DebugCommand score.
         * @member {(SC2APIProtocol.IDebugSetScore|null|undefined)}score
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.score = null;
        /**
         * DebugCommand endGame.
         * @member {(SC2APIProtocol.IDebugEndGame|null|undefined)}endGame
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.endGame = null;
        /**
         * DebugCommand unitValue.
         * @member {(SC2APIProtocol.IDebugSetUnitValue|null|undefined)}unitValue
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.unitValue = null;
        /**
         * DebugCommand chat.
         * @member {(SC2APIProtocol.IDebugChat|null|undefined)}chat
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        DebugCommand.prototype.chat = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * DebugCommand command.
         * @member {string|undefined} command
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         */
        Object.defineProperty(DebugCommand.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["draw", "gameState", "createUnit", "killUnit", "testProcess", "score", "endGame", "unitValue", "chat"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new DebugCommand instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {SC2APIProtocol.IDebugCommand=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugCommand} DebugCommand instance
         */
        DebugCommand.create = function create(properties) {
            return new DebugCommand(properties);
        };
        /**
         * Encodes the specified DebugCommand message. Does not implicitly {@link SC2APIProtocol.DebugCommand.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {SC2APIProtocol.IDebugCommand} message DebugCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.draw != null && message.hasOwnProperty("draw"))
                $root.SC2APIProtocol.DebugDraw.encode(message.draw, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.gameState != null && message.hasOwnProperty("gameState"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.gameState);
            if (message.createUnit != null && message.hasOwnProperty("createUnit"))
                $root.SC2APIProtocol.DebugCreateUnit.encode(message.createUnit, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.killUnit != null && message.hasOwnProperty("killUnit"))
                $root.SC2APIProtocol.DebugKillUnit.encode(message.killUnit, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.testProcess != null && message.hasOwnProperty("testProcess"))
                $root.SC2APIProtocol.DebugTestProcess.encode(message.testProcess, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.score != null && message.hasOwnProperty("score"))
                $root.SC2APIProtocol.DebugSetScore.encode(message.score, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.endGame != null && message.hasOwnProperty("endGame"))
                $root.SC2APIProtocol.DebugEndGame.encode(message.endGame, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.unitValue != null && message.hasOwnProperty("unitValue"))
                $root.SC2APIProtocol.DebugSetUnitValue.encode(message.unitValue, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.chat != null && message.hasOwnProperty("chat"))
                $root.SC2APIProtocol.DebugChat.encode(message.chat, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified DebugCommand message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {SC2APIProtocol.IDebugCommand} message DebugCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugCommand message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugCommand} DebugCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.draw = $root.SC2APIProtocol.DebugDraw.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.gameState = reader.int32();
                        break;
                    case 3:
                        message.createUnit = $root.SC2APIProtocol.DebugCreateUnit.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.killUnit = $root.SC2APIProtocol.DebugKillUnit.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.testProcess = $root.SC2APIProtocol.DebugTestProcess.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.score = $root.SC2APIProtocol.DebugSetScore.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.endGame = $root.SC2APIProtocol.DebugEndGame.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.unitValue = $root.SC2APIProtocol.DebugSetUnitValue.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.chat = $root.SC2APIProtocol.DebugChat.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugCommand} DebugCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugCommand message.
         * @function verify
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.draw != null && message.hasOwnProperty("draw")) {
                properties.command = 1;
                var error = $root.SC2APIProtocol.DebugDraw.verify(message.draw);
                if (error)
                    return "draw." + error;
            }
            if (message.gameState != null && message.hasOwnProperty("gameState")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                switch (message.gameState) {
                    default:
                        return "gameState: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                }
            }
            if (message.createUnit != null && message.hasOwnProperty("createUnit")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugCreateUnit.verify(message.createUnit);
                if (error)
                    return "createUnit." + error;
            }
            if (message.killUnit != null && message.hasOwnProperty("killUnit")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugKillUnit.verify(message.killUnit);
                if (error)
                    return "killUnit." + error;
            }
            if (message.testProcess != null && message.hasOwnProperty("testProcess")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugTestProcess.verify(message.testProcess);
                if (error)
                    return "testProcess." + error;
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugSetScore.verify(message.score);
                if (error)
                    return "score." + error;
            }
            if (message.endGame != null && message.hasOwnProperty("endGame")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugEndGame.verify(message.endGame);
                if (error)
                    return "endGame." + error;
            }
            if (message.unitValue != null && message.hasOwnProperty("unitValue")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugSetUnitValue.verify(message.unitValue);
                if (error)
                    return "unitValue." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                if (properties.command === 1)
                    return "command: multiple values";
                properties.command = 1;
                error = $root.SC2APIProtocol.DebugChat.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            return null;
        };
        /**
         * Creates a DebugCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugCommand} DebugCommand
         */
        DebugCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugCommand)
                return object;
            var message = new $root.SC2APIProtocol.DebugCommand();
            if (object.draw != null) {
                if (typeof object.draw !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.draw: object expected");
                message.draw = $root.SC2APIProtocol.DebugDraw.fromObject(object.draw);
            }
            switch (object.gameState) {
                case "show_map":
                case 1:
                    message.gameState = 1;
                    break;
                case "control_enemy":
                case 2:
                    message.gameState = 2;
                    break;
                case "food":
                case 3:
                    message.gameState = 3;
                    break;
                case "free":
                case 4:
                    message.gameState = 4;
                    break;
                case "all_resources":
                case 5:
                    message.gameState = 5;
                    break;
                case "god":
                case 6:
                    message.gameState = 6;
                    break;
                case "minerals":
                case 7:
                    message.gameState = 7;
                    break;
                case "gas":
                case 8:
                    message.gameState = 8;
                    break;
                case "cooldown":
                case 9:
                    message.gameState = 9;
                    break;
                case "tech_tree":
                case 10:
                    message.gameState = 10;
                    break;
                case "upgrade":
                case 11:
                    message.gameState = 11;
                    break;
                case "fast_build":
                case 12:
                    message.gameState = 12;
                    break;
            }
            if (object.createUnit != null) {
                if (typeof object.createUnit !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.createUnit: object expected");
                message.createUnit = $root.SC2APIProtocol.DebugCreateUnit.fromObject(object.createUnit);
            }
            if (object.killUnit != null) {
                if (typeof object.killUnit !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.killUnit: object expected");
                message.killUnit = $root.SC2APIProtocol.DebugKillUnit.fromObject(object.killUnit);
            }
            if (object.testProcess != null) {
                if (typeof object.testProcess !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.testProcess: object expected");
                message.testProcess = $root.SC2APIProtocol.DebugTestProcess.fromObject(object.testProcess);
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.score: object expected");
                message.score = $root.SC2APIProtocol.DebugSetScore.fromObject(object.score);
            }
            if (object.endGame != null) {
                if (typeof object.endGame !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.endGame: object expected");
                message.endGame = $root.SC2APIProtocol.DebugEndGame.fromObject(object.endGame);
            }
            if (object.unitValue != null) {
                if (typeof object.unitValue !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.unitValue: object expected");
                message.unitValue = $root.SC2APIProtocol.DebugSetUnitValue.fromObject(object.unitValue);
            }
            if (object.chat != null) {
                if (typeof object.chat !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCommand.chat: object expected");
                message.chat = $root.SC2APIProtocol.DebugChat.fromObject(object.chat);
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugCommand
         * @static
         * @param {SC2APIProtocol.DebugCommand} message DebugCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.draw != null && message.hasOwnProperty("draw")) {
                object.draw = $root.SC2APIProtocol.DebugDraw.toObject(message.draw, options);
                if (options.oneofs)
                    object.command = "draw";
            }
            if (message.gameState != null && message.hasOwnProperty("gameState")) {
                object.gameState = options.enums === String ? $root.SC2APIProtocol.DebugGameState[message.gameState] : message.gameState;
                if (options.oneofs)
                    object.command = "gameState";
            }
            if (message.createUnit != null && message.hasOwnProperty("createUnit")) {
                object.createUnit = $root.SC2APIProtocol.DebugCreateUnit.toObject(message.createUnit, options);
                if (options.oneofs)
                    object.command = "createUnit";
            }
            if (message.killUnit != null && message.hasOwnProperty("killUnit")) {
                object.killUnit = $root.SC2APIProtocol.DebugKillUnit.toObject(message.killUnit, options);
                if (options.oneofs)
                    object.command = "killUnit";
            }
            if (message.testProcess != null && message.hasOwnProperty("testProcess")) {
                object.testProcess = $root.SC2APIProtocol.DebugTestProcess.toObject(message.testProcess, options);
                if (options.oneofs)
                    object.command = "testProcess";
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                object.score = $root.SC2APIProtocol.DebugSetScore.toObject(message.score, options);
                if (options.oneofs)
                    object.command = "score";
            }
            if (message.endGame != null && message.hasOwnProperty("endGame")) {
                object.endGame = $root.SC2APIProtocol.DebugEndGame.toObject(message.endGame, options);
                if (options.oneofs)
                    object.command = "endGame";
            }
            if (message.unitValue != null && message.hasOwnProperty("unitValue")) {
                object.unitValue = $root.SC2APIProtocol.DebugSetUnitValue.toObject(message.unitValue, options);
                if (options.oneofs)
                    object.command = "unitValue";
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                object.chat = $root.SC2APIProtocol.DebugChat.toObject(message.chat, options);
                if (options.oneofs)
                    object.command = "chat";
            }
            return object;
        };
        /**
         * Converts this DebugCommand to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugCommand;
    })();
    SC2APIProtocol.DebugDraw = (function () {
        /**
         * Properties of a DebugDraw.
         * @memberof SC2APIProtocol
         * @interface IDebugDraw
         * @property {Array.<SC2APIProtocol.IDebugText>} [text] DebugDraw text
         * @property {Array.<SC2APIProtocol.IDebugLine>} [lines] DebugDraw lines
         * @property {Array.<SC2APIProtocol.IDebugBox>} [boxes] DebugDraw boxes
         * @property {Array.<SC2APIProtocol.IDebugSphere>} [spheres] DebugDraw spheres
         */
        /**
         * Constructs a new DebugDraw.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugDraw.
         * @constructor
         * @param {SC2APIProtocol.IDebugDraw=} [properties] Properties to set
         */
        function DebugDraw(properties) {
            this.text = [];
            this.lines = [];
            this.boxes = [];
            this.spheres = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugDraw text.
         * @member {Array.<SC2APIProtocol.IDebugText>}text
         * @memberof SC2APIProtocol.DebugDraw
         * @instance
         */
        DebugDraw.prototype.text = $util.emptyArray;
        /**
         * DebugDraw lines.
         * @member {Array.<SC2APIProtocol.IDebugLine>}lines
         * @memberof SC2APIProtocol.DebugDraw
         * @instance
         */
        DebugDraw.prototype.lines = $util.emptyArray;
        /**
         * DebugDraw boxes.
         * @member {Array.<SC2APIProtocol.IDebugBox>}boxes
         * @memberof SC2APIProtocol.DebugDraw
         * @instance
         */
        DebugDraw.prototype.boxes = $util.emptyArray;
        /**
         * DebugDraw spheres.
         * @member {Array.<SC2APIProtocol.IDebugSphere>}spheres
         * @memberof SC2APIProtocol.DebugDraw
         * @instance
         */
        DebugDraw.prototype.spheres = $util.emptyArray;
        /**
         * Creates a new DebugDraw instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {SC2APIProtocol.IDebugDraw=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugDraw} DebugDraw instance
         */
        DebugDraw.create = function create(properties) {
            return new DebugDraw(properties);
        };
        /**
         * Encodes the specified DebugDraw message. Does not implicitly {@link SC2APIProtocol.DebugDraw.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {SC2APIProtocol.IDebugDraw} message DebugDraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugDraw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && message.text.length)
                for (var i = 0; i < message.text.length; ++i)
                    $root.SC2APIProtocol.DebugText.encode(message.text[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.lines != null && message.lines.length)
                for (var i = 0; i < message.lines.length; ++i)
                    $root.SC2APIProtocol.DebugLine.encode(message.lines[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.boxes != null && message.boxes.length)
                for (var i = 0; i < message.boxes.length; ++i)
                    $root.SC2APIProtocol.DebugBox.encode(message.boxes[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.spheres != null && message.spheres.length)
                for (var i = 0; i < message.spheres.length; ++i)
                    $root.SC2APIProtocol.DebugSphere.encode(message.spheres[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified DebugDraw message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugDraw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {SC2APIProtocol.IDebugDraw} message DebugDraw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugDraw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugDraw message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugDraw} DebugDraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugDraw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugDraw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.text && message.text.length))
                            message.text = [];
                        message.text.push($root.SC2APIProtocol.DebugText.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.lines && message.lines.length))
                            message.lines = [];
                        message.lines.push($root.SC2APIProtocol.DebugLine.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.boxes && message.boxes.length))
                            message.boxes = [];
                        message.boxes.push($root.SC2APIProtocol.DebugBox.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.spheres && message.spheres.length))
                            message.spheres = [];
                        message.spheres.push($root.SC2APIProtocol.DebugSphere.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugDraw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugDraw} DebugDraw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugDraw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugDraw message.
         * @function verify
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugDraw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text")) {
                if (!Array.isArray(message.text))
                    return "text: array expected";
                for (var i = 0; i < message.text.length; ++i) {
                    var error = $root.SC2APIProtocol.DebugText.verify(message.text[i]);
                    if (error)
                        return "text." + error;
                }
            }
            if (message.lines != null && message.hasOwnProperty("lines")) {
                if (!Array.isArray(message.lines))
                    return "lines: array expected";
                for (var i = 0; i < message.lines.length; ++i) {
                    error = $root.SC2APIProtocol.DebugLine.verify(message.lines[i]);
                    if (error)
                        return "lines." + error;
                }
            }
            if (message.boxes != null && message.hasOwnProperty("boxes")) {
                if (!Array.isArray(message.boxes))
                    return "boxes: array expected";
                for (var i = 0; i < message.boxes.length; ++i) {
                    error = $root.SC2APIProtocol.DebugBox.verify(message.boxes[i]);
                    if (error)
                        return "boxes." + error;
                }
            }
            if (message.spheres != null && message.hasOwnProperty("spheres")) {
                if (!Array.isArray(message.spheres))
                    return "spheres: array expected";
                for (var i = 0; i < message.spheres.length; ++i) {
                    error = $root.SC2APIProtocol.DebugSphere.verify(message.spheres[i]);
                    if (error)
                        return "spheres." + error;
                }
            }
            return null;
        };
        /**
         * Creates a DebugDraw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugDraw} DebugDraw
         */
        DebugDraw.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugDraw)
                return object;
            var message = new $root.SC2APIProtocol.DebugDraw();
            if (object.text) {
                if (!Array.isArray(object.text))
                    throw TypeError(".SC2APIProtocol.DebugDraw.text: array expected");
                message.text = [];
                for (var i = 0; i < object.text.length; ++i) {
                    if (typeof object.text[i] !== "object")
                        throw TypeError(".SC2APIProtocol.DebugDraw.text: object expected");
                    message.text[i] = $root.SC2APIProtocol.DebugText.fromObject(object.text[i]);
                }
            }
            if (object.lines) {
                if (!Array.isArray(object.lines))
                    throw TypeError(".SC2APIProtocol.DebugDraw.lines: array expected");
                message.lines = [];
                for (var i = 0; i < object.lines.length; ++i) {
                    if (typeof object.lines[i] !== "object")
                        throw TypeError(".SC2APIProtocol.DebugDraw.lines: object expected");
                    message.lines[i] = $root.SC2APIProtocol.DebugLine.fromObject(object.lines[i]);
                }
            }
            if (object.boxes) {
                if (!Array.isArray(object.boxes))
                    throw TypeError(".SC2APIProtocol.DebugDraw.boxes: array expected");
                message.boxes = [];
                for (var i = 0; i < object.boxes.length; ++i) {
                    if (typeof object.boxes[i] !== "object")
                        throw TypeError(".SC2APIProtocol.DebugDraw.boxes: object expected");
                    message.boxes[i] = $root.SC2APIProtocol.DebugBox.fromObject(object.boxes[i]);
                }
            }
            if (object.spheres) {
                if (!Array.isArray(object.spheres))
                    throw TypeError(".SC2APIProtocol.DebugDraw.spheres: array expected");
                message.spheres = [];
                for (var i = 0; i < object.spheres.length; ++i) {
                    if (typeof object.spheres[i] !== "object")
                        throw TypeError(".SC2APIProtocol.DebugDraw.spheres: object expected");
                    message.spheres[i] = $root.SC2APIProtocol.DebugSphere.fromObject(object.spheres[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugDraw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugDraw
         * @static
         * @param {SC2APIProtocol.DebugDraw} message DebugDraw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugDraw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.text = [];
                object.lines = [];
                object.boxes = [];
                object.spheres = [];
            }
            if (message.text && message.text.length) {
                object.text = [];
                for (var j = 0; j < message.text.length; ++j)
                    object.text[j] = $root.SC2APIProtocol.DebugText.toObject(message.text[j], options);
            }
            if (message.lines && message.lines.length) {
                object.lines = [];
                for (var j = 0; j < message.lines.length; ++j)
                    object.lines[j] = $root.SC2APIProtocol.DebugLine.toObject(message.lines[j], options);
            }
            if (message.boxes && message.boxes.length) {
                object.boxes = [];
                for (var j = 0; j < message.boxes.length; ++j)
                    object.boxes[j] = $root.SC2APIProtocol.DebugBox.toObject(message.boxes[j], options);
            }
            if (message.spheres && message.spheres.length) {
                object.spheres = [];
                for (var j = 0; j < message.spheres.length; ++j)
                    object.spheres[j] = $root.SC2APIProtocol.DebugSphere.toObject(message.spheres[j], options);
            }
            return object;
        };
        /**
         * Converts this DebugDraw to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugDraw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugDraw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugDraw;
    })();
    SC2APIProtocol.Line = (function () {
        /**
         * Properties of a Line.
         * @memberof SC2APIProtocol
         * @interface ILine
         * @property {SC2APIProtocol.IPoint} [p0] Line p0
         * @property {SC2APIProtocol.IPoint} [p1] Line p1
         */
        /**
         * Constructs a new Line.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Line.
         * @constructor
         * @param {SC2APIProtocol.ILine=} [properties] Properties to set
         */
        function Line(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Line p0.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}p0
         * @memberof SC2APIProtocol.Line
         * @instance
         */
        Line.prototype.p0 = null;
        /**
         * Line p1.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}p1
         * @memberof SC2APIProtocol.Line
         * @instance
         */
        Line.prototype.p1 = null;
        /**
         * Creates a new Line instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {SC2APIProtocol.ILine=} [properties] Properties to set
         * @returns {SC2APIProtocol.Line} Line instance
         */
        Line.create = function create(properties) {
            return new Line(properties);
        };
        /**
         * Encodes the specified Line message. Does not implicitly {@link SC2APIProtocol.Line.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {SC2APIProtocol.ILine} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.p0 != null && message.hasOwnProperty("p0"))
                $root.SC2APIProtocol.Point.encode(message.p0, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.p1 != null && message.hasOwnProperty("p1"))
                $root.SC2APIProtocol.Point.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Line message, length delimited. Does not implicitly {@link SC2APIProtocol.Line.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {SC2APIProtocol.ILine} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Line message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Line();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.p0 = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.p1 = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Line message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Line message.
         * @function verify
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Line.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.p0 != null && message.hasOwnProperty("p0")) {
                var error = $root.SC2APIProtocol.Point.verify(message.p0);
                if (error)
                    return "p0." + error;
            }
            if (message.p1 != null && message.hasOwnProperty("p1")) {
                error = $root.SC2APIProtocol.Point.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            return null;
        };
        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Line} Line
         */
        Line.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Line)
                return object;
            var message = new $root.SC2APIProtocol.Line();
            if (object.p0 != null) {
                if (typeof object.p0 !== "object")
                    throw TypeError(".SC2APIProtocol.Line.p0: object expected");
                message.p0 = $root.SC2APIProtocol.Point.fromObject(object.p0);
            }
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".SC2APIProtocol.Line.p1: object expected");
                message.p1 = $root.SC2APIProtocol.Point.fromObject(object.p1);
            }
            return message;
        };
        /**
         * Creates a plain object from a Line message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Line
         * @static
         * @param {SC2APIProtocol.Line} message Line
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Line.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p0 = null;
                object.p1 = null;
            }
            if (message.p0 != null && message.hasOwnProperty("p0"))
                object.p0 = $root.SC2APIProtocol.Point.toObject(message.p0, options);
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.SC2APIProtocol.Point.toObject(message.p1, options);
            return object;
        };
        /**
         * Converts this Line to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Line
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Line.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Line;
    })();
    SC2APIProtocol.Color = (function () {
        /**
         * Properties of a Color.
         * @memberof SC2APIProtocol
         * @interface IColor
         * @property {number} [r] Color r
         * @property {number} [g] Color g
         * @property {number} [b] Color b
         */
        /**
         * Constructs a new Color.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Color.
         * @constructor
         * @param {SC2APIProtocol.IColor=} [properties] Properties to set
         */
        function Color(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Color r.
         * @member {number}r
         * @memberof SC2APIProtocol.Color
         * @instance
         */
        Color.prototype.r = 0;
        /**
         * Color g.
         * @member {number}g
         * @memberof SC2APIProtocol.Color
         * @instance
         */
        Color.prototype.g = 0;
        /**
         * Color b.
         * @member {number}b
         * @memberof SC2APIProtocol.Color
         * @instance
         */
        Color.prototype.b = 0;
        /**
         * Creates a new Color instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {SC2APIProtocol.IColor=} [properties] Properties to set
         * @returns {SC2APIProtocol.Color} Color instance
         */
        Color.create = function create(properties) {
            return new Color(properties);
        };
        /**
         * Encodes the specified Color message. Does not implicitly {@link SC2APIProtocol.Color.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {SC2APIProtocol.IColor} message Color message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Color.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && message.hasOwnProperty("r"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.r);
            if (message.g != null && message.hasOwnProperty("g"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.g);
            if (message.b != null && message.hasOwnProperty("b"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.b);
            return writer;
        };
        /**
         * Encodes the specified Color message, length delimited. Does not implicitly {@link SC2APIProtocol.Color.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {SC2APIProtocol.IColor} message Color message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Color.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Color message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Color} Color
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Color.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Color();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.r = reader.uint32();
                        break;
                    case 2:
                        message.g = reader.uint32();
                        break;
                    case 3:
                        message.b = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Color message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Color} Color
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Color.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Color message.
         * @function verify
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Color.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            return null;
        };
        /**
         * Creates a Color message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Color} Color
         */
        Color.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Color)
                return object;
            var message = new $root.SC2APIProtocol.Color();
            if (object.r != null)
                message.r = object.r >>> 0;
            if (object.g != null)
                message.g = object.g >>> 0;
            if (object.b != null)
                message.b = object.b >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a Color message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Color
         * @static
         * @param {SC2APIProtocol.Color} message Color
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Color.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            return object;
        };
        /**
         * Converts this Color to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Color
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Color.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Color;
    })();
    SC2APIProtocol.DebugText = (function () {
        /**
         * Properties of a DebugText.
         * @memberof SC2APIProtocol
         * @interface IDebugText
         * @property {SC2APIProtocol.IColor} [color] DebugText color
         * @property {string} [text] DebugText text
         * @property {SC2APIProtocol.IPoint} [virtualPos] DebugText virtualPos
         * @property {SC2APIProtocol.IPoint} [worldPos] DebugText worldPos
         */
        /**
         * Constructs a new DebugText.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugText.
         * @constructor
         * @param {SC2APIProtocol.IDebugText=} [properties] Properties to set
         */
        function DebugText(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugText color.
         * @member {(SC2APIProtocol.IColor|null|undefined)}color
         * @memberof SC2APIProtocol.DebugText
         * @instance
         */
        DebugText.prototype.color = null;
        /**
         * DebugText text.
         * @member {string}text
         * @memberof SC2APIProtocol.DebugText
         * @instance
         */
        DebugText.prototype.text = "";
        /**
         * DebugText virtualPos.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}virtualPos
         * @memberof SC2APIProtocol.DebugText
         * @instance
         */
        DebugText.prototype.virtualPos = null;
        /**
         * DebugText worldPos.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}worldPos
         * @memberof SC2APIProtocol.DebugText
         * @instance
         */
        DebugText.prototype.worldPos = null;
        /**
         * Creates a new DebugText instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {SC2APIProtocol.IDebugText=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugText} DebugText instance
         */
        DebugText.create = function create(properties) {
            return new DebugText(properties);
        };
        /**
         * Encodes the specified DebugText message. Does not implicitly {@link SC2APIProtocol.DebugText.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {SC2APIProtocol.IDebugText} message DebugText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && message.hasOwnProperty("color"))
                $root.SC2APIProtocol.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.text);
            if (message.virtualPos != null && message.hasOwnProperty("virtualPos"))
                $root.SC2APIProtocol.Point.encode(message.virtualPos, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.worldPos != null && message.hasOwnProperty("worldPos"))
                $root.SC2APIProtocol.Point.encode(message.worldPos, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified DebugText message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {SC2APIProtocol.IDebugText} message DebugText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugText message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugText} DebugText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.color = $root.SC2APIProtocol.Color.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    case 3:
                        message.virtualPos = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.worldPos = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugText} DebugText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugText message.
         * @function verify
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugText.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.SC2APIProtocol.Color.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.virtualPos != null && message.hasOwnProperty("virtualPos")) {
                error = $root.SC2APIProtocol.Point.verify(message.virtualPos);
                if (error)
                    return "virtualPos." + error;
            }
            if (message.worldPos != null && message.hasOwnProperty("worldPos")) {
                error = $root.SC2APIProtocol.Point.verify(message.worldPos);
                if (error)
                    return "worldPos." + error;
            }
            return null;
        };
        /**
         * Creates a DebugText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugText} DebugText
         */
        DebugText.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugText)
                return object;
            var message = new $root.SC2APIProtocol.DebugText();
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".SC2APIProtocol.DebugText.color: object expected");
                message.color = $root.SC2APIProtocol.Color.fromObject(object.color);
            }
            if (object.text != null)
                message.text = String(object.text);
            if (object.virtualPos != null) {
                if (typeof object.virtualPos !== "object")
                    throw TypeError(".SC2APIProtocol.DebugText.virtualPos: object expected");
                message.virtualPos = $root.SC2APIProtocol.Point.fromObject(object.virtualPos);
            }
            if (object.worldPos != null) {
                if (typeof object.worldPos !== "object")
                    throw TypeError(".SC2APIProtocol.DebugText.worldPos: object expected");
                message.worldPos = $root.SC2APIProtocol.Point.fromObject(object.worldPos);
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugText
         * @static
         * @param {SC2APIProtocol.DebugText} message DebugText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = null;
                object.text = "";
                object.virtualPos = null;
                object.worldPos = null;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.SC2APIProtocol.Color.toObject(message.color, options);
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.virtualPos != null && message.hasOwnProperty("virtualPos"))
                object.virtualPos = $root.SC2APIProtocol.Point.toObject(message.virtualPos, options);
            if (message.worldPos != null && message.hasOwnProperty("worldPos"))
                object.worldPos = $root.SC2APIProtocol.Point.toObject(message.worldPos, options);
            return object;
        };
        /**
         * Converts this DebugText to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugText;
    })();
    SC2APIProtocol.DebugLine = (function () {
        /**
         * Properties of a DebugLine.
         * @memberof SC2APIProtocol
         * @interface IDebugLine
         * @property {SC2APIProtocol.IColor} [color] DebugLine color
         * @property {SC2APIProtocol.ILine} [line] DebugLine line
         */
        /**
         * Constructs a new DebugLine.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugLine.
         * @constructor
         * @param {SC2APIProtocol.IDebugLine=} [properties] Properties to set
         */
        function DebugLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugLine color.
         * @member {(SC2APIProtocol.IColor|null|undefined)}color
         * @memberof SC2APIProtocol.DebugLine
         * @instance
         */
        DebugLine.prototype.color = null;
        /**
         * DebugLine line.
         * @member {(SC2APIProtocol.ILine|null|undefined)}line
         * @memberof SC2APIProtocol.DebugLine
         * @instance
         */
        DebugLine.prototype.line = null;
        /**
         * Creates a new DebugLine instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {SC2APIProtocol.IDebugLine=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugLine} DebugLine instance
         */
        DebugLine.create = function create(properties) {
            return new DebugLine(properties);
        };
        /**
         * Encodes the specified DebugLine message. Does not implicitly {@link SC2APIProtocol.DebugLine.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {SC2APIProtocol.IDebugLine} message DebugLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && message.hasOwnProperty("color"))
                $root.SC2APIProtocol.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.line != null && message.hasOwnProperty("line"))
                $root.SC2APIProtocol.Line.encode(message.line, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified DebugLine message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {SC2APIProtocol.IDebugLine} message DebugLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugLine message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugLine} DebugLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.color = $root.SC2APIProtocol.Color.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.line = $root.SC2APIProtocol.Line.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugLine} DebugLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugLine message.
         * @function verify
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.SC2APIProtocol.Color.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.line != null && message.hasOwnProperty("line")) {
                error = $root.SC2APIProtocol.Line.verify(message.line);
                if (error)
                    return "line." + error;
            }
            return null;
        };
        /**
         * Creates a DebugLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugLine} DebugLine
         */
        DebugLine.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugLine)
                return object;
            var message = new $root.SC2APIProtocol.DebugLine();
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".SC2APIProtocol.DebugLine.color: object expected");
                message.color = $root.SC2APIProtocol.Color.fromObject(object.color);
            }
            if (object.line != null) {
                if (typeof object.line !== "object")
                    throw TypeError(".SC2APIProtocol.DebugLine.line: object expected");
                message.line = $root.SC2APIProtocol.Line.fromObject(object.line);
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugLine
         * @static
         * @param {SC2APIProtocol.DebugLine} message DebugLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = null;
                object.line = null;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.SC2APIProtocol.Color.toObject(message.color, options);
            if (message.line != null && message.hasOwnProperty("line"))
                object.line = $root.SC2APIProtocol.Line.toObject(message.line, options);
            return object;
        };
        /**
         * Converts this DebugLine to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugLine;
    })();
    SC2APIProtocol.DebugBox = (function () {
        /**
         * Properties of a DebugBox.
         * @memberof SC2APIProtocol
         * @interface IDebugBox
         * @property {SC2APIProtocol.IColor} [color] DebugBox color
         * @property {SC2APIProtocol.IPoint} [min] DebugBox min
         * @property {SC2APIProtocol.IPoint} [max] DebugBox max
         */
        /**
         * Constructs a new DebugBox.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugBox.
         * @constructor
         * @param {SC2APIProtocol.IDebugBox=} [properties] Properties to set
         */
        function DebugBox(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugBox color.
         * @member {(SC2APIProtocol.IColor|null|undefined)}color
         * @memberof SC2APIProtocol.DebugBox
         * @instance
         */
        DebugBox.prototype.color = null;
        /**
         * DebugBox min.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}min
         * @memberof SC2APIProtocol.DebugBox
         * @instance
         */
        DebugBox.prototype.min = null;
        /**
         * DebugBox max.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}max
         * @memberof SC2APIProtocol.DebugBox
         * @instance
         */
        DebugBox.prototype.max = null;
        /**
         * Creates a new DebugBox instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {SC2APIProtocol.IDebugBox=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugBox} DebugBox instance
         */
        DebugBox.create = function create(properties) {
            return new DebugBox(properties);
        };
        /**
         * Encodes the specified DebugBox message. Does not implicitly {@link SC2APIProtocol.DebugBox.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {SC2APIProtocol.IDebugBox} message DebugBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugBox.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && message.hasOwnProperty("color"))
                $root.SC2APIProtocol.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.min != null && message.hasOwnProperty("min"))
                $root.SC2APIProtocol.Point.encode(message.min, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.max != null && message.hasOwnProperty("max"))
                $root.SC2APIProtocol.Point.encode(message.max, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified DebugBox message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugBox.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {SC2APIProtocol.IDebugBox} message DebugBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugBox.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugBox message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugBox} DebugBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugBox.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugBox();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.color = $root.SC2APIProtocol.Color.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.min = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.max = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugBox message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugBox} DebugBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugBox.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugBox message.
         * @function verify
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugBox.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.SC2APIProtocol.Color.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.min != null && message.hasOwnProperty("min")) {
                error = $root.SC2APIProtocol.Point.verify(message.min);
                if (error)
                    return "min." + error;
            }
            if (message.max != null && message.hasOwnProperty("max")) {
                error = $root.SC2APIProtocol.Point.verify(message.max);
                if (error)
                    return "max." + error;
            }
            return null;
        };
        /**
         * Creates a DebugBox message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugBox} DebugBox
         */
        DebugBox.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugBox)
                return object;
            var message = new $root.SC2APIProtocol.DebugBox();
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".SC2APIProtocol.DebugBox.color: object expected");
                message.color = $root.SC2APIProtocol.Color.fromObject(object.color);
            }
            if (object.min != null) {
                if (typeof object.min !== "object")
                    throw TypeError(".SC2APIProtocol.DebugBox.min: object expected");
                message.min = $root.SC2APIProtocol.Point.fromObject(object.min);
            }
            if (object.max != null) {
                if (typeof object.max !== "object")
                    throw TypeError(".SC2APIProtocol.DebugBox.max: object expected");
                message.max = $root.SC2APIProtocol.Point.fromObject(object.max);
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugBox message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugBox
         * @static
         * @param {SC2APIProtocol.DebugBox} message DebugBox
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugBox.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = null;
                object.min = null;
                object.max = null;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.SC2APIProtocol.Color.toObject(message.color, options);
            if (message.min != null && message.hasOwnProperty("min"))
                object.min = $root.SC2APIProtocol.Point.toObject(message.min, options);
            if (message.max != null && message.hasOwnProperty("max"))
                object.max = $root.SC2APIProtocol.Point.toObject(message.max, options);
            return object;
        };
        /**
         * Converts this DebugBox to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugBox
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugBox.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugBox;
    })();
    SC2APIProtocol.DebugSphere = (function () {
        /**
         * Properties of a DebugSphere.
         * @memberof SC2APIProtocol
         * @interface IDebugSphere
         * @property {SC2APIProtocol.IColor} [color] DebugSphere color
         * @property {SC2APIProtocol.IPoint} [p] DebugSphere p
         * @property {number} [r] DebugSphere r
         */
        /**
         * Constructs a new DebugSphere.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugSphere.
         * @constructor
         * @param {SC2APIProtocol.IDebugSphere=} [properties] Properties to set
         */
        function DebugSphere(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugSphere color.
         * @member {(SC2APIProtocol.IColor|null|undefined)}color
         * @memberof SC2APIProtocol.DebugSphere
         * @instance
         */
        DebugSphere.prototype.color = null;
        /**
         * DebugSphere p.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}p
         * @memberof SC2APIProtocol.DebugSphere
         * @instance
         */
        DebugSphere.prototype.p = null;
        /**
         * DebugSphere r.
         * @member {number}r
         * @memberof SC2APIProtocol.DebugSphere
         * @instance
         */
        DebugSphere.prototype.r = 0;
        /**
         * Creates a new DebugSphere instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {SC2APIProtocol.IDebugSphere=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugSphere} DebugSphere instance
         */
        DebugSphere.create = function create(properties) {
            return new DebugSphere(properties);
        };
        /**
         * Encodes the specified DebugSphere message. Does not implicitly {@link SC2APIProtocol.DebugSphere.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {SC2APIProtocol.IDebugSphere} message DebugSphere message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSphere.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.color != null && message.hasOwnProperty("color"))
                $root.SC2APIProtocol.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.p != null && message.hasOwnProperty("p"))
                $root.SC2APIProtocol.Point.encode(message.p, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.r != null && message.hasOwnProperty("r"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.r);
            return writer;
        };
        /**
         * Encodes the specified DebugSphere message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugSphere.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {SC2APIProtocol.IDebugSphere} message DebugSphere message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSphere.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugSphere message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugSphere} DebugSphere
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSphere.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugSphere();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.color = $root.SC2APIProtocol.Color.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.p = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.r = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugSphere message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugSphere} DebugSphere
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSphere.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugSphere message.
         * @function verify
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugSphere.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                var error = $root.SC2APIProtocol.Color.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.p != null && message.hasOwnProperty("p")) {
                error = $root.SC2APIProtocol.Point.verify(message.p);
                if (error)
                    return "p." + error;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                if (typeof message.r !== "number")
                    return "r: number expected";
            return null;
        };
        /**
         * Creates a DebugSphere message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugSphere} DebugSphere
         */
        DebugSphere.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugSphere)
                return object;
            var message = new $root.SC2APIProtocol.DebugSphere();
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".SC2APIProtocol.DebugSphere.color: object expected");
                message.color = $root.SC2APIProtocol.Color.fromObject(object.color);
            }
            if (object.p != null) {
                if (typeof object.p !== "object")
                    throw TypeError(".SC2APIProtocol.DebugSphere.p: object expected");
                message.p = $root.SC2APIProtocol.Point.fromObject(object.p);
            }
            if (object.r != null)
                message.r = Number(object.r);
            return message;
        };
        /**
         * Creates a plain object from a DebugSphere message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugSphere
         * @static
         * @param {SC2APIProtocol.DebugSphere} message DebugSphere
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugSphere.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.color = null;
                object.p = null;
                object.r = 0;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.SC2APIProtocol.Color.toObject(message.color, options);
            if (message.p != null && message.hasOwnProperty("p"))
                object.p = $root.SC2APIProtocol.Point.toObject(message.p, options);
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = options.json && !isFinite(message.r) ? String(message.r) : message.r;
            return object;
        };
        /**
         * Converts this DebugSphere to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugSphere
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugSphere.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugSphere;
    })();
    /**
     * DebugGameState enum.
     * @enum {string}
     * @property {number} show_map=1 show_map value
     * @property {number} control_enemy=2 control_enemy value
     * @property {number} food=3 food value
     * @property {number} free=4 free value
     * @property {number} all_resources=5 all_resources value
     * @property {number} god=6 god value
     * @property {number} minerals=7 minerals value
     * @property {number} gas=8 gas value
     * @property {number} cooldown=9 cooldown value
     * @property {number} tech_tree=10 tech_tree value
     * @property {number} upgrade=11 upgrade value
     * @property {number} fast_build=12 fast_build value
     */
    SC2APIProtocol.DebugGameState = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "show_map"] = 1;
        values[valuesById[2] = "control_enemy"] = 2;
        values[valuesById[3] = "food"] = 3;
        values[valuesById[4] = "free"] = 4;
        values[valuesById[5] = "all_resources"] = 5;
        values[valuesById[6] = "god"] = 6;
        values[valuesById[7] = "minerals"] = 7;
        values[valuesById[8] = "gas"] = 8;
        values[valuesById[9] = "cooldown"] = 9;
        values[valuesById[10] = "tech_tree"] = 10;
        values[valuesById[11] = "upgrade"] = 11;
        values[valuesById[12] = "fast_build"] = 12;
        return values;
    })();
    SC2APIProtocol.DebugCreateUnit = (function () {
        /**
         * Properties of a DebugCreateUnit.
         * @memberof SC2APIProtocol
         * @interface IDebugCreateUnit
         * @property {number} [unitType] DebugCreateUnit unitType
         * @property {number} [owner] DebugCreateUnit owner
         * @property {SC2APIProtocol.IPoint2D} [pos] DebugCreateUnit pos
         * @property {number} [quantity] DebugCreateUnit quantity
         */
        /**
         * Constructs a new DebugCreateUnit.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugCreateUnit.
         * @constructor
         * @param {SC2APIProtocol.IDebugCreateUnit=} [properties] Properties to set
         */
        function DebugCreateUnit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugCreateUnit unitType.
         * @member {number}unitType
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @instance
         */
        DebugCreateUnit.prototype.unitType = 0;
        /**
         * DebugCreateUnit owner.
         * @member {number}owner
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @instance
         */
        DebugCreateUnit.prototype.owner = 0;
        /**
         * DebugCreateUnit pos.
         * @member {(SC2APIProtocol.IPoint2D|null|undefined)}pos
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @instance
         */
        DebugCreateUnit.prototype.pos = null;
        /**
         * DebugCreateUnit quantity.
         * @member {number}quantity
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @instance
         */
        DebugCreateUnit.prototype.quantity = 0;
        /**
         * Creates a new DebugCreateUnit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {SC2APIProtocol.IDebugCreateUnit=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugCreateUnit} DebugCreateUnit instance
         */
        DebugCreateUnit.create = function create(properties) {
            return new DebugCreateUnit(properties);
        };
        /**
         * Encodes the specified DebugCreateUnit message. Does not implicitly {@link SC2APIProtocol.DebugCreateUnit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {SC2APIProtocol.IDebugCreateUnit} message DebugCreateUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugCreateUnit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.unitType);
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.owner);
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.SC2APIProtocol.Point2D.encode(message.pos, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.quantity);
            return writer;
        };
        /**
         * Encodes the specified DebugCreateUnit message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugCreateUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {SC2APIProtocol.IDebugCreateUnit} message DebugCreateUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugCreateUnit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugCreateUnit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugCreateUnit} DebugCreateUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugCreateUnit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugCreateUnit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitType = reader.uint32();
                        break;
                    case 2:
                        message.owner = reader.int32();
                        break;
                    case 3:
                        message.pos = $root.SC2APIProtocol.Point2D.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.quantity = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugCreateUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugCreateUnit} DebugCreateUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugCreateUnit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugCreateUnit message.
         * @function verify
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugCreateUnit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                if (!$util.isInteger(message.unitType))
                    return "unitType: integer expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isInteger(message.owner))
                    return "owner: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.SC2APIProtocol.Point2D.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                if (!$util.isInteger(message.quantity))
                    return "quantity: integer expected";
            return null;
        };
        /**
         * Creates a DebugCreateUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugCreateUnit} DebugCreateUnit
         */
        DebugCreateUnit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugCreateUnit)
                return object;
            var message = new $root.SC2APIProtocol.DebugCreateUnit();
            if (object.unitType != null)
                message.unitType = object.unitType >>> 0;
            if (object.owner != null)
                message.owner = object.owner | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".SC2APIProtocol.DebugCreateUnit.pos: object expected");
                message.pos = $root.SC2APIProtocol.Point2D.fromObject(object.pos);
            }
            if (object.quantity != null)
                message.quantity = object.quantity >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a DebugCreateUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @static
         * @param {SC2APIProtocol.DebugCreateUnit} message DebugCreateUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugCreateUnit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitType = 0;
                object.owner = 0;
                object.pos = null;
                object.quantity = 0;
            }
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = message.unitType;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.SC2APIProtocol.Point2D.toObject(message.pos, options);
            if (message.quantity != null && message.hasOwnProperty("quantity"))
                object.quantity = message.quantity;
            return object;
        };
        /**
         * Converts this DebugCreateUnit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugCreateUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugCreateUnit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugCreateUnit;
    })();
    SC2APIProtocol.DebugKillUnit = (function () {
        /**
         * Properties of a DebugKillUnit.
         * @memberof SC2APIProtocol
         * @interface IDebugKillUnit
         * @property {Array.<number|Long>} [tag] DebugKillUnit tag
         */
        /**
         * Constructs a new DebugKillUnit.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugKillUnit.
         * @constructor
         * @param {SC2APIProtocol.IDebugKillUnit=} [properties] Properties to set
         */
        function DebugKillUnit(properties) {
            this.tag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugKillUnit tag.
         * @member {Array.<number|Long>}tag
         * @memberof SC2APIProtocol.DebugKillUnit
         * @instance
         */
        DebugKillUnit.prototype.tag = $util.emptyArray;
        /**
         * Creates a new DebugKillUnit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {SC2APIProtocol.IDebugKillUnit=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugKillUnit} DebugKillUnit instance
         */
        DebugKillUnit.create = function create(properties) {
            return new DebugKillUnit(properties);
        };
        /**
         * Encodes the specified DebugKillUnit message. Does not implicitly {@link SC2APIProtocol.DebugKillUnit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {SC2APIProtocol.IDebugKillUnit} message DebugKillUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugKillUnit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tag != null && message.tag.length)
                for (var i = 0; i < message.tag.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.tag[i]);
            return writer;
        };
        /**
         * Encodes the specified DebugKillUnit message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugKillUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {SC2APIProtocol.IDebugKillUnit} message DebugKillUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugKillUnit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugKillUnit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugKillUnit} DebugKillUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugKillUnit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugKillUnit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.tag && message.tag.length))
                            message.tag = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.tag.push(reader.uint64());
                        }
                        else
                            message.tag.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugKillUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugKillUnit} DebugKillUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugKillUnit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugKillUnit message.
         * @function verify
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugKillUnit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tag != null && message.hasOwnProperty("tag")) {
                if (!Array.isArray(message.tag))
                    return "tag: array expected";
                for (var i = 0; i < message.tag.length; ++i)
                    if (!$util.isInteger(message.tag[i]) && !(message.tag[i] && $util.isInteger(message.tag[i].low) && $util.isInteger(message.tag[i].high)))
                        return "tag: integer|Long[] expected";
            }
            return null;
        };
        /**
         * Creates a DebugKillUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugKillUnit} DebugKillUnit
         */
        DebugKillUnit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugKillUnit)
                return object;
            var message = new $root.SC2APIProtocol.DebugKillUnit();
            if (object.tag) {
                if (!Array.isArray(object.tag))
                    throw TypeError(".SC2APIProtocol.DebugKillUnit.tag: array expected");
                message.tag = [];
                for (var i = 0; i < object.tag.length; ++i)
                    if ($util.Long)
                        (message.tag[i] = $util.Long.fromValue(object.tag[i])).unsigned = true;
                    else if (typeof object.tag[i] === "string")
                        message.tag[i] = parseInt(object.tag[i], 10);
                    else if (typeof object.tag[i] === "number")
                        message.tag[i] = object.tag[i];
                    else if (typeof object.tag[i] === "object")
                        message.tag[i] = new $util.LongBits(object.tag[i].low >>> 0, object.tag[i].high >>> 0).toNumber(true);
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugKillUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugKillUnit
         * @static
         * @param {SC2APIProtocol.DebugKillUnit} message DebugKillUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugKillUnit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tag = [];
            if (message.tag && message.tag.length) {
                object.tag = [];
                for (var j = 0; j < message.tag.length; ++j)
                    if (typeof message.tag[j] === "number")
                        object.tag[j] = options.longs === String ? String(message.tag[j]) : message.tag[j];
                    else
                        object.tag[j] = options.longs === String ? $util.Long.prototype.toString.call(message.tag[j]) : options.longs === Number ? new $util.LongBits(message.tag[j].low >>> 0, message.tag[j].high >>> 0).toNumber(true) : message.tag[j];
            }
            return object;
        };
        /**
         * Converts this DebugKillUnit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugKillUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugKillUnit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugKillUnit;
    })();
    SC2APIProtocol.DebugTestProcess = (function () {
        /**
         * Properties of a DebugTestProcess.
         * @memberof SC2APIProtocol
         * @interface IDebugTestProcess
         * @property {SC2APIProtocol.DebugTestProcess.Test} [test] DebugTestProcess test
         * @property {number} [delayMs] DebugTestProcess delayMs
         */
        /**
         * Constructs a new DebugTestProcess.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugTestProcess.
         * @constructor
         * @param {SC2APIProtocol.IDebugTestProcess=} [properties] Properties to set
         */
        function DebugTestProcess(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugTestProcess test.
         * @member {SC2APIProtocol.DebugTestProcess.Test}test
         * @memberof SC2APIProtocol.DebugTestProcess
         * @instance
         */
        DebugTestProcess.prototype.test = 1;
        /**
         * DebugTestProcess delayMs.
         * @member {number}delayMs
         * @memberof SC2APIProtocol.DebugTestProcess
         * @instance
         */
        DebugTestProcess.prototype.delayMs = 0;
        /**
         * Creates a new DebugTestProcess instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {SC2APIProtocol.IDebugTestProcess=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugTestProcess} DebugTestProcess instance
         */
        DebugTestProcess.create = function create(properties) {
            return new DebugTestProcess(properties);
        };
        /**
         * Encodes the specified DebugTestProcess message. Does not implicitly {@link SC2APIProtocol.DebugTestProcess.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {SC2APIProtocol.IDebugTestProcess} message DebugTestProcess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugTestProcess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.test != null && message.hasOwnProperty("test"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.test);
            if (message.delayMs != null && message.hasOwnProperty("delayMs"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.delayMs);
            return writer;
        };
        /**
         * Encodes the specified DebugTestProcess message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugTestProcess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {SC2APIProtocol.IDebugTestProcess} message DebugTestProcess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugTestProcess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugTestProcess message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugTestProcess} DebugTestProcess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugTestProcess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugTestProcess();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.test = reader.int32();
                        break;
                    case 2:
                        message.delayMs = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugTestProcess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugTestProcess} DebugTestProcess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugTestProcess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugTestProcess message.
         * @function verify
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugTestProcess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.test != null && message.hasOwnProperty("test"))
                switch (message.test) {
                    default:
                        return "test: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.delayMs != null && message.hasOwnProperty("delayMs"))
                if (!$util.isInteger(message.delayMs))
                    return "delayMs: integer expected";
            return null;
        };
        /**
         * Creates a DebugTestProcess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugTestProcess} DebugTestProcess
         */
        DebugTestProcess.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugTestProcess)
                return object;
            var message = new $root.SC2APIProtocol.DebugTestProcess();
            switch (object.test) {
                case "hang":
                case 1:
                    message.test = 1;
                    break;
                case "crash":
                case 2:
                    message.test = 2;
                    break;
                case "exit":
                case 3:
                    message.test = 3;
                    break;
            }
            if (object.delayMs != null)
                message.delayMs = object.delayMs | 0;
            return message;
        };
        /**
         * Creates a plain object from a DebugTestProcess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugTestProcess
         * @static
         * @param {SC2APIProtocol.DebugTestProcess} message DebugTestProcess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugTestProcess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.test = options.enums === String ? "hang" : 1;
                object.delayMs = 0;
            }
            if (message.test != null && message.hasOwnProperty("test"))
                object.test = options.enums === String ? $root.SC2APIProtocol.DebugTestProcess.Test[message.test] : message.test;
            if (message.delayMs != null && message.hasOwnProperty("delayMs"))
                object.delayMs = message.delayMs;
            return object;
        };
        /**
         * Converts this DebugTestProcess to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugTestProcess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugTestProcess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Test enum.
         * @enum {string}
         * @property {number} hang=1 hang value
         * @property {number} crash=2 crash value
         * @property {number} exit=3 exit value
         */
        DebugTestProcess.Test = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "hang"] = 1;
            values[valuesById[2] = "crash"] = 2;
            values[valuesById[3] = "exit"] = 3;
            return values;
        })();
        return DebugTestProcess;
    })();
    SC2APIProtocol.DebugSetScore = (function () {
        /**
         * Properties of a DebugSetScore.
         * @memberof SC2APIProtocol
         * @interface IDebugSetScore
         * @property {number} [score] DebugSetScore score
         */
        /**
         * Constructs a new DebugSetScore.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugSetScore.
         * @constructor
         * @param {SC2APIProtocol.IDebugSetScore=} [properties] Properties to set
         */
        function DebugSetScore(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugSetScore score.
         * @member {number}score
         * @memberof SC2APIProtocol.DebugSetScore
         * @instance
         */
        DebugSetScore.prototype.score = 0;
        /**
         * Creates a new DebugSetScore instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {SC2APIProtocol.IDebugSetScore=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugSetScore} DebugSetScore instance
         */
        DebugSetScore.create = function create(properties) {
            return new DebugSetScore(properties);
        };
        /**
         * Encodes the specified DebugSetScore message. Does not implicitly {@link SC2APIProtocol.DebugSetScore.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {SC2APIProtocol.IDebugSetScore} message DebugSetScore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSetScore.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.score);
            return writer;
        };
        /**
         * Encodes the specified DebugSetScore message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugSetScore.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {SC2APIProtocol.IDebugSetScore} message DebugSetScore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSetScore.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugSetScore message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugSetScore} DebugSetScore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSetScore.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugSetScore();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.score = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugSetScore message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugSetScore} DebugSetScore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSetScore.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugSetScore message.
         * @function verify
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugSetScore.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            return null;
        };
        /**
         * Creates a DebugSetScore message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugSetScore} DebugSetScore
         */
        DebugSetScore.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugSetScore)
                return object;
            var message = new $root.SC2APIProtocol.DebugSetScore();
            if (object.score != null)
                message.score = Number(object.score);
            return message;
        };
        /**
         * Creates a plain object from a DebugSetScore message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugSetScore
         * @static
         * @param {SC2APIProtocol.DebugSetScore} message DebugSetScore
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugSetScore.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.score = 0;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            return object;
        };
        /**
         * Converts this DebugSetScore to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugSetScore
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugSetScore.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugSetScore;
    })();
    SC2APIProtocol.DebugEndGame = (function () {
        /**
         * Properties of a DebugEndGame.
         * @memberof SC2APIProtocol
         * @interface IDebugEndGame
         * @property {SC2APIProtocol.DebugEndGame.EndResult} [endResult] DebugEndGame endResult
         */
        /**
         * Constructs a new DebugEndGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugEndGame.
         * @constructor
         * @param {SC2APIProtocol.IDebugEndGame=} [properties] Properties to set
         */
        function DebugEndGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugEndGame endResult.
         * @member {SC2APIProtocol.DebugEndGame.EndResult}endResult
         * @memberof SC2APIProtocol.DebugEndGame
         * @instance
         */
        DebugEndGame.prototype.endResult = 1;
        /**
         * Creates a new DebugEndGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {SC2APIProtocol.IDebugEndGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugEndGame} DebugEndGame instance
         */
        DebugEndGame.create = function create(properties) {
            return new DebugEndGame(properties);
        };
        /**
         * Encodes the specified DebugEndGame message. Does not implicitly {@link SC2APIProtocol.DebugEndGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {SC2APIProtocol.IDebugEndGame} message DebugEndGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugEndGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.endResult != null && message.hasOwnProperty("endResult"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.endResult);
            return writer;
        };
        /**
         * Encodes the specified DebugEndGame message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugEndGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {SC2APIProtocol.IDebugEndGame} message DebugEndGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugEndGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugEndGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugEndGame} DebugEndGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugEndGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugEndGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.endResult = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugEndGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugEndGame} DebugEndGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugEndGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugEndGame message.
         * @function verify
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugEndGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.endResult != null && message.hasOwnProperty("endResult"))
                switch (message.endResult) {
                    default:
                        return "endResult: enum value expected";
                    case 1:
                    case 2:
                        break;
                }
            return null;
        };
        /**
         * Creates a DebugEndGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugEndGame} DebugEndGame
         */
        DebugEndGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugEndGame)
                return object;
            var message = new $root.SC2APIProtocol.DebugEndGame();
            switch (object.endResult) {
                case "Surrender":
                case 1:
                    message.endResult = 1;
                    break;
                case "DeclareVictory":
                case 2:
                    message.endResult = 2;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a DebugEndGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugEndGame
         * @static
         * @param {SC2APIProtocol.DebugEndGame} message DebugEndGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugEndGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.endResult = options.enums === String ? "Surrender" : 1;
            if (message.endResult != null && message.hasOwnProperty("endResult"))
                object.endResult = options.enums === String ? $root.SC2APIProtocol.DebugEndGame.EndResult[message.endResult] : message.endResult;
            return object;
        };
        /**
         * Converts this DebugEndGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugEndGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugEndGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * EndResult enum.
         * @enum {string}
         * @property {number} Surrender=1 Surrender value
         * @property {number} DeclareVictory=2 DeclareVictory value
         */
        DebugEndGame.EndResult = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Surrender"] = 1;
            values[valuesById[2] = "DeclareVictory"] = 2;
            return values;
        })();
        return DebugEndGame;
    })();
    SC2APIProtocol.DebugSetUnitValue = (function () {
        /**
         * Properties of a DebugSetUnitValue.
         * @memberof SC2APIProtocol
         * @interface IDebugSetUnitValue
         * @property {SC2APIProtocol.DebugSetUnitValue.UnitValue} [unitValue] DebugSetUnitValue unitValue
         * @property {number} [value] DebugSetUnitValue value
         * @property {number|Long} [unitTag] DebugSetUnitValue unitTag
         */
        /**
         * Constructs a new DebugSetUnitValue.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugSetUnitValue.
         * @constructor
         * @param {SC2APIProtocol.IDebugSetUnitValue=} [properties] Properties to set
         */
        function DebugSetUnitValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugSetUnitValue unitValue.
         * @member {SC2APIProtocol.DebugSetUnitValue.UnitValue}unitValue
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @instance
         */
        DebugSetUnitValue.prototype.unitValue = 1;
        /**
         * DebugSetUnitValue value.
         * @member {number}value
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @instance
         */
        DebugSetUnitValue.prototype.value = 0;
        /**
         * DebugSetUnitValue unitTag.
         * @member {number|Long}unitTag
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @instance
         */
        DebugSetUnitValue.prototype.unitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new DebugSetUnitValue instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {SC2APIProtocol.IDebugSetUnitValue=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugSetUnitValue} DebugSetUnitValue instance
         */
        DebugSetUnitValue.create = function create(properties) {
            return new DebugSetUnitValue(properties);
        };
        /**
         * Encodes the specified DebugSetUnitValue message. Does not implicitly {@link SC2APIProtocol.DebugSetUnitValue.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {SC2APIProtocol.IDebugSetUnitValue} message DebugSetUnitValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSetUnitValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitValue != null && message.hasOwnProperty("unitValue"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.unitValue);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.value);
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.unitTag);
            return writer;
        };
        /**
         * Encodes the specified DebugSetUnitValue message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugSetUnitValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {SC2APIProtocol.IDebugSetUnitValue} message DebugSetUnitValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugSetUnitValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugSetUnitValue message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugSetUnitValue} DebugSetUnitValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSetUnitValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugSetUnitValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitValue = reader.int32();
                        break;
                    case 2:
                        message.value = reader.float();
                        break;
                    case 3:
                        message.unitTag = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugSetUnitValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugSetUnitValue} DebugSetUnitValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugSetUnitValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugSetUnitValue message.
         * @function verify
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugSetUnitValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitValue != null && message.hasOwnProperty("unitValue"))
                switch (message.unitValue) {
                    default:
                        return "unitValue: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (!$util.isInteger(message.unitTag) && !(message.unitTag && $util.isInteger(message.unitTag.low) && $util.isInteger(message.unitTag.high)))
                    return "unitTag: integer|Long expected";
            return null;
        };
        /**
         * Creates a DebugSetUnitValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugSetUnitValue} DebugSetUnitValue
         */
        DebugSetUnitValue.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugSetUnitValue)
                return object;
            var message = new $root.SC2APIProtocol.DebugSetUnitValue();
            switch (object.unitValue) {
                case "Energy":
                case 1:
                    message.unitValue = 1;
                    break;
                case "Life":
                case 2:
                    message.unitValue = 2;
                    break;
                case "Shields":
                case 3:
                    message.unitValue = 3;
                    break;
            }
            if (object.value != null)
                message.value = Number(object.value);
            if (object.unitTag != null)
                if ($util.Long)
                    (message.unitTag = $util.Long.fromValue(object.unitTag)).unsigned = true;
                else if (typeof object.unitTag === "string")
                    message.unitTag = parseInt(object.unitTag, 10);
                else if (typeof object.unitTag === "number")
                    message.unitTag = object.unitTag;
                else if (typeof object.unitTag === "object")
                    message.unitTag = new $util.LongBits(object.unitTag.low >>> 0, object.unitTag.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from a DebugSetUnitValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @static
         * @param {SC2APIProtocol.DebugSetUnitValue} message DebugSetUnitValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugSetUnitValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitValue = options.enums === String ? "Energy" : 1;
                object.value = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.unitTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.unitTag = options.longs === String ? "0" : 0;
            }
            if (message.unitValue != null && message.hasOwnProperty("unitValue"))
                object.unitValue = options.enums === String ? $root.SC2APIProtocol.DebugSetUnitValue.UnitValue[message.unitValue] : message.unitValue;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (typeof message.unitTag === "number")
                    object.unitTag = options.longs === String ? String(message.unitTag) : message.unitTag;
                else
                    object.unitTag = options.longs === String ? $util.Long.prototype.toString.call(message.unitTag) : options.longs === Number ? new $util.LongBits(message.unitTag.low >>> 0, message.unitTag.high >>> 0).toNumber(true) : message.unitTag;
            return object;
        };
        /**
         * Converts this DebugSetUnitValue to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugSetUnitValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugSetUnitValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * UnitValue enum.
         * @enum {string}
         * @property {number} Energy=1 Energy value
         * @property {number} Life=2 Life value
         * @property {number} Shields=3 Shields value
         */
        DebugSetUnitValue.UnitValue = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Energy"] = 1;
            values[valuesById[2] = "Life"] = 2;
            values[valuesById[3] = "Shields"] = 3;
            return values;
        })();
        return DebugSetUnitValue;
    })();
    SC2APIProtocol.DebugChat = (function () {
        /**
         * Properties of a DebugChat.
         * @memberof SC2APIProtocol
         * @interface IDebugChat
         * @property {string} [message] DebugChat message
         */
        /**
         * Constructs a new DebugChat.
         * @memberof SC2APIProtocol
         * @classdesc Represents a DebugChat.
         * @constructor
         * @param {SC2APIProtocol.IDebugChat=} [properties] Properties to set
         */
        function DebugChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DebugChat message.
         * @member {string}message
         * @memberof SC2APIProtocol.DebugChat
         * @instance
         */
        DebugChat.prototype.message = "";
        /**
         * Creates a new DebugChat instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {SC2APIProtocol.IDebugChat=} [properties] Properties to set
         * @returns {SC2APIProtocol.DebugChat} DebugChat instance
         */
        DebugChat.create = function create(properties) {
            return new DebugChat(properties);
        };
        /**
         * Encodes the specified DebugChat message. Does not implicitly {@link SC2APIProtocol.DebugChat.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {SC2APIProtocol.IDebugChat} message DebugChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.message);
            return writer;
        };
        /**
         * Encodes the specified DebugChat message, length delimited. Does not implicitly {@link SC2APIProtocol.DebugChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {SC2APIProtocol.IDebugChat} message DebugChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a DebugChat message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.DebugChat} DebugChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.DebugChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a DebugChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.DebugChat} DebugChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a DebugChat message.
         * @function verify
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
        /**
         * Creates a DebugChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.DebugChat} DebugChat
         */
        DebugChat.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.DebugChat)
                return object;
            var message = new $root.SC2APIProtocol.DebugChat();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
        /**
         * Creates a plain object from a DebugChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.DebugChat
         * @static
         * @param {SC2APIProtocol.DebugChat} message DebugChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
        /**
         * Converts this DebugChat to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.DebugChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DebugChat;
    })();
    /**
     * ActionResult enum.
     * @enum {string}
     * @property {number} Success=1 Success value
     * @property {number} NotSupported=2 NotSupported value
     * @property {number} Error=3 Error value
     * @property {number} CantQueueThatOrder=4 CantQueueThatOrder value
     * @property {number} Retry=5 Retry value
     * @property {number} Cooldown=6 Cooldown value
     * @property {number} QueueIsFull=7 QueueIsFull value
     * @property {number} RallyQueueIsFull=8 RallyQueueIsFull value
     * @property {number} NotEnoughMinerals=9 NotEnoughMinerals value
     * @property {number} NotEnoughVespene=10 NotEnoughVespene value
     * @property {number} NotEnoughTerrazine=11 NotEnoughTerrazine value
     * @property {number} NotEnoughCustom=12 NotEnoughCustom value
     * @property {number} NotEnoughFood=13 NotEnoughFood value
     * @property {number} FoodUsageImpossible=14 FoodUsageImpossible value
     * @property {number} NotEnoughLife=15 NotEnoughLife value
     * @property {number} NotEnoughShields=16 NotEnoughShields value
     * @property {number} NotEnoughEnergy=17 NotEnoughEnergy value
     * @property {number} LifeSuppressed=18 LifeSuppressed value
     * @property {number} ShieldsSuppressed=19 ShieldsSuppressed value
     * @property {number} EnergySuppressed=20 EnergySuppressed value
     * @property {number} NotEnoughCharges=21 NotEnoughCharges value
     * @property {number} CantAddMoreCharges=22 CantAddMoreCharges value
     * @property {number} TooMuchMinerals=23 TooMuchMinerals value
     * @property {number} TooMuchVespene=24 TooMuchVespene value
     * @property {number} TooMuchTerrazine=25 TooMuchTerrazine value
     * @property {number} TooMuchCustom=26 TooMuchCustom value
     * @property {number} TooMuchFood=27 TooMuchFood value
     * @property {number} TooMuchLife=28 TooMuchLife value
     * @property {number} TooMuchShields=29 TooMuchShields value
     * @property {number} TooMuchEnergy=30 TooMuchEnergy value
     * @property {number} MustTargetUnitWithLife=31 MustTargetUnitWithLife value
     * @property {number} MustTargetUnitWithShields=32 MustTargetUnitWithShields value
     * @property {number} MustTargetUnitWithEnergy=33 MustTargetUnitWithEnergy value
     * @property {number} CantTrade=34 CantTrade value
     * @property {number} CantSpend=35 CantSpend value
     * @property {number} CantTargetThatUnit=36 CantTargetThatUnit value
     * @property {number} CouldntAllocateUnit=37 CouldntAllocateUnit value
     * @property {number} UnitCantMove=38 UnitCantMove value
     * @property {number} TransportIsHoldingPosition=39 TransportIsHoldingPosition value
     * @property {number} BuildTechRequirementsNotMet=40 BuildTechRequirementsNotMet value
     * @property {number} CantFindPlacementLocation=41 CantFindPlacementLocation value
     * @property {number} CantBuildOnThat=42 CantBuildOnThat value
     * @property {number} CantBuildTooCloseToDropOff=43 CantBuildTooCloseToDropOff value
     * @property {number} CantBuildLocationInvalid=44 CantBuildLocationInvalid value
     * @property {number} CantSeeBuildLocation=45 CantSeeBuildLocation value
     * @property {number} CantBuildTooCloseToCreepSource=46 CantBuildTooCloseToCreepSource value
     * @property {number} CantBuildTooCloseToResources=47 CantBuildTooCloseToResources value
     * @property {number} CantBuildTooFarFromWater=48 CantBuildTooFarFromWater value
     * @property {number} CantBuildTooFarFromCreepSource=49 CantBuildTooFarFromCreepSource value
     * @property {number} CantBuildTooFarFromBuildPowerSource=50 CantBuildTooFarFromBuildPowerSource value
     * @property {number} CantBuildOnDenseTerrain=51 CantBuildOnDenseTerrain value
     * @property {number} CantTrainTooFarFromTrainPowerSource=52 CantTrainTooFarFromTrainPowerSource value
     * @property {number} CantLandLocationInvalid=53 CantLandLocationInvalid value
     * @property {number} CantSeeLandLocation=54 CantSeeLandLocation value
     * @property {number} CantLandTooCloseToCreepSource=55 CantLandTooCloseToCreepSource value
     * @property {number} CantLandTooCloseToResources=56 CantLandTooCloseToResources value
     * @property {number} CantLandTooFarFromWater=57 CantLandTooFarFromWater value
     * @property {number} CantLandTooFarFromCreepSource=58 CantLandTooFarFromCreepSource value
     * @property {number} CantLandTooFarFromBuildPowerSource=59 CantLandTooFarFromBuildPowerSource value
     * @property {number} CantLandTooFarFromTrainPowerSource=60 CantLandTooFarFromTrainPowerSource value
     * @property {number} CantLandOnDenseTerrain=61 CantLandOnDenseTerrain value
     * @property {number} AddOnTooFarFromBuilding=62 AddOnTooFarFromBuilding value
     * @property {number} MustBuildRefineryFirst=63 MustBuildRefineryFirst value
     * @property {number} BuildingIsUnderConstruction=64 BuildingIsUnderConstruction value
     * @property {number} CantFindDropOff=65 CantFindDropOff value
     * @property {number} CantLoadOtherPlayersUnits=66 CantLoadOtherPlayersUnits value
     * @property {number} NotEnoughRoomToLoadUnit=67 NotEnoughRoomToLoadUnit value
     * @property {number} CantUnloadUnitsThere=68 CantUnloadUnitsThere value
     * @property {number} CantWarpInUnitsThere=69 CantWarpInUnitsThere value
     * @property {number} CantLoadImmobileUnits=70 CantLoadImmobileUnits value
     * @property {number} CantRechargeImmobileUnits=71 CantRechargeImmobileUnits value
     * @property {number} CantRechargeUnderConstructionUnits=72 CantRechargeUnderConstructionUnits value
     * @property {number} CantLoadThatUnit=73 CantLoadThatUnit value
     * @property {number} NoCargoToUnload=74 NoCargoToUnload value
     * @property {number} LoadAllNoTargetsFound=75 LoadAllNoTargetsFound value
     * @property {number} NotWhileOccupied=76 NotWhileOccupied value
     * @property {number} CantAttackWithoutAmmo=77 CantAttackWithoutAmmo value
     * @property {number} CantHoldAnyMoreAmmo=78 CantHoldAnyMoreAmmo value
     * @property {number} TechRequirementsNotMet=79 TechRequirementsNotMet value
     * @property {number} MustLockdownUnitFirst=80 MustLockdownUnitFirst value
     * @property {number} MustTargetUnit=81 MustTargetUnit value
     * @property {number} MustTargetInventory=82 MustTargetInventory value
     * @property {number} MustTargetVisibleUnit=83 MustTargetVisibleUnit value
     * @property {number} MustTargetVisibleLocation=84 MustTargetVisibleLocation value
     * @property {number} MustTargetWalkableLocation=85 MustTargetWalkableLocation value
     * @property {number} MustTargetPawnableUnit=86 MustTargetPawnableUnit value
     * @property {number} YouCantControlThatUnit=87 YouCantControlThatUnit value
     * @property {number} YouCantIssueCommandsToThatUnit=88 YouCantIssueCommandsToThatUnit value
     * @property {number} MustTargetResources=89 MustTargetResources value
     * @property {number} RequiresHealTarget=90 RequiresHealTarget value
     * @property {number} RequiresRepairTarget=91 RequiresRepairTarget value
     * @property {number} NoItemsToDrop=92 NoItemsToDrop value
     * @property {number} CantHoldAnyMoreItems=93 CantHoldAnyMoreItems value
     * @property {number} CantHoldThat=94 CantHoldThat value
     * @property {number} TargetHasNoInventory=95 TargetHasNoInventory value
     * @property {number} CantDropThisItem=96 CantDropThisItem value
     * @property {number} CantMoveThisItem=97 CantMoveThisItem value
     * @property {number} CantPawnThisUnit=98 CantPawnThisUnit value
     * @property {number} MustTargetCaster=99 MustTargetCaster value
     * @property {number} CantTargetCaster=100 CantTargetCaster value
     * @property {number} MustTargetOuter=101 MustTargetOuter value
     * @property {number} CantTargetOuter=102 CantTargetOuter value
     * @property {number} MustTargetYourOwnUnits=103 MustTargetYourOwnUnits value
     * @property {number} CantTargetYourOwnUnits=104 CantTargetYourOwnUnits value
     * @property {number} MustTargetFriendlyUnits=105 MustTargetFriendlyUnits value
     * @property {number} CantTargetFriendlyUnits=106 CantTargetFriendlyUnits value
     * @property {number} MustTargetNeutralUnits=107 MustTargetNeutralUnits value
     * @property {number} CantTargetNeutralUnits=108 CantTargetNeutralUnits value
     * @property {number} MustTargetEnemyUnits=109 MustTargetEnemyUnits value
     * @property {number} CantTargetEnemyUnits=110 CantTargetEnemyUnits value
     * @property {number} MustTargetAirUnits=111 MustTargetAirUnits value
     * @property {number} CantTargetAirUnits=112 CantTargetAirUnits value
     * @property {number} MustTargetGroundUnits=113 MustTargetGroundUnits value
     * @property {number} CantTargetGroundUnits=114 CantTargetGroundUnits value
     * @property {number} MustTargetStructures=115 MustTargetStructures value
     * @property {number} CantTargetStructures=116 CantTargetStructures value
     * @property {number} MustTargetLightUnits=117 MustTargetLightUnits value
     * @property {number} CantTargetLightUnits=118 CantTargetLightUnits value
     * @property {number} MustTargetArmoredUnits=119 MustTargetArmoredUnits value
     * @property {number} CantTargetArmoredUnits=120 CantTargetArmoredUnits value
     * @property {number} MustTargetBiologicalUnits=121 MustTargetBiologicalUnits value
     * @property {number} CantTargetBiologicalUnits=122 CantTargetBiologicalUnits value
     * @property {number} MustTargetHeroicUnits=123 MustTargetHeroicUnits value
     * @property {number} CantTargetHeroicUnits=124 CantTargetHeroicUnits value
     * @property {number} MustTargetRoboticUnits=125 MustTargetRoboticUnits value
     * @property {number} CantTargetRoboticUnits=126 CantTargetRoboticUnits value
     * @property {number} MustTargetMechanicalUnits=127 MustTargetMechanicalUnits value
     * @property {number} CantTargetMechanicalUnits=128 CantTargetMechanicalUnits value
     * @property {number} MustTargetPsionicUnits=129 MustTargetPsionicUnits value
     * @property {number} CantTargetPsionicUnits=130 CantTargetPsionicUnits value
     * @property {number} MustTargetMassiveUnits=131 MustTargetMassiveUnits value
     * @property {number} CantTargetMassiveUnits=132 CantTargetMassiveUnits value
     * @property {number} MustTargetMissile=133 MustTargetMissile value
     * @property {number} CantTargetMissile=134 CantTargetMissile value
     * @property {number} MustTargetWorkerUnits=135 MustTargetWorkerUnits value
     * @property {number} CantTargetWorkerUnits=136 CantTargetWorkerUnits value
     * @property {number} MustTargetEnergyCapableUnits=137 MustTargetEnergyCapableUnits value
     * @property {number} CantTargetEnergyCapableUnits=138 CantTargetEnergyCapableUnits value
     * @property {number} MustTargetShieldCapableUnits=139 MustTargetShieldCapableUnits value
     * @property {number} CantTargetShieldCapableUnits=140 CantTargetShieldCapableUnits value
     * @property {number} MustTargetFlyers=141 MustTargetFlyers value
     * @property {number} CantTargetFlyers=142 CantTargetFlyers value
     * @property {number} MustTargetBuriedUnits=143 MustTargetBuriedUnits value
     * @property {number} CantTargetBuriedUnits=144 CantTargetBuriedUnits value
     * @property {number} MustTargetCloakedUnits=145 MustTargetCloakedUnits value
     * @property {number} CantTargetCloakedUnits=146 CantTargetCloakedUnits value
     * @property {number} MustTargetUnitsInAStasisField=147 MustTargetUnitsInAStasisField value
     * @property {number} CantTargetUnitsInAStasisField=148 CantTargetUnitsInAStasisField value
     * @property {number} MustTargetUnderConstructionUnits=149 MustTargetUnderConstructionUnits value
     * @property {number} CantTargetUnderConstructionUnits=150 CantTargetUnderConstructionUnits value
     * @property {number} MustTargetDeadUnits=151 MustTargetDeadUnits value
     * @property {number} CantTargetDeadUnits=152 CantTargetDeadUnits value
     * @property {number} MustTargetRevivableUnits=153 MustTargetRevivableUnits value
     * @property {number} CantTargetRevivableUnits=154 CantTargetRevivableUnits value
     * @property {number} MustTargetHiddenUnits=155 MustTargetHiddenUnits value
     * @property {number} CantTargetHiddenUnits=156 CantTargetHiddenUnits value
     * @property {number} CantRechargeOtherPlayersUnits=157 CantRechargeOtherPlayersUnits value
     * @property {number} MustTargetHallucinations=158 MustTargetHallucinations value
     * @property {number} CantTargetHallucinations=159 CantTargetHallucinations value
     * @property {number} MustTargetInvulnerableUnits=160 MustTargetInvulnerableUnits value
     * @property {number} CantTargetInvulnerableUnits=161 CantTargetInvulnerableUnits value
     * @property {number} MustTargetDetectedUnits=162 MustTargetDetectedUnits value
     * @property {number} CantTargetDetectedUnits=163 CantTargetDetectedUnits value
     * @property {number} CantTargetUnitWithEnergy=164 CantTargetUnitWithEnergy value
     * @property {number} CantTargetUnitWithShields=165 CantTargetUnitWithShields value
     * @property {number} MustTargetUncommandableUnits=166 MustTargetUncommandableUnits value
     * @property {number} CantTargetUncommandableUnits=167 CantTargetUncommandableUnits value
     * @property {number} MustTargetPreventDefeatUnits=168 MustTargetPreventDefeatUnits value
     * @property {number} CantTargetPreventDefeatUnits=169 CantTargetPreventDefeatUnits value
     * @property {number} MustTargetPreventRevealUnits=170 MustTargetPreventRevealUnits value
     * @property {number} CantTargetPreventRevealUnits=171 CantTargetPreventRevealUnits value
     * @property {number} MustTargetPassiveUnits=172 MustTargetPassiveUnits value
     * @property {number} CantTargetPassiveUnits=173 CantTargetPassiveUnits value
     * @property {number} MustTargetStunnedUnits=174 MustTargetStunnedUnits value
     * @property {number} CantTargetStunnedUnits=175 CantTargetStunnedUnits value
     * @property {number} MustTargetSummonedUnits=176 MustTargetSummonedUnits value
     * @property {number} CantTargetSummonedUnits=177 CantTargetSummonedUnits value
     * @property {number} MustTargetUser1=178 MustTargetUser1 value
     * @property {number} CantTargetUser1=179 CantTargetUser1 value
     * @property {number} MustTargetUnstoppableUnits=180 MustTargetUnstoppableUnits value
     * @property {number} CantTargetUnstoppableUnits=181 CantTargetUnstoppableUnits value
     * @property {number} MustTargetResistantUnits=182 MustTargetResistantUnits value
     * @property {number} CantTargetResistantUnits=183 CantTargetResistantUnits value
     * @property {number} MustTargetDazedUnits=184 MustTargetDazedUnits value
     * @property {number} CantTargetDazedUnits=185 CantTargetDazedUnits value
     * @property {number} CantLockdown=186 CantLockdown value
     * @property {number} CantMindControl=187 CantMindControl value
     * @property {number} MustTargetDestructibles=188 MustTargetDestructibles value
     * @property {number} CantTargetDestructibles=189 CantTargetDestructibles value
     * @property {number} MustTargetItems=190 MustTargetItems value
     * @property {number} CantTargetItems=191 CantTargetItems value
     * @property {number} NoCalldownAvailable=192 NoCalldownAvailable value
     * @property {number} WaypointListFull=193 WaypointListFull value
     * @property {number} MustTargetRace=194 MustTargetRace value
     * @property {number} CantTargetRace=195 CantTargetRace value
     * @property {number} MustTargetSimilarUnits=196 MustTargetSimilarUnits value
     * @property {number} CantTargetSimilarUnits=197 CantTargetSimilarUnits value
     * @property {number} CantFindEnoughTargets=198 CantFindEnoughTargets value
     * @property {number} AlreadySpawningLarva=199 AlreadySpawningLarva value
     * @property {number} CantTargetExhaustedResources=200 CantTargetExhaustedResources value
     * @property {number} CantUseMinimap=201 CantUseMinimap value
     * @property {number} CantUseInfoPanel=202 CantUseInfoPanel value
     * @property {number} OrderQueueIsFull=203 OrderQueueIsFull value
     * @property {number} CantHarvestThatResource=204 CantHarvestThatResource value
     * @property {number} HarvestersNotRequired=205 HarvestersNotRequired value
     * @property {number} AlreadyTargeted=206 AlreadyTargeted value
     * @property {number} CantAttackWeaponsDisabled=207 CantAttackWeaponsDisabled value
     * @property {number} CouldntReachTarget=208 CouldntReachTarget value
     * @property {number} TargetIsOutOfRange=209 TargetIsOutOfRange value
     * @property {number} TargetIsTooClose=210 TargetIsTooClose value
     * @property {number} TargetIsOutOfArc=211 TargetIsOutOfArc value
     * @property {number} CantFindTeleportLocation=212 CantFindTeleportLocation value
     * @property {number} InvalidItemClass=213 InvalidItemClass value
     * @property {number} CantFindCancelOrder=214 CantFindCancelOrder value
     */
    SC2APIProtocol.ActionResult = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Success"] = 1;
        values[valuesById[2] = "NotSupported"] = 2;
        values[valuesById[3] = "Error"] = 3;
        values[valuesById[4] = "CantQueueThatOrder"] = 4;
        values[valuesById[5] = "Retry"] = 5;
        values[valuesById[6] = "Cooldown"] = 6;
        values[valuesById[7] = "QueueIsFull"] = 7;
        values[valuesById[8] = "RallyQueueIsFull"] = 8;
        values[valuesById[9] = "NotEnoughMinerals"] = 9;
        values[valuesById[10] = "NotEnoughVespene"] = 10;
        values[valuesById[11] = "NotEnoughTerrazine"] = 11;
        values[valuesById[12] = "NotEnoughCustom"] = 12;
        values[valuesById[13] = "NotEnoughFood"] = 13;
        values[valuesById[14] = "FoodUsageImpossible"] = 14;
        values[valuesById[15] = "NotEnoughLife"] = 15;
        values[valuesById[16] = "NotEnoughShields"] = 16;
        values[valuesById[17] = "NotEnoughEnergy"] = 17;
        values[valuesById[18] = "LifeSuppressed"] = 18;
        values[valuesById[19] = "ShieldsSuppressed"] = 19;
        values[valuesById[20] = "EnergySuppressed"] = 20;
        values[valuesById[21] = "NotEnoughCharges"] = 21;
        values[valuesById[22] = "CantAddMoreCharges"] = 22;
        values[valuesById[23] = "TooMuchMinerals"] = 23;
        values[valuesById[24] = "TooMuchVespene"] = 24;
        values[valuesById[25] = "TooMuchTerrazine"] = 25;
        values[valuesById[26] = "TooMuchCustom"] = 26;
        values[valuesById[27] = "TooMuchFood"] = 27;
        values[valuesById[28] = "TooMuchLife"] = 28;
        values[valuesById[29] = "TooMuchShields"] = 29;
        values[valuesById[30] = "TooMuchEnergy"] = 30;
        values[valuesById[31] = "MustTargetUnitWithLife"] = 31;
        values[valuesById[32] = "MustTargetUnitWithShields"] = 32;
        values[valuesById[33] = "MustTargetUnitWithEnergy"] = 33;
        values[valuesById[34] = "CantTrade"] = 34;
        values[valuesById[35] = "CantSpend"] = 35;
        values[valuesById[36] = "CantTargetThatUnit"] = 36;
        values[valuesById[37] = "CouldntAllocateUnit"] = 37;
        values[valuesById[38] = "UnitCantMove"] = 38;
        values[valuesById[39] = "TransportIsHoldingPosition"] = 39;
        values[valuesById[40] = "BuildTechRequirementsNotMet"] = 40;
        values[valuesById[41] = "CantFindPlacementLocation"] = 41;
        values[valuesById[42] = "CantBuildOnThat"] = 42;
        values[valuesById[43] = "CantBuildTooCloseToDropOff"] = 43;
        values[valuesById[44] = "CantBuildLocationInvalid"] = 44;
        values[valuesById[45] = "CantSeeBuildLocation"] = 45;
        values[valuesById[46] = "CantBuildTooCloseToCreepSource"] = 46;
        values[valuesById[47] = "CantBuildTooCloseToResources"] = 47;
        values[valuesById[48] = "CantBuildTooFarFromWater"] = 48;
        values[valuesById[49] = "CantBuildTooFarFromCreepSource"] = 49;
        values[valuesById[50] = "CantBuildTooFarFromBuildPowerSource"] = 50;
        values[valuesById[51] = "CantBuildOnDenseTerrain"] = 51;
        values[valuesById[52] = "CantTrainTooFarFromTrainPowerSource"] = 52;
        values[valuesById[53] = "CantLandLocationInvalid"] = 53;
        values[valuesById[54] = "CantSeeLandLocation"] = 54;
        values[valuesById[55] = "CantLandTooCloseToCreepSource"] = 55;
        values[valuesById[56] = "CantLandTooCloseToResources"] = 56;
        values[valuesById[57] = "CantLandTooFarFromWater"] = 57;
        values[valuesById[58] = "CantLandTooFarFromCreepSource"] = 58;
        values[valuesById[59] = "CantLandTooFarFromBuildPowerSource"] = 59;
        values[valuesById[60] = "CantLandTooFarFromTrainPowerSource"] = 60;
        values[valuesById[61] = "CantLandOnDenseTerrain"] = 61;
        values[valuesById[62] = "AddOnTooFarFromBuilding"] = 62;
        values[valuesById[63] = "MustBuildRefineryFirst"] = 63;
        values[valuesById[64] = "BuildingIsUnderConstruction"] = 64;
        values[valuesById[65] = "CantFindDropOff"] = 65;
        values[valuesById[66] = "CantLoadOtherPlayersUnits"] = 66;
        values[valuesById[67] = "NotEnoughRoomToLoadUnit"] = 67;
        values[valuesById[68] = "CantUnloadUnitsThere"] = 68;
        values[valuesById[69] = "CantWarpInUnitsThere"] = 69;
        values[valuesById[70] = "CantLoadImmobileUnits"] = 70;
        values[valuesById[71] = "CantRechargeImmobileUnits"] = 71;
        values[valuesById[72] = "CantRechargeUnderConstructionUnits"] = 72;
        values[valuesById[73] = "CantLoadThatUnit"] = 73;
        values[valuesById[74] = "NoCargoToUnload"] = 74;
        values[valuesById[75] = "LoadAllNoTargetsFound"] = 75;
        values[valuesById[76] = "NotWhileOccupied"] = 76;
        values[valuesById[77] = "CantAttackWithoutAmmo"] = 77;
        values[valuesById[78] = "CantHoldAnyMoreAmmo"] = 78;
        values[valuesById[79] = "TechRequirementsNotMet"] = 79;
        values[valuesById[80] = "MustLockdownUnitFirst"] = 80;
        values[valuesById[81] = "MustTargetUnit"] = 81;
        values[valuesById[82] = "MustTargetInventory"] = 82;
        values[valuesById[83] = "MustTargetVisibleUnit"] = 83;
        values[valuesById[84] = "MustTargetVisibleLocation"] = 84;
        values[valuesById[85] = "MustTargetWalkableLocation"] = 85;
        values[valuesById[86] = "MustTargetPawnableUnit"] = 86;
        values[valuesById[87] = "YouCantControlThatUnit"] = 87;
        values[valuesById[88] = "YouCantIssueCommandsToThatUnit"] = 88;
        values[valuesById[89] = "MustTargetResources"] = 89;
        values[valuesById[90] = "RequiresHealTarget"] = 90;
        values[valuesById[91] = "RequiresRepairTarget"] = 91;
        values[valuesById[92] = "NoItemsToDrop"] = 92;
        values[valuesById[93] = "CantHoldAnyMoreItems"] = 93;
        values[valuesById[94] = "CantHoldThat"] = 94;
        values[valuesById[95] = "TargetHasNoInventory"] = 95;
        values[valuesById[96] = "CantDropThisItem"] = 96;
        values[valuesById[97] = "CantMoveThisItem"] = 97;
        values[valuesById[98] = "CantPawnThisUnit"] = 98;
        values[valuesById[99] = "MustTargetCaster"] = 99;
        values[valuesById[100] = "CantTargetCaster"] = 100;
        values[valuesById[101] = "MustTargetOuter"] = 101;
        values[valuesById[102] = "CantTargetOuter"] = 102;
        values[valuesById[103] = "MustTargetYourOwnUnits"] = 103;
        values[valuesById[104] = "CantTargetYourOwnUnits"] = 104;
        values[valuesById[105] = "MustTargetFriendlyUnits"] = 105;
        values[valuesById[106] = "CantTargetFriendlyUnits"] = 106;
        values[valuesById[107] = "MustTargetNeutralUnits"] = 107;
        values[valuesById[108] = "CantTargetNeutralUnits"] = 108;
        values[valuesById[109] = "MustTargetEnemyUnits"] = 109;
        values[valuesById[110] = "CantTargetEnemyUnits"] = 110;
        values[valuesById[111] = "MustTargetAirUnits"] = 111;
        values[valuesById[112] = "CantTargetAirUnits"] = 112;
        values[valuesById[113] = "MustTargetGroundUnits"] = 113;
        values[valuesById[114] = "CantTargetGroundUnits"] = 114;
        values[valuesById[115] = "MustTargetStructures"] = 115;
        values[valuesById[116] = "CantTargetStructures"] = 116;
        values[valuesById[117] = "MustTargetLightUnits"] = 117;
        values[valuesById[118] = "CantTargetLightUnits"] = 118;
        values[valuesById[119] = "MustTargetArmoredUnits"] = 119;
        values[valuesById[120] = "CantTargetArmoredUnits"] = 120;
        values[valuesById[121] = "MustTargetBiologicalUnits"] = 121;
        values[valuesById[122] = "CantTargetBiologicalUnits"] = 122;
        values[valuesById[123] = "MustTargetHeroicUnits"] = 123;
        values[valuesById[124] = "CantTargetHeroicUnits"] = 124;
        values[valuesById[125] = "MustTargetRoboticUnits"] = 125;
        values[valuesById[126] = "CantTargetRoboticUnits"] = 126;
        values[valuesById[127] = "MustTargetMechanicalUnits"] = 127;
        values[valuesById[128] = "CantTargetMechanicalUnits"] = 128;
        values[valuesById[129] = "MustTargetPsionicUnits"] = 129;
        values[valuesById[130] = "CantTargetPsionicUnits"] = 130;
        values[valuesById[131] = "MustTargetMassiveUnits"] = 131;
        values[valuesById[132] = "CantTargetMassiveUnits"] = 132;
        values[valuesById[133] = "MustTargetMissile"] = 133;
        values[valuesById[134] = "CantTargetMissile"] = 134;
        values[valuesById[135] = "MustTargetWorkerUnits"] = 135;
        values[valuesById[136] = "CantTargetWorkerUnits"] = 136;
        values[valuesById[137] = "MustTargetEnergyCapableUnits"] = 137;
        values[valuesById[138] = "CantTargetEnergyCapableUnits"] = 138;
        values[valuesById[139] = "MustTargetShieldCapableUnits"] = 139;
        values[valuesById[140] = "CantTargetShieldCapableUnits"] = 140;
        values[valuesById[141] = "MustTargetFlyers"] = 141;
        values[valuesById[142] = "CantTargetFlyers"] = 142;
        values[valuesById[143] = "MustTargetBuriedUnits"] = 143;
        values[valuesById[144] = "CantTargetBuriedUnits"] = 144;
        values[valuesById[145] = "MustTargetCloakedUnits"] = 145;
        values[valuesById[146] = "CantTargetCloakedUnits"] = 146;
        values[valuesById[147] = "MustTargetUnitsInAStasisField"] = 147;
        values[valuesById[148] = "CantTargetUnitsInAStasisField"] = 148;
        values[valuesById[149] = "MustTargetUnderConstructionUnits"] = 149;
        values[valuesById[150] = "CantTargetUnderConstructionUnits"] = 150;
        values[valuesById[151] = "MustTargetDeadUnits"] = 151;
        values[valuesById[152] = "CantTargetDeadUnits"] = 152;
        values[valuesById[153] = "MustTargetRevivableUnits"] = 153;
        values[valuesById[154] = "CantTargetRevivableUnits"] = 154;
        values[valuesById[155] = "MustTargetHiddenUnits"] = 155;
        values[valuesById[156] = "CantTargetHiddenUnits"] = 156;
        values[valuesById[157] = "CantRechargeOtherPlayersUnits"] = 157;
        values[valuesById[158] = "MustTargetHallucinations"] = 158;
        values[valuesById[159] = "CantTargetHallucinations"] = 159;
        values[valuesById[160] = "MustTargetInvulnerableUnits"] = 160;
        values[valuesById[161] = "CantTargetInvulnerableUnits"] = 161;
        values[valuesById[162] = "MustTargetDetectedUnits"] = 162;
        values[valuesById[163] = "CantTargetDetectedUnits"] = 163;
        values[valuesById[164] = "CantTargetUnitWithEnergy"] = 164;
        values[valuesById[165] = "CantTargetUnitWithShields"] = 165;
        values[valuesById[166] = "MustTargetUncommandableUnits"] = 166;
        values[valuesById[167] = "CantTargetUncommandableUnits"] = 167;
        values[valuesById[168] = "MustTargetPreventDefeatUnits"] = 168;
        values[valuesById[169] = "CantTargetPreventDefeatUnits"] = 169;
        values[valuesById[170] = "MustTargetPreventRevealUnits"] = 170;
        values[valuesById[171] = "CantTargetPreventRevealUnits"] = 171;
        values[valuesById[172] = "MustTargetPassiveUnits"] = 172;
        values[valuesById[173] = "CantTargetPassiveUnits"] = 173;
        values[valuesById[174] = "MustTargetStunnedUnits"] = 174;
        values[valuesById[175] = "CantTargetStunnedUnits"] = 175;
        values[valuesById[176] = "MustTargetSummonedUnits"] = 176;
        values[valuesById[177] = "CantTargetSummonedUnits"] = 177;
        values[valuesById[178] = "MustTargetUser1"] = 178;
        values[valuesById[179] = "CantTargetUser1"] = 179;
        values[valuesById[180] = "MustTargetUnstoppableUnits"] = 180;
        values[valuesById[181] = "CantTargetUnstoppableUnits"] = 181;
        values[valuesById[182] = "MustTargetResistantUnits"] = 182;
        values[valuesById[183] = "CantTargetResistantUnits"] = 183;
        values[valuesById[184] = "MustTargetDazedUnits"] = 184;
        values[valuesById[185] = "CantTargetDazedUnits"] = 185;
        values[valuesById[186] = "CantLockdown"] = 186;
        values[valuesById[187] = "CantMindControl"] = 187;
        values[valuesById[188] = "MustTargetDestructibles"] = 188;
        values[valuesById[189] = "CantTargetDestructibles"] = 189;
        values[valuesById[190] = "MustTargetItems"] = 190;
        values[valuesById[191] = "CantTargetItems"] = 191;
        values[valuesById[192] = "NoCalldownAvailable"] = 192;
        values[valuesById[193] = "WaypointListFull"] = 193;
        values[valuesById[194] = "MustTargetRace"] = 194;
        values[valuesById[195] = "CantTargetRace"] = 195;
        values[valuesById[196] = "MustTargetSimilarUnits"] = 196;
        values[valuesById[197] = "CantTargetSimilarUnits"] = 197;
        values[valuesById[198] = "CantFindEnoughTargets"] = 198;
        values[valuesById[199] = "AlreadySpawningLarva"] = 199;
        values[valuesById[200] = "CantTargetExhaustedResources"] = 200;
        values[valuesById[201] = "CantUseMinimap"] = 201;
        values[valuesById[202] = "CantUseInfoPanel"] = 202;
        values[valuesById[203] = "OrderQueueIsFull"] = 203;
        values[valuesById[204] = "CantHarvestThatResource"] = 204;
        values[valuesById[205] = "HarvestersNotRequired"] = 205;
        values[valuesById[206] = "AlreadyTargeted"] = 206;
        values[valuesById[207] = "CantAttackWeaponsDisabled"] = 207;
        values[valuesById[208] = "CouldntReachTarget"] = 208;
        values[valuesById[209] = "TargetIsOutOfRange"] = 209;
        values[valuesById[210] = "TargetIsTooClose"] = 210;
        values[valuesById[211] = "TargetIsOutOfArc"] = 211;
        values[valuesById[212] = "CantFindTeleportLocation"] = 212;
        values[valuesById[213] = "InvalidItemClass"] = 213;
        values[valuesById[214] = "CantFindCancelOrder"] = 214;
        return values;
    })();
    SC2APIProtocol.RequestQuery = (function () {
        /**
         * Properties of a RequestQuery.
         * @memberof SC2APIProtocol
         * @interface IRequestQuery
         * @property {Array.<SC2APIProtocol.IRequestQueryPathing>} [pathing] RequestQuery pathing
         * @property {Array.<SC2APIProtocol.IRequestQueryAvailableAbilities>} [abilities] RequestQuery abilities
         * @property {Array.<SC2APIProtocol.IRequestQueryBuildingPlacement>} [placements] RequestQuery placements
         * @property {boolean} [ignoreResourceRequirements] RequestQuery ignoreResourceRequirements
         */
        /**
         * Constructs a new RequestQuery.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQuery.
         * @constructor
         * @param {SC2APIProtocol.IRequestQuery=} [properties] Properties to set
         */
        function RequestQuery(properties) {
            this.pathing = [];
            this.abilities = [];
            this.placements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestQuery pathing.
         * @member {Array.<SC2APIProtocol.IRequestQueryPathing>}pathing
         * @memberof SC2APIProtocol.RequestQuery
         * @instance
         */
        RequestQuery.prototype.pathing = $util.emptyArray;
        /**
         * RequestQuery abilities.
         * @member {Array.<SC2APIProtocol.IRequestQueryAvailableAbilities>}abilities
         * @memberof SC2APIProtocol.RequestQuery
         * @instance
         */
        RequestQuery.prototype.abilities = $util.emptyArray;
        /**
         * RequestQuery placements.
         * @member {Array.<SC2APIProtocol.IRequestQueryBuildingPlacement>}placements
         * @memberof SC2APIProtocol.RequestQuery
         * @instance
         */
        RequestQuery.prototype.placements = $util.emptyArray;
        /**
         * RequestQuery ignoreResourceRequirements.
         * @member {boolean}ignoreResourceRequirements
         * @memberof SC2APIProtocol.RequestQuery
         * @instance
         */
        RequestQuery.prototype.ignoreResourceRequirements = false;
        /**
         * Creates a new RequestQuery instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {SC2APIProtocol.IRequestQuery=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQuery} RequestQuery instance
         */
        RequestQuery.create = function create(properties) {
            return new RequestQuery(properties);
        };
        /**
         * Encodes the specified RequestQuery message. Does not implicitly {@link SC2APIProtocol.RequestQuery.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {SC2APIProtocol.IRequestQuery} message RequestQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pathing != null && message.pathing.length)
                for (var i = 0; i < message.pathing.length; ++i)
                    $root.SC2APIProtocol.RequestQueryPathing.encode(message.pathing[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.abilities != null && message.abilities.length)
                for (var i = 0; i < message.abilities.length; ++i)
                    $root.SC2APIProtocol.RequestQueryAvailableAbilities.encode(message.abilities[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.placements != null && message.placements.length)
                for (var i = 0; i < message.placements.length; ++i)
                    $root.SC2APIProtocol.RequestQueryBuildingPlacement.encode(message.placements[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.ignoreResourceRequirements != null && message.hasOwnProperty("ignoreResourceRequirements"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.ignoreResourceRequirements);
            return writer;
        };
        /**
         * Encodes the specified RequestQuery message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {SC2APIProtocol.IRequestQuery} message RequestQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQuery message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQuery} RequestQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.pathing && message.pathing.length))
                            message.pathing = [];
                        message.pathing.push($root.SC2APIProtocol.RequestQueryPathing.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.SC2APIProtocol.RequestQueryAvailableAbilities.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.placements && message.placements.length))
                            message.placements = [];
                        message.placements.push($root.SC2APIProtocol.RequestQueryBuildingPlacement.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.ignoreResourceRequirements = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQuery} RequestQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQuery message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pathing != null && message.hasOwnProperty("pathing")) {
                if (!Array.isArray(message.pathing))
                    return "pathing: array expected";
                for (var i = 0; i < message.pathing.length; ++i) {
                    var error = $root.SC2APIProtocol.RequestQueryPathing.verify(message.pathing[i]);
                    if (error)
                        return "pathing." + error;
                }
            }
            if (message.abilities != null && message.hasOwnProperty("abilities")) {
                if (!Array.isArray(message.abilities))
                    return "abilities: array expected";
                for (var i = 0; i < message.abilities.length; ++i) {
                    error = $root.SC2APIProtocol.RequestQueryAvailableAbilities.verify(message.abilities[i]);
                    if (error)
                        return "abilities." + error;
                }
            }
            if (message.placements != null && message.hasOwnProperty("placements")) {
                if (!Array.isArray(message.placements))
                    return "placements: array expected";
                for (var i = 0; i < message.placements.length; ++i) {
                    error = $root.SC2APIProtocol.RequestQueryBuildingPlacement.verify(message.placements[i]);
                    if (error)
                        return "placements." + error;
                }
            }
            if (message.ignoreResourceRequirements != null && message.hasOwnProperty("ignoreResourceRequirements"))
                if (typeof message.ignoreResourceRequirements !== "boolean")
                    return "ignoreResourceRequirements: boolean expected";
            return null;
        };
        /**
         * Creates a RequestQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQuery} RequestQuery
         */
        RequestQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQuery)
                return object;
            var message = new $root.SC2APIProtocol.RequestQuery();
            if (object.pathing) {
                if (!Array.isArray(object.pathing))
                    throw TypeError(".SC2APIProtocol.RequestQuery.pathing: array expected");
                message.pathing = [];
                for (var i = 0; i < object.pathing.length; ++i) {
                    if (typeof object.pathing[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestQuery.pathing: object expected");
                    message.pathing[i] = $root.SC2APIProtocol.RequestQueryPathing.fromObject(object.pathing[i]);
                }
            }
            if (object.abilities) {
                if (!Array.isArray(object.abilities))
                    throw TypeError(".SC2APIProtocol.RequestQuery.abilities: array expected");
                message.abilities = [];
                for (var i = 0; i < object.abilities.length; ++i) {
                    if (typeof object.abilities[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestQuery.abilities: object expected");
                    message.abilities[i] = $root.SC2APIProtocol.RequestQueryAvailableAbilities.fromObject(object.abilities[i]);
                }
            }
            if (object.placements) {
                if (!Array.isArray(object.placements))
                    throw TypeError(".SC2APIProtocol.RequestQuery.placements: array expected");
                message.placements = [];
                for (var i = 0; i < object.placements.length; ++i) {
                    if (typeof object.placements[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestQuery.placements: object expected");
                    message.placements[i] = $root.SC2APIProtocol.RequestQueryBuildingPlacement.fromObject(object.placements[i]);
                }
            }
            if (object.ignoreResourceRequirements != null)
                message.ignoreResourceRequirements = Boolean(object.ignoreResourceRequirements);
            return message;
        };
        /**
         * Creates a plain object from a RequestQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQuery
         * @static
         * @param {SC2APIProtocol.RequestQuery} message RequestQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pathing = [];
                object.abilities = [];
                object.placements = [];
            }
            if (options.defaults)
                object.ignoreResourceRequirements = false;
            if (message.pathing && message.pathing.length) {
                object.pathing = [];
                for (var j = 0; j < message.pathing.length; ++j)
                    object.pathing[j] = $root.SC2APIProtocol.RequestQueryPathing.toObject(message.pathing[j], options);
            }
            if (message.abilities && message.abilities.length) {
                object.abilities = [];
                for (var j = 0; j < message.abilities.length; ++j)
                    object.abilities[j] = $root.SC2APIProtocol.RequestQueryAvailableAbilities.toObject(message.abilities[j], options);
            }
            if (message.placements && message.placements.length) {
                object.placements = [];
                for (var j = 0; j < message.placements.length; ++j)
                    object.placements[j] = $root.SC2APIProtocol.RequestQueryBuildingPlacement.toObject(message.placements[j], options);
            }
            if (message.ignoreResourceRequirements != null && message.hasOwnProperty("ignoreResourceRequirements"))
                object.ignoreResourceRequirements = message.ignoreResourceRequirements;
            return object;
        };
        /**
         * Converts this RequestQuery to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQuery;
    })();
    SC2APIProtocol.ResponseQuery = (function () {
        /**
         * Properties of a ResponseQuery.
         * @memberof SC2APIProtocol
         * @interface IResponseQuery
         * @property {Array.<SC2APIProtocol.IResponseQueryPathing>} [pathing] ResponseQuery pathing
         * @property {Array.<SC2APIProtocol.IResponseQueryAvailableAbilities>} [abilities] ResponseQuery abilities
         * @property {Array.<SC2APIProtocol.IResponseQueryBuildingPlacement>} [placements] ResponseQuery placements
         */
        /**
         * Constructs a new ResponseQuery.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQuery.
         * @constructor
         * @param {SC2APIProtocol.IResponseQuery=} [properties] Properties to set
         */
        function ResponseQuery(properties) {
            this.pathing = [];
            this.abilities = [];
            this.placements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseQuery pathing.
         * @member {Array.<SC2APIProtocol.IResponseQueryPathing>}pathing
         * @memberof SC2APIProtocol.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.pathing = $util.emptyArray;
        /**
         * ResponseQuery abilities.
         * @member {Array.<SC2APIProtocol.IResponseQueryAvailableAbilities>}abilities
         * @memberof SC2APIProtocol.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.abilities = $util.emptyArray;
        /**
         * ResponseQuery placements.
         * @member {Array.<SC2APIProtocol.IResponseQueryBuildingPlacement>}placements
         * @memberof SC2APIProtocol.ResponseQuery
         * @instance
         */
        ResponseQuery.prototype.placements = $util.emptyArray;
        /**
         * Creates a new ResponseQuery instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {SC2APIProtocol.IResponseQuery=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQuery} ResponseQuery instance
         */
        ResponseQuery.create = function create(properties) {
            return new ResponseQuery(properties);
        };
        /**
         * Encodes the specified ResponseQuery message. Does not implicitly {@link SC2APIProtocol.ResponseQuery.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {SC2APIProtocol.IResponseQuery} message ResponseQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pathing != null && message.pathing.length)
                for (var i = 0; i < message.pathing.length; ++i)
                    $root.SC2APIProtocol.ResponseQueryPathing.encode(message.pathing[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.abilities != null && message.abilities.length)
                for (var i = 0; i < message.abilities.length; ++i)
                    $root.SC2APIProtocol.ResponseQueryAvailableAbilities.encode(message.abilities[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.placements != null && message.placements.length)
                for (var i = 0; i < message.placements.length; ++i)
                    $root.SC2APIProtocol.ResponseQueryBuildingPlacement.encode(message.placements[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ResponseQuery message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {SC2APIProtocol.IResponseQuery} message ResponseQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQuery message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQuery} ResponseQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.pathing && message.pathing.length))
                            message.pathing = [];
                        message.pathing.push($root.SC2APIProtocol.ResponseQueryPathing.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.SC2APIProtocol.ResponseQueryAvailableAbilities.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.placements && message.placements.length))
                            message.placements = [];
                        message.placements.push($root.SC2APIProtocol.ResponseQueryBuildingPlacement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQuery} ResponseQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQuery message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pathing != null && message.hasOwnProperty("pathing")) {
                if (!Array.isArray(message.pathing))
                    return "pathing: array expected";
                for (var i = 0; i < message.pathing.length; ++i) {
                    var error = $root.SC2APIProtocol.ResponseQueryPathing.verify(message.pathing[i]);
                    if (error)
                        return "pathing." + error;
                }
            }
            if (message.abilities != null && message.hasOwnProperty("abilities")) {
                if (!Array.isArray(message.abilities))
                    return "abilities: array expected";
                for (var i = 0; i < message.abilities.length; ++i) {
                    error = $root.SC2APIProtocol.ResponseQueryAvailableAbilities.verify(message.abilities[i]);
                    if (error)
                        return "abilities." + error;
                }
            }
            if (message.placements != null && message.hasOwnProperty("placements")) {
                if (!Array.isArray(message.placements))
                    return "placements: array expected";
                for (var i = 0; i < message.placements.length; ++i) {
                    error = $root.SC2APIProtocol.ResponseQueryBuildingPlacement.verify(message.placements[i]);
                    if (error)
                        return "placements." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ResponseQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQuery} ResponseQuery
         */
        ResponseQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQuery)
                return object;
            var message = new $root.SC2APIProtocol.ResponseQuery();
            if (object.pathing) {
                if (!Array.isArray(object.pathing))
                    throw TypeError(".SC2APIProtocol.ResponseQuery.pathing: array expected");
                message.pathing = [];
                for (var i = 0; i < object.pathing.length; ++i) {
                    if (typeof object.pathing[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseQuery.pathing: object expected");
                    message.pathing[i] = $root.SC2APIProtocol.ResponseQueryPathing.fromObject(object.pathing[i]);
                }
            }
            if (object.abilities) {
                if (!Array.isArray(object.abilities))
                    throw TypeError(".SC2APIProtocol.ResponseQuery.abilities: array expected");
                message.abilities = [];
                for (var i = 0; i < object.abilities.length; ++i) {
                    if (typeof object.abilities[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseQuery.abilities: object expected");
                    message.abilities[i] = $root.SC2APIProtocol.ResponseQueryAvailableAbilities.fromObject(object.abilities[i]);
                }
            }
            if (object.placements) {
                if (!Array.isArray(object.placements))
                    throw TypeError(".SC2APIProtocol.ResponseQuery.placements: array expected");
                message.placements = [];
                for (var i = 0; i < object.placements.length; ++i) {
                    if (typeof object.placements[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseQuery.placements: object expected");
                    message.placements[i] = $root.SC2APIProtocol.ResponseQueryBuildingPlacement.fromObject(object.placements[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQuery
         * @static
         * @param {SC2APIProtocol.ResponseQuery} message ResponseQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pathing = [];
                object.abilities = [];
                object.placements = [];
            }
            if (message.pathing && message.pathing.length) {
                object.pathing = [];
                for (var j = 0; j < message.pathing.length; ++j)
                    object.pathing[j] = $root.SC2APIProtocol.ResponseQueryPathing.toObject(message.pathing[j], options);
            }
            if (message.abilities && message.abilities.length) {
                object.abilities = [];
                for (var j = 0; j < message.abilities.length; ++j)
                    object.abilities[j] = $root.SC2APIProtocol.ResponseQueryAvailableAbilities.toObject(message.abilities[j], options);
            }
            if (message.placements && message.placements.length) {
                object.placements = [];
                for (var j = 0; j < message.placements.length; ++j)
                    object.placements[j] = $root.SC2APIProtocol.ResponseQueryBuildingPlacement.toObject(message.placements[j], options);
            }
            return object;
        };
        /**
         * Converts this ResponseQuery to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQuery;
    })();
    SC2APIProtocol.RequestQueryPathing = (function () {
        /**
         * Properties of a RequestQueryPathing.
         * @memberof SC2APIProtocol
         * @interface IRequestQueryPathing
         * @property {SC2APIProtocol.IPoint2D} [startPos] RequestQueryPathing startPos
         * @property {number|Long} [unitTag] RequestQueryPathing unitTag
         * @property {SC2APIProtocol.IPoint2D} [endPos] RequestQueryPathing endPos
         */
        /**
         * Constructs a new RequestQueryPathing.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQueryPathing.
         * @constructor
         * @param {SC2APIProtocol.IRequestQueryPathing=} [properties] Properties to set
         */
        function RequestQueryPathing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestQueryPathing startPos.
         * @member {(SC2APIProtocol.IPoint2D|null|undefined)}startPos
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @instance
         */
        RequestQueryPathing.prototype.startPos = null;
        /**
         * RequestQueryPathing unitTag.
         * @member {number|Long}unitTag
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @instance
         */
        RequestQueryPathing.prototype.unitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * RequestQueryPathing endPos.
         * @member {(SC2APIProtocol.IPoint2D|null|undefined)}endPos
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @instance
         */
        RequestQueryPathing.prototype.endPos = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestQueryPathing start.
         * @member {string|undefined} start
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @instance
         */
        Object.defineProperty(RequestQueryPathing.prototype, "start", {
            get: $util.oneOfGetter($oneOfFields = ["startPos", "unitTag"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestQueryPathing instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {SC2APIProtocol.IRequestQueryPathing=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQueryPathing} RequestQueryPathing instance
         */
        RequestQueryPathing.create = function create(properties) {
            return new RequestQueryPathing(properties);
        };
        /**
         * Encodes the specified RequestQueryPathing message. Does not implicitly {@link SC2APIProtocol.RequestQueryPathing.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {SC2APIProtocol.IRequestQueryPathing} message RequestQueryPathing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryPathing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startPos != null && message.hasOwnProperty("startPos"))
                $root.SC2APIProtocol.Point2D.encode(message.startPos, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.unitTag);
            if (message.endPos != null && message.hasOwnProperty("endPos"))
                $root.SC2APIProtocol.Point2D.encode(message.endPos, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified RequestQueryPathing message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQueryPathing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {SC2APIProtocol.IRequestQueryPathing} message RequestQueryPathing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryPathing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQueryPathing message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQueryPathing} RequestQueryPathing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryPathing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQueryPathing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.startPos = $root.SC2APIProtocol.Point2D.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.unitTag = reader.uint64();
                        break;
                    case 3:
                        message.endPos = $root.SC2APIProtocol.Point2D.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQueryPathing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQueryPathing} RequestQueryPathing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryPathing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQueryPathing message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQueryPathing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.startPos != null && message.hasOwnProperty("startPos")) {
                properties.start = 1;
                var error = $root.SC2APIProtocol.Point2D.verify(message.startPos);
                if (error)
                    return "startPos." + error;
            }
            if (message.unitTag != null && message.hasOwnProperty("unitTag")) {
                if (properties.start === 1)
                    return "start: multiple values";
                properties.start = 1;
                if (!$util.isInteger(message.unitTag) && !(message.unitTag && $util.isInteger(message.unitTag.low) && $util.isInteger(message.unitTag.high)))
                    return "unitTag: integer|Long expected";
            }
            if (message.endPos != null && message.hasOwnProperty("endPos")) {
                error = $root.SC2APIProtocol.Point2D.verify(message.endPos);
                if (error)
                    return "endPos." + error;
            }
            return null;
        };
        /**
         * Creates a RequestQueryPathing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQueryPathing} RequestQueryPathing
         */
        RequestQueryPathing.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQueryPathing)
                return object;
            var message = new $root.SC2APIProtocol.RequestQueryPathing();
            if (object.startPos != null) {
                if (typeof object.startPos !== "object")
                    throw TypeError(".SC2APIProtocol.RequestQueryPathing.startPos: object expected");
                message.startPos = $root.SC2APIProtocol.Point2D.fromObject(object.startPos);
            }
            if (object.unitTag != null)
                if ($util.Long)
                    (message.unitTag = $util.Long.fromValue(object.unitTag)).unsigned = true;
                else if (typeof object.unitTag === "string")
                    message.unitTag = parseInt(object.unitTag, 10);
                else if (typeof object.unitTag === "number")
                    message.unitTag = object.unitTag;
                else if (typeof object.unitTag === "object")
                    message.unitTag = new $util.LongBits(object.unitTag.low >>> 0, object.unitTag.high >>> 0).toNumber(true);
            if (object.endPos != null) {
                if (typeof object.endPos !== "object")
                    throw TypeError(".SC2APIProtocol.RequestQueryPathing.endPos: object expected");
                message.endPos = $root.SC2APIProtocol.Point2D.fromObject(object.endPos);
            }
            return message;
        };
        /**
         * Creates a plain object from a RequestQueryPathing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @static
         * @param {SC2APIProtocol.RequestQueryPathing} message RequestQueryPathing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQueryPathing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.endPos = null;
            if (message.startPos != null && message.hasOwnProperty("startPos")) {
                object.startPos = $root.SC2APIProtocol.Point2D.toObject(message.startPos, options);
                if (options.oneofs)
                    object.start = "startPos";
            }
            if (message.unitTag != null && message.hasOwnProperty("unitTag")) {
                if (typeof message.unitTag === "number")
                    object.unitTag = options.longs === String ? String(message.unitTag) : message.unitTag;
                else
                    object.unitTag = options.longs === String ? $util.Long.prototype.toString.call(message.unitTag) : options.longs === Number ? new $util.LongBits(message.unitTag.low >>> 0, message.unitTag.high >>> 0).toNumber(true) : message.unitTag;
                if (options.oneofs)
                    object.start = "unitTag";
            }
            if (message.endPos != null && message.hasOwnProperty("endPos"))
                object.endPos = $root.SC2APIProtocol.Point2D.toObject(message.endPos, options);
            return object;
        };
        /**
         * Converts this RequestQueryPathing to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQueryPathing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQueryPathing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQueryPathing;
    })();
    SC2APIProtocol.ResponseQueryPathing = (function () {
        /**
         * Properties of a ResponseQueryPathing.
         * @memberof SC2APIProtocol
         * @interface IResponseQueryPathing
         * @property {number} [distance] ResponseQueryPathing distance
         */
        /**
         * Constructs a new ResponseQueryPathing.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQueryPathing.
         * @constructor
         * @param {SC2APIProtocol.IResponseQueryPathing=} [properties] Properties to set
         */
        function ResponseQueryPathing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseQueryPathing distance.
         * @member {number}distance
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @instance
         */
        ResponseQueryPathing.prototype.distance = 0;
        /**
         * Creates a new ResponseQueryPathing instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {SC2APIProtocol.IResponseQueryPathing=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQueryPathing} ResponseQueryPathing instance
         */
        ResponseQueryPathing.create = function create(properties) {
            return new ResponseQueryPathing(properties);
        };
        /**
         * Encodes the specified ResponseQueryPathing message. Does not implicitly {@link SC2APIProtocol.ResponseQueryPathing.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {SC2APIProtocol.IResponseQueryPathing} message ResponseQueryPathing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryPathing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distance != null && message.hasOwnProperty("distance"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.distance);
            return writer;
        };
        /**
         * Encodes the specified ResponseQueryPathing message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQueryPathing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {SC2APIProtocol.IResponseQueryPathing} message ResponseQueryPathing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryPathing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQueryPathing message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQueryPathing} ResponseQueryPathing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryPathing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQueryPathing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.distance = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQueryPathing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQueryPathing} ResponseQueryPathing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryPathing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQueryPathing message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQueryPathing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            return null;
        };
        /**
         * Creates a ResponseQueryPathing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQueryPathing} ResponseQueryPathing
         */
        ResponseQueryPathing.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQueryPathing)
                return object;
            var message = new $root.SC2APIProtocol.ResponseQueryPathing();
            if (object.distance != null)
                message.distance = Number(object.distance);
            return message;
        };
        /**
         * Creates a plain object from a ResponseQueryPathing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @static
         * @param {SC2APIProtocol.ResponseQueryPathing} message ResponseQueryPathing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQueryPathing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.distance = 0;
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
            return object;
        };
        /**
         * Converts this ResponseQueryPathing to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQueryPathing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQueryPathing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQueryPathing;
    })();
    SC2APIProtocol.RequestQueryAvailableAbilities = (function () {
        /**
         * Properties of a RequestQueryAvailableAbilities.
         * @memberof SC2APIProtocol
         * @interface IRequestQueryAvailableAbilities
         * @property {number|Long} [unitTag] RequestQueryAvailableAbilities unitTag
         */
        /**
         * Constructs a new RequestQueryAvailableAbilities.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQueryAvailableAbilities.
         * @constructor
         * @param {SC2APIProtocol.IRequestQueryAvailableAbilities=} [properties] Properties to set
         */
        function RequestQueryAvailableAbilities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestQueryAvailableAbilities unitTag.
         * @member {number|Long}unitTag
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @instance
         */
        RequestQueryAvailableAbilities.prototype.unitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new RequestQueryAvailableAbilities instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IRequestQueryAvailableAbilities=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQueryAvailableAbilities} RequestQueryAvailableAbilities instance
         */
        RequestQueryAvailableAbilities.create = function create(properties) {
            return new RequestQueryAvailableAbilities(properties);
        };
        /**
         * Encodes the specified RequestQueryAvailableAbilities message. Does not implicitly {@link SC2APIProtocol.RequestQueryAvailableAbilities.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IRequestQueryAvailableAbilities} message RequestQueryAvailableAbilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryAvailableAbilities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.unitTag);
            return writer;
        };
        /**
         * Encodes the specified RequestQueryAvailableAbilities message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQueryAvailableAbilities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IRequestQueryAvailableAbilities} message RequestQueryAvailableAbilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryAvailableAbilities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQueryAvailableAbilities message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQueryAvailableAbilities} RequestQueryAvailableAbilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryAvailableAbilities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQueryAvailableAbilities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitTag = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQueryAvailableAbilities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQueryAvailableAbilities} RequestQueryAvailableAbilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryAvailableAbilities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQueryAvailableAbilities message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQueryAvailableAbilities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (!$util.isInteger(message.unitTag) && !(message.unitTag && $util.isInteger(message.unitTag.low) && $util.isInteger(message.unitTag.high)))
                    return "unitTag: integer|Long expected";
            return null;
        };
        /**
         * Creates a RequestQueryAvailableAbilities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQueryAvailableAbilities} RequestQueryAvailableAbilities
         */
        RequestQueryAvailableAbilities.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQueryAvailableAbilities)
                return object;
            var message = new $root.SC2APIProtocol.RequestQueryAvailableAbilities();
            if (object.unitTag != null)
                if ($util.Long)
                    (message.unitTag = $util.Long.fromValue(object.unitTag)).unsigned = true;
                else if (typeof object.unitTag === "string")
                    message.unitTag = parseInt(object.unitTag, 10);
                else if (typeof object.unitTag === "number")
                    message.unitTag = object.unitTag;
                else if (typeof object.unitTag === "object")
                    message.unitTag = new $util.LongBits(object.unitTag.low >>> 0, object.unitTag.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from a RequestQueryAvailableAbilities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.RequestQueryAvailableAbilities} message RequestQueryAvailableAbilities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQueryAvailableAbilities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.unitTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.unitTag = options.longs === String ? "0" : 0;
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (typeof message.unitTag === "number")
                    object.unitTag = options.longs === String ? String(message.unitTag) : message.unitTag;
                else
                    object.unitTag = options.longs === String ? $util.Long.prototype.toString.call(message.unitTag) : options.longs === Number ? new $util.LongBits(message.unitTag.low >>> 0, message.unitTag.high >>> 0).toNumber(true) : message.unitTag;
            return object;
        };
        /**
         * Converts this RequestQueryAvailableAbilities to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQueryAvailableAbilities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQueryAvailableAbilities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQueryAvailableAbilities;
    })();
    SC2APIProtocol.ResponseQueryAvailableAbilities = (function () {
        /**
         * Properties of a ResponseQueryAvailableAbilities.
         * @memberof SC2APIProtocol
         * @interface IResponseQueryAvailableAbilities
         * @property {Array.<SC2APIProtocol.IAvailableAbility>} [abilities] ResponseQueryAvailableAbilities abilities
         * @property {number|Long} [unitTag] ResponseQueryAvailableAbilities unitTag
         * @property {number} [unitTypeId] ResponseQueryAvailableAbilities unitTypeId
         */
        /**
         * Constructs a new ResponseQueryAvailableAbilities.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQueryAvailableAbilities.
         * @constructor
         * @param {SC2APIProtocol.IResponseQueryAvailableAbilities=} [properties] Properties to set
         */
        function ResponseQueryAvailableAbilities(properties) {
            this.abilities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseQueryAvailableAbilities abilities.
         * @member {Array.<SC2APIProtocol.IAvailableAbility>}abilities
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @instance
         */
        ResponseQueryAvailableAbilities.prototype.abilities = $util.emptyArray;
        /**
         * ResponseQueryAvailableAbilities unitTag.
         * @member {number|Long}unitTag
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @instance
         */
        ResponseQueryAvailableAbilities.prototype.unitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * ResponseQueryAvailableAbilities unitTypeId.
         * @member {number}unitTypeId
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @instance
         */
        ResponseQueryAvailableAbilities.prototype.unitTypeId = 0;
        /**
         * Creates a new ResponseQueryAvailableAbilities instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IResponseQueryAvailableAbilities=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQueryAvailableAbilities} ResponseQueryAvailableAbilities instance
         */
        ResponseQueryAvailableAbilities.create = function create(properties) {
            return new ResponseQueryAvailableAbilities(properties);
        };
        /**
         * Encodes the specified ResponseQueryAvailableAbilities message. Does not implicitly {@link SC2APIProtocol.ResponseQueryAvailableAbilities.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IResponseQueryAvailableAbilities} message ResponseQueryAvailableAbilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryAvailableAbilities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilities != null && message.abilities.length)
                for (var i = 0; i < message.abilities.length; ++i)
                    $root.SC2APIProtocol.AvailableAbility.encode(message.abilities[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.unitTag);
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.unitTypeId);
            return writer;
        };
        /**
         * Encodes the specified ResponseQueryAvailableAbilities message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQueryAvailableAbilities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.IResponseQueryAvailableAbilities} message ResponseQueryAvailableAbilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryAvailableAbilities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQueryAvailableAbilities message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQueryAvailableAbilities} ResponseQueryAvailableAbilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryAvailableAbilities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQueryAvailableAbilities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.SC2APIProtocol.AvailableAbility.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.unitTag = reader.uint64();
                        break;
                    case 3:
                        message.unitTypeId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQueryAvailableAbilities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQueryAvailableAbilities} ResponseQueryAvailableAbilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryAvailableAbilities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQueryAvailableAbilities message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQueryAvailableAbilities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilities != null && message.hasOwnProperty("abilities")) {
                if (!Array.isArray(message.abilities))
                    return "abilities: array expected";
                for (var i = 0; i < message.abilities.length; ++i) {
                    var error = $root.SC2APIProtocol.AvailableAbility.verify(message.abilities[i]);
                    if (error)
                        return "abilities." + error;
                }
            }
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (!$util.isInteger(message.unitTag) && !(message.unitTag && $util.isInteger(message.unitTag.low) && $util.isInteger(message.unitTag.high)))
                    return "unitTag: integer|Long expected";
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                if (!$util.isInteger(message.unitTypeId))
                    return "unitTypeId: integer expected";
            return null;
        };
        /**
         * Creates a ResponseQueryAvailableAbilities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQueryAvailableAbilities} ResponseQueryAvailableAbilities
         */
        ResponseQueryAvailableAbilities.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQueryAvailableAbilities)
                return object;
            var message = new $root.SC2APIProtocol.ResponseQueryAvailableAbilities();
            if (object.abilities) {
                if (!Array.isArray(object.abilities))
                    throw TypeError(".SC2APIProtocol.ResponseQueryAvailableAbilities.abilities: array expected");
                message.abilities = [];
                for (var i = 0; i < object.abilities.length; ++i) {
                    if (typeof object.abilities[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseQueryAvailableAbilities.abilities: object expected");
                    message.abilities[i] = $root.SC2APIProtocol.AvailableAbility.fromObject(object.abilities[i]);
                }
            }
            if (object.unitTag != null)
                if ($util.Long)
                    (message.unitTag = $util.Long.fromValue(object.unitTag)).unsigned = true;
                else if (typeof object.unitTag === "string")
                    message.unitTag = parseInt(object.unitTag, 10);
                else if (typeof object.unitTag === "number")
                    message.unitTag = object.unitTag;
                else if (typeof object.unitTag === "object")
                    message.unitTag = new $util.LongBits(object.unitTag.low >>> 0, object.unitTag.high >>> 0).toNumber(true);
            if (object.unitTypeId != null)
                message.unitTypeId = object.unitTypeId >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a ResponseQueryAvailableAbilities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @static
         * @param {SC2APIProtocol.ResponseQueryAvailableAbilities} message ResponseQueryAvailableAbilities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQueryAvailableAbilities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.abilities = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.unitTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.unitTag = options.longs === String ? "0" : 0;
                object.unitTypeId = 0;
            }
            if (message.abilities && message.abilities.length) {
                object.abilities = [];
                for (var j = 0; j < message.abilities.length; ++j)
                    object.abilities[j] = $root.SC2APIProtocol.AvailableAbility.toObject(message.abilities[j], options);
            }
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (typeof message.unitTag === "number")
                    object.unitTag = options.longs === String ? String(message.unitTag) : message.unitTag;
                else
                    object.unitTag = options.longs === String ? $util.Long.prototype.toString.call(message.unitTag) : options.longs === Number ? new $util.LongBits(message.unitTag.low >>> 0, message.unitTag.high >>> 0).toNumber(true) : message.unitTag;
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                object.unitTypeId = message.unitTypeId;
            return object;
        };
        /**
         * Converts this ResponseQueryAvailableAbilities to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQueryAvailableAbilities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQueryAvailableAbilities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQueryAvailableAbilities;
    })();
    SC2APIProtocol.RequestQueryBuildingPlacement = (function () {
        /**
         * Properties of a RequestQueryBuildingPlacement.
         * @memberof SC2APIProtocol
         * @interface IRequestQueryBuildingPlacement
         * @property {number} [abilityId] RequestQueryBuildingPlacement abilityId
         * @property {SC2APIProtocol.IPoint2D} [targetPos] RequestQueryBuildingPlacement targetPos
         * @property {number|Long} [placingUnitTag] RequestQueryBuildingPlacement placingUnitTag
         */
        /**
         * Constructs a new RequestQueryBuildingPlacement.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQueryBuildingPlacement.
         * @constructor
         * @param {SC2APIProtocol.IRequestQueryBuildingPlacement=} [properties] Properties to set
         */
        function RequestQueryBuildingPlacement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestQueryBuildingPlacement abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @instance
         */
        RequestQueryBuildingPlacement.prototype.abilityId = 0;
        /**
         * RequestQueryBuildingPlacement targetPos.
         * @member {(SC2APIProtocol.IPoint2D|null|undefined)}targetPos
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @instance
         */
        RequestQueryBuildingPlacement.prototype.targetPos = null;
        /**
         * RequestQueryBuildingPlacement placingUnitTag.
         * @member {number|Long}placingUnitTag
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @instance
         */
        RequestQueryBuildingPlacement.prototype.placingUnitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new RequestQueryBuildingPlacement instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IRequestQueryBuildingPlacement=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQueryBuildingPlacement} RequestQueryBuildingPlacement instance
         */
        RequestQueryBuildingPlacement.create = function create(properties) {
            return new RequestQueryBuildingPlacement(properties);
        };
        /**
         * Encodes the specified RequestQueryBuildingPlacement message. Does not implicitly {@link SC2APIProtocol.RequestQueryBuildingPlacement.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IRequestQueryBuildingPlacement} message RequestQueryBuildingPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryBuildingPlacement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            if (message.targetPos != null && message.hasOwnProperty("targetPos"))
                $root.SC2APIProtocol.Point2D.encode(message.targetPos, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.placingUnitTag != null && message.hasOwnProperty("placingUnitTag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.placingUnitTag);
            return writer;
        };
        /**
         * Encodes the specified RequestQueryBuildingPlacement message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQueryBuildingPlacement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IRequestQueryBuildingPlacement} message RequestQueryBuildingPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQueryBuildingPlacement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQueryBuildingPlacement message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQueryBuildingPlacement} RequestQueryBuildingPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryBuildingPlacement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQueryBuildingPlacement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    case 2:
                        message.targetPos = $root.SC2APIProtocol.Point2D.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.placingUnitTag = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQueryBuildingPlacement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQueryBuildingPlacement} RequestQueryBuildingPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQueryBuildingPlacement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQueryBuildingPlacement message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQueryBuildingPlacement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.targetPos != null && message.hasOwnProperty("targetPos")) {
                var error = $root.SC2APIProtocol.Point2D.verify(message.targetPos);
                if (error)
                    return "targetPos." + error;
            }
            if (message.placingUnitTag != null && message.hasOwnProperty("placingUnitTag"))
                if (!$util.isInteger(message.placingUnitTag) && !(message.placingUnitTag && $util.isInteger(message.placingUnitTag.low) && $util.isInteger(message.placingUnitTag.high)))
                    return "placingUnitTag: integer|Long expected";
            return null;
        };
        /**
         * Creates a RequestQueryBuildingPlacement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQueryBuildingPlacement} RequestQueryBuildingPlacement
         */
        RequestQueryBuildingPlacement.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQueryBuildingPlacement)
                return object;
            var message = new $root.SC2APIProtocol.RequestQueryBuildingPlacement();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            if (object.targetPos != null) {
                if (typeof object.targetPos !== "object")
                    throw TypeError(".SC2APIProtocol.RequestQueryBuildingPlacement.targetPos: object expected");
                message.targetPos = $root.SC2APIProtocol.Point2D.fromObject(object.targetPos);
            }
            if (object.placingUnitTag != null)
                if ($util.Long)
                    (message.placingUnitTag = $util.Long.fromValue(object.placingUnitTag)).unsigned = true;
                else if (typeof object.placingUnitTag === "string")
                    message.placingUnitTag = parseInt(object.placingUnitTag, 10);
                else if (typeof object.placingUnitTag === "number")
                    message.placingUnitTag = object.placingUnitTag;
                else if (typeof object.placingUnitTag === "object")
                    message.placingUnitTag = new $util.LongBits(object.placingUnitTag.low >>> 0, object.placingUnitTag.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from a RequestQueryBuildingPlacement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.RequestQueryBuildingPlacement} message RequestQueryBuildingPlacement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQueryBuildingPlacement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = 0;
                object.targetPos = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.placingUnitTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.placingUnitTag = options.longs === String ? "0" : 0;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.targetPos != null && message.hasOwnProperty("targetPos"))
                object.targetPos = $root.SC2APIProtocol.Point2D.toObject(message.targetPos, options);
            if (message.placingUnitTag != null && message.hasOwnProperty("placingUnitTag"))
                if (typeof message.placingUnitTag === "number")
                    object.placingUnitTag = options.longs === String ? String(message.placingUnitTag) : message.placingUnitTag;
                else
                    object.placingUnitTag = options.longs === String ? $util.Long.prototype.toString.call(message.placingUnitTag) : options.longs === Number ? new $util.LongBits(message.placingUnitTag.low >>> 0, message.placingUnitTag.high >>> 0).toNumber(true) : message.placingUnitTag;
            return object;
        };
        /**
         * Converts this RequestQueryBuildingPlacement to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQueryBuildingPlacement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQueryBuildingPlacement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQueryBuildingPlacement;
    })();
    SC2APIProtocol.ResponseQueryBuildingPlacement = (function () {
        /**
         * Properties of a ResponseQueryBuildingPlacement.
         * @memberof SC2APIProtocol
         * @interface IResponseQueryBuildingPlacement
         * @property {SC2APIProtocol.ActionResult} [result] ResponseQueryBuildingPlacement result
         */
        /**
         * Constructs a new ResponseQueryBuildingPlacement.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQueryBuildingPlacement.
         * @constructor
         * @param {SC2APIProtocol.IResponseQueryBuildingPlacement=} [properties] Properties to set
         */
        function ResponseQueryBuildingPlacement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseQueryBuildingPlacement result.
         * @member {SC2APIProtocol.ActionResult}result
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @instance
         */
        ResponseQueryBuildingPlacement.prototype.result = 1;
        /**
         * Creates a new ResponseQueryBuildingPlacement instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IResponseQueryBuildingPlacement=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQueryBuildingPlacement} ResponseQueryBuildingPlacement instance
         */
        ResponseQueryBuildingPlacement.create = function create(properties) {
            return new ResponseQueryBuildingPlacement(properties);
        };
        /**
         * Encodes the specified ResponseQueryBuildingPlacement message. Does not implicitly {@link SC2APIProtocol.ResponseQueryBuildingPlacement.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IResponseQueryBuildingPlacement} message ResponseQueryBuildingPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryBuildingPlacement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result);
            return writer;
        };
        /**
         * Encodes the specified ResponseQueryBuildingPlacement message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQueryBuildingPlacement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.IResponseQueryBuildingPlacement} message ResponseQueryBuildingPlacement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQueryBuildingPlacement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQueryBuildingPlacement message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQueryBuildingPlacement} ResponseQueryBuildingPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryBuildingPlacement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQueryBuildingPlacement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQueryBuildingPlacement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQueryBuildingPlacement} ResponseQueryBuildingPlacement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQueryBuildingPlacement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQueryBuildingPlacement message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQueryBuildingPlacement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 86:
                    case 87:
                    case 88:
                    case 89:
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 122:
                    case 123:
                    case 124:
                    case 125:
                    case 126:
                    case 127:
                    case 128:
                    case 129:
                    case 130:
                    case 131:
                    case 132:
                    case 133:
                    case 134:
                    case 135:
                    case 136:
                    case 137:
                    case 138:
                    case 139:
                    case 140:
                    case 141:
                    case 142:
                    case 143:
                    case 144:
                    case 145:
                    case 146:
                    case 147:
                    case 148:
                    case 149:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                    case 164:
                    case 165:
                    case 166:
                    case 167:
                    case 168:
                    case 169:
                    case 170:
                    case 171:
                    case 172:
                    case 173:
                    case 174:
                    case 175:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 180:
                    case 181:
                    case 182:
                    case 183:
                    case 184:
                    case 185:
                    case 186:
                    case 187:
                    case 188:
                    case 189:
                    case 190:
                    case 191:
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 196:
                    case 197:
                    case 198:
                    case 199:
                    case 200:
                    case 201:
                    case 202:
                    case 203:
                    case 204:
                    case 205:
                    case 206:
                    case 207:
                    case 208:
                    case 209:
                    case 210:
                    case 211:
                    case 212:
                    case 213:
                    case 214:
                        break;
                }
            return null;
        };
        /**
         * Creates a ResponseQueryBuildingPlacement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQueryBuildingPlacement} ResponseQueryBuildingPlacement
         */
        ResponseQueryBuildingPlacement.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQueryBuildingPlacement)
                return object;
            var message = new $root.SC2APIProtocol.ResponseQueryBuildingPlacement();
            switch (object.result) {
                case "Success":
                case 1:
                    message.result = 1;
                    break;
                case "NotSupported":
                case 2:
                    message.result = 2;
                    break;
                case "Error":
                case 3:
                    message.result = 3;
                    break;
                case "CantQueueThatOrder":
                case 4:
                    message.result = 4;
                    break;
                case "Retry":
                case 5:
                    message.result = 5;
                    break;
                case "Cooldown":
                case 6:
                    message.result = 6;
                    break;
                case "QueueIsFull":
                case 7:
                    message.result = 7;
                    break;
                case "RallyQueueIsFull":
                case 8:
                    message.result = 8;
                    break;
                case "NotEnoughMinerals":
                case 9:
                    message.result = 9;
                    break;
                case "NotEnoughVespene":
                case 10:
                    message.result = 10;
                    break;
                case "NotEnoughTerrazine":
                case 11:
                    message.result = 11;
                    break;
                case "NotEnoughCustom":
                case 12:
                    message.result = 12;
                    break;
                case "NotEnoughFood":
                case 13:
                    message.result = 13;
                    break;
                case "FoodUsageImpossible":
                case 14:
                    message.result = 14;
                    break;
                case "NotEnoughLife":
                case 15:
                    message.result = 15;
                    break;
                case "NotEnoughShields":
                case 16:
                    message.result = 16;
                    break;
                case "NotEnoughEnergy":
                case 17:
                    message.result = 17;
                    break;
                case "LifeSuppressed":
                case 18:
                    message.result = 18;
                    break;
                case "ShieldsSuppressed":
                case 19:
                    message.result = 19;
                    break;
                case "EnergySuppressed":
                case 20:
                    message.result = 20;
                    break;
                case "NotEnoughCharges":
                case 21:
                    message.result = 21;
                    break;
                case "CantAddMoreCharges":
                case 22:
                    message.result = 22;
                    break;
                case "TooMuchMinerals":
                case 23:
                    message.result = 23;
                    break;
                case "TooMuchVespene":
                case 24:
                    message.result = 24;
                    break;
                case "TooMuchTerrazine":
                case 25:
                    message.result = 25;
                    break;
                case "TooMuchCustom":
                case 26:
                    message.result = 26;
                    break;
                case "TooMuchFood":
                case 27:
                    message.result = 27;
                    break;
                case "TooMuchLife":
                case 28:
                    message.result = 28;
                    break;
                case "TooMuchShields":
                case 29:
                    message.result = 29;
                    break;
                case "TooMuchEnergy":
                case 30:
                    message.result = 30;
                    break;
                case "MustTargetUnitWithLife":
                case 31:
                    message.result = 31;
                    break;
                case "MustTargetUnitWithShields":
                case 32:
                    message.result = 32;
                    break;
                case "MustTargetUnitWithEnergy":
                case 33:
                    message.result = 33;
                    break;
                case "CantTrade":
                case 34:
                    message.result = 34;
                    break;
                case "CantSpend":
                case 35:
                    message.result = 35;
                    break;
                case "CantTargetThatUnit":
                case 36:
                    message.result = 36;
                    break;
                case "CouldntAllocateUnit":
                case 37:
                    message.result = 37;
                    break;
                case "UnitCantMove":
                case 38:
                    message.result = 38;
                    break;
                case "TransportIsHoldingPosition":
                case 39:
                    message.result = 39;
                    break;
                case "BuildTechRequirementsNotMet":
                case 40:
                    message.result = 40;
                    break;
                case "CantFindPlacementLocation":
                case 41:
                    message.result = 41;
                    break;
                case "CantBuildOnThat":
                case 42:
                    message.result = 42;
                    break;
                case "CantBuildTooCloseToDropOff":
                case 43:
                    message.result = 43;
                    break;
                case "CantBuildLocationInvalid":
                case 44:
                    message.result = 44;
                    break;
                case "CantSeeBuildLocation":
                case 45:
                    message.result = 45;
                    break;
                case "CantBuildTooCloseToCreepSource":
                case 46:
                    message.result = 46;
                    break;
                case "CantBuildTooCloseToResources":
                case 47:
                    message.result = 47;
                    break;
                case "CantBuildTooFarFromWater":
                case 48:
                    message.result = 48;
                    break;
                case "CantBuildTooFarFromCreepSource":
                case 49:
                    message.result = 49;
                    break;
                case "CantBuildTooFarFromBuildPowerSource":
                case 50:
                    message.result = 50;
                    break;
                case "CantBuildOnDenseTerrain":
                case 51:
                    message.result = 51;
                    break;
                case "CantTrainTooFarFromTrainPowerSource":
                case 52:
                    message.result = 52;
                    break;
                case "CantLandLocationInvalid":
                case 53:
                    message.result = 53;
                    break;
                case "CantSeeLandLocation":
                case 54:
                    message.result = 54;
                    break;
                case "CantLandTooCloseToCreepSource":
                case 55:
                    message.result = 55;
                    break;
                case "CantLandTooCloseToResources":
                case 56:
                    message.result = 56;
                    break;
                case "CantLandTooFarFromWater":
                case 57:
                    message.result = 57;
                    break;
                case "CantLandTooFarFromCreepSource":
                case 58:
                    message.result = 58;
                    break;
                case "CantLandTooFarFromBuildPowerSource":
                case 59:
                    message.result = 59;
                    break;
                case "CantLandTooFarFromTrainPowerSource":
                case 60:
                    message.result = 60;
                    break;
                case "CantLandOnDenseTerrain":
                case 61:
                    message.result = 61;
                    break;
                case "AddOnTooFarFromBuilding":
                case 62:
                    message.result = 62;
                    break;
                case "MustBuildRefineryFirst":
                case 63:
                    message.result = 63;
                    break;
                case "BuildingIsUnderConstruction":
                case 64:
                    message.result = 64;
                    break;
                case "CantFindDropOff":
                case 65:
                    message.result = 65;
                    break;
                case "CantLoadOtherPlayersUnits":
                case 66:
                    message.result = 66;
                    break;
                case "NotEnoughRoomToLoadUnit":
                case 67:
                    message.result = 67;
                    break;
                case "CantUnloadUnitsThere":
                case 68:
                    message.result = 68;
                    break;
                case "CantWarpInUnitsThere":
                case 69:
                    message.result = 69;
                    break;
                case "CantLoadImmobileUnits":
                case 70:
                    message.result = 70;
                    break;
                case "CantRechargeImmobileUnits":
                case 71:
                    message.result = 71;
                    break;
                case "CantRechargeUnderConstructionUnits":
                case 72:
                    message.result = 72;
                    break;
                case "CantLoadThatUnit":
                case 73:
                    message.result = 73;
                    break;
                case "NoCargoToUnload":
                case 74:
                    message.result = 74;
                    break;
                case "LoadAllNoTargetsFound":
                case 75:
                    message.result = 75;
                    break;
                case "NotWhileOccupied":
                case 76:
                    message.result = 76;
                    break;
                case "CantAttackWithoutAmmo":
                case 77:
                    message.result = 77;
                    break;
                case "CantHoldAnyMoreAmmo":
                case 78:
                    message.result = 78;
                    break;
                case "TechRequirementsNotMet":
                case 79:
                    message.result = 79;
                    break;
                case "MustLockdownUnitFirst":
                case 80:
                    message.result = 80;
                    break;
                case "MustTargetUnit":
                case 81:
                    message.result = 81;
                    break;
                case "MustTargetInventory":
                case 82:
                    message.result = 82;
                    break;
                case "MustTargetVisibleUnit":
                case 83:
                    message.result = 83;
                    break;
                case "MustTargetVisibleLocation":
                case 84:
                    message.result = 84;
                    break;
                case "MustTargetWalkableLocation":
                case 85:
                    message.result = 85;
                    break;
                case "MustTargetPawnableUnit":
                case 86:
                    message.result = 86;
                    break;
                case "YouCantControlThatUnit":
                case 87:
                    message.result = 87;
                    break;
                case "YouCantIssueCommandsToThatUnit":
                case 88:
                    message.result = 88;
                    break;
                case "MustTargetResources":
                case 89:
                    message.result = 89;
                    break;
                case "RequiresHealTarget":
                case 90:
                    message.result = 90;
                    break;
                case "RequiresRepairTarget":
                case 91:
                    message.result = 91;
                    break;
                case "NoItemsToDrop":
                case 92:
                    message.result = 92;
                    break;
                case "CantHoldAnyMoreItems":
                case 93:
                    message.result = 93;
                    break;
                case "CantHoldThat":
                case 94:
                    message.result = 94;
                    break;
                case "TargetHasNoInventory":
                case 95:
                    message.result = 95;
                    break;
                case "CantDropThisItem":
                case 96:
                    message.result = 96;
                    break;
                case "CantMoveThisItem":
                case 97:
                    message.result = 97;
                    break;
                case "CantPawnThisUnit":
                case 98:
                    message.result = 98;
                    break;
                case "MustTargetCaster":
                case 99:
                    message.result = 99;
                    break;
                case "CantTargetCaster":
                case 100:
                    message.result = 100;
                    break;
                case "MustTargetOuter":
                case 101:
                    message.result = 101;
                    break;
                case "CantTargetOuter":
                case 102:
                    message.result = 102;
                    break;
                case "MustTargetYourOwnUnits":
                case 103:
                    message.result = 103;
                    break;
                case "CantTargetYourOwnUnits":
                case 104:
                    message.result = 104;
                    break;
                case "MustTargetFriendlyUnits":
                case 105:
                    message.result = 105;
                    break;
                case "CantTargetFriendlyUnits":
                case 106:
                    message.result = 106;
                    break;
                case "MustTargetNeutralUnits":
                case 107:
                    message.result = 107;
                    break;
                case "CantTargetNeutralUnits":
                case 108:
                    message.result = 108;
                    break;
                case "MustTargetEnemyUnits":
                case 109:
                    message.result = 109;
                    break;
                case "CantTargetEnemyUnits":
                case 110:
                    message.result = 110;
                    break;
                case "MustTargetAirUnits":
                case 111:
                    message.result = 111;
                    break;
                case "CantTargetAirUnits":
                case 112:
                    message.result = 112;
                    break;
                case "MustTargetGroundUnits":
                case 113:
                    message.result = 113;
                    break;
                case "CantTargetGroundUnits":
                case 114:
                    message.result = 114;
                    break;
                case "MustTargetStructures":
                case 115:
                    message.result = 115;
                    break;
                case "CantTargetStructures":
                case 116:
                    message.result = 116;
                    break;
                case "MustTargetLightUnits":
                case 117:
                    message.result = 117;
                    break;
                case "CantTargetLightUnits":
                case 118:
                    message.result = 118;
                    break;
                case "MustTargetArmoredUnits":
                case 119:
                    message.result = 119;
                    break;
                case "CantTargetArmoredUnits":
                case 120:
                    message.result = 120;
                    break;
                case "MustTargetBiologicalUnits":
                case 121:
                    message.result = 121;
                    break;
                case "CantTargetBiologicalUnits":
                case 122:
                    message.result = 122;
                    break;
                case "MustTargetHeroicUnits":
                case 123:
                    message.result = 123;
                    break;
                case "CantTargetHeroicUnits":
                case 124:
                    message.result = 124;
                    break;
                case "MustTargetRoboticUnits":
                case 125:
                    message.result = 125;
                    break;
                case "CantTargetRoboticUnits":
                case 126:
                    message.result = 126;
                    break;
                case "MustTargetMechanicalUnits":
                case 127:
                    message.result = 127;
                    break;
                case "CantTargetMechanicalUnits":
                case 128:
                    message.result = 128;
                    break;
                case "MustTargetPsionicUnits":
                case 129:
                    message.result = 129;
                    break;
                case "CantTargetPsionicUnits":
                case 130:
                    message.result = 130;
                    break;
                case "MustTargetMassiveUnits":
                case 131:
                    message.result = 131;
                    break;
                case "CantTargetMassiveUnits":
                case 132:
                    message.result = 132;
                    break;
                case "MustTargetMissile":
                case 133:
                    message.result = 133;
                    break;
                case "CantTargetMissile":
                case 134:
                    message.result = 134;
                    break;
                case "MustTargetWorkerUnits":
                case 135:
                    message.result = 135;
                    break;
                case "CantTargetWorkerUnits":
                case 136:
                    message.result = 136;
                    break;
                case "MustTargetEnergyCapableUnits":
                case 137:
                    message.result = 137;
                    break;
                case "CantTargetEnergyCapableUnits":
                case 138:
                    message.result = 138;
                    break;
                case "MustTargetShieldCapableUnits":
                case 139:
                    message.result = 139;
                    break;
                case "CantTargetShieldCapableUnits":
                case 140:
                    message.result = 140;
                    break;
                case "MustTargetFlyers":
                case 141:
                    message.result = 141;
                    break;
                case "CantTargetFlyers":
                case 142:
                    message.result = 142;
                    break;
                case "MustTargetBuriedUnits":
                case 143:
                    message.result = 143;
                    break;
                case "CantTargetBuriedUnits":
                case 144:
                    message.result = 144;
                    break;
                case "MustTargetCloakedUnits":
                case 145:
                    message.result = 145;
                    break;
                case "CantTargetCloakedUnits":
                case 146:
                    message.result = 146;
                    break;
                case "MustTargetUnitsInAStasisField":
                case 147:
                    message.result = 147;
                    break;
                case "CantTargetUnitsInAStasisField":
                case 148:
                    message.result = 148;
                    break;
                case "MustTargetUnderConstructionUnits":
                case 149:
                    message.result = 149;
                    break;
                case "CantTargetUnderConstructionUnits":
                case 150:
                    message.result = 150;
                    break;
                case "MustTargetDeadUnits":
                case 151:
                    message.result = 151;
                    break;
                case "CantTargetDeadUnits":
                case 152:
                    message.result = 152;
                    break;
                case "MustTargetRevivableUnits":
                case 153:
                    message.result = 153;
                    break;
                case "CantTargetRevivableUnits":
                case 154:
                    message.result = 154;
                    break;
                case "MustTargetHiddenUnits":
                case 155:
                    message.result = 155;
                    break;
                case "CantTargetHiddenUnits":
                case 156:
                    message.result = 156;
                    break;
                case "CantRechargeOtherPlayersUnits":
                case 157:
                    message.result = 157;
                    break;
                case "MustTargetHallucinations":
                case 158:
                    message.result = 158;
                    break;
                case "CantTargetHallucinations":
                case 159:
                    message.result = 159;
                    break;
                case "MustTargetInvulnerableUnits":
                case 160:
                    message.result = 160;
                    break;
                case "CantTargetInvulnerableUnits":
                case 161:
                    message.result = 161;
                    break;
                case "MustTargetDetectedUnits":
                case 162:
                    message.result = 162;
                    break;
                case "CantTargetDetectedUnits":
                case 163:
                    message.result = 163;
                    break;
                case "CantTargetUnitWithEnergy":
                case 164:
                    message.result = 164;
                    break;
                case "CantTargetUnitWithShields":
                case 165:
                    message.result = 165;
                    break;
                case "MustTargetUncommandableUnits":
                case 166:
                    message.result = 166;
                    break;
                case "CantTargetUncommandableUnits":
                case 167:
                    message.result = 167;
                    break;
                case "MustTargetPreventDefeatUnits":
                case 168:
                    message.result = 168;
                    break;
                case "CantTargetPreventDefeatUnits":
                case 169:
                    message.result = 169;
                    break;
                case "MustTargetPreventRevealUnits":
                case 170:
                    message.result = 170;
                    break;
                case "CantTargetPreventRevealUnits":
                case 171:
                    message.result = 171;
                    break;
                case "MustTargetPassiveUnits":
                case 172:
                    message.result = 172;
                    break;
                case "CantTargetPassiveUnits":
                case 173:
                    message.result = 173;
                    break;
                case "MustTargetStunnedUnits":
                case 174:
                    message.result = 174;
                    break;
                case "CantTargetStunnedUnits":
                case 175:
                    message.result = 175;
                    break;
                case "MustTargetSummonedUnits":
                case 176:
                    message.result = 176;
                    break;
                case "CantTargetSummonedUnits":
                case 177:
                    message.result = 177;
                    break;
                case "MustTargetUser1":
                case 178:
                    message.result = 178;
                    break;
                case "CantTargetUser1":
                case 179:
                    message.result = 179;
                    break;
                case "MustTargetUnstoppableUnits":
                case 180:
                    message.result = 180;
                    break;
                case "CantTargetUnstoppableUnits":
                case 181:
                    message.result = 181;
                    break;
                case "MustTargetResistantUnits":
                case 182:
                    message.result = 182;
                    break;
                case "CantTargetResistantUnits":
                case 183:
                    message.result = 183;
                    break;
                case "MustTargetDazedUnits":
                case 184:
                    message.result = 184;
                    break;
                case "CantTargetDazedUnits":
                case 185:
                    message.result = 185;
                    break;
                case "CantLockdown":
                case 186:
                    message.result = 186;
                    break;
                case "CantMindControl":
                case 187:
                    message.result = 187;
                    break;
                case "MustTargetDestructibles":
                case 188:
                    message.result = 188;
                    break;
                case "CantTargetDestructibles":
                case 189:
                    message.result = 189;
                    break;
                case "MustTargetItems":
                case 190:
                    message.result = 190;
                    break;
                case "CantTargetItems":
                case 191:
                    message.result = 191;
                    break;
                case "NoCalldownAvailable":
                case 192:
                    message.result = 192;
                    break;
                case "WaypointListFull":
                case 193:
                    message.result = 193;
                    break;
                case "MustTargetRace":
                case 194:
                    message.result = 194;
                    break;
                case "CantTargetRace":
                case 195:
                    message.result = 195;
                    break;
                case "MustTargetSimilarUnits":
                case 196:
                    message.result = 196;
                    break;
                case "CantTargetSimilarUnits":
                case 197:
                    message.result = 197;
                    break;
                case "CantFindEnoughTargets":
                case 198:
                    message.result = 198;
                    break;
                case "AlreadySpawningLarva":
                case 199:
                    message.result = 199;
                    break;
                case "CantTargetExhaustedResources":
                case 200:
                    message.result = 200;
                    break;
                case "CantUseMinimap":
                case 201:
                    message.result = 201;
                    break;
                case "CantUseInfoPanel":
                case 202:
                    message.result = 202;
                    break;
                case "OrderQueueIsFull":
                case 203:
                    message.result = 203;
                    break;
                case "CantHarvestThatResource":
                case 204:
                    message.result = 204;
                    break;
                case "HarvestersNotRequired":
                case 205:
                    message.result = 205;
                    break;
                case "AlreadyTargeted":
                case 206:
                    message.result = 206;
                    break;
                case "CantAttackWeaponsDisabled":
                case 207:
                    message.result = 207;
                    break;
                case "CouldntReachTarget":
                case 208:
                    message.result = 208;
                    break;
                case "TargetIsOutOfRange":
                case 209:
                    message.result = 209;
                    break;
                case "TargetIsTooClose":
                case 210:
                    message.result = 210;
                    break;
                case "TargetIsOutOfArc":
                case 211:
                    message.result = 211;
                    break;
                case "CantFindTeleportLocation":
                case 212:
                    message.result = 212;
                    break;
                case "InvalidItemClass":
                case 213:
                    message.result = 213;
                    break;
                case "CantFindCancelOrder":
                case 214:
                    message.result = 214;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseQueryBuildingPlacement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @static
         * @param {SC2APIProtocol.ResponseQueryBuildingPlacement} message ResponseQueryBuildingPlacement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQueryBuildingPlacement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Success" : 1;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.SC2APIProtocol.ActionResult[message.result] : message.result;
            return object;
        };
        /**
         * Converts this ResponseQueryBuildingPlacement to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQueryBuildingPlacement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQueryBuildingPlacement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQueryBuildingPlacement;
    })();
    SC2APIProtocol.StartRaw = (function () {
        /**
         * Properties of a StartRaw.
         * @memberof SC2APIProtocol
         * @interface IStartRaw
         * @property {SC2APIProtocol.ISize2DI} [mapSize] StartRaw mapSize
         * @property {SC2APIProtocol.IImageData} [pathingGrid] StartRaw pathingGrid
         * @property {SC2APIProtocol.IImageData} [terrainHeight] StartRaw terrainHeight
         * @property {SC2APIProtocol.IImageData} [placementGrid] StartRaw placementGrid
         * @property {SC2APIProtocol.IRectangleI} [playableArea] StartRaw playableArea
         * @property {Array.<SC2APIProtocol.IPoint2D>} [startLocations] StartRaw startLocations
         */
        /**
         * Constructs a new StartRaw.
         * @memberof SC2APIProtocol
         * @classdesc Represents a StartRaw.
         * @constructor
         * @param {SC2APIProtocol.IStartRaw=} [properties] Properties to set
         */
        function StartRaw(properties) {
            this.startLocations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * StartRaw mapSize.
         * @member {(SC2APIProtocol.ISize2DI|null|undefined)}mapSize
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.mapSize = null;
        /**
         * StartRaw pathingGrid.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}pathingGrid
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.pathingGrid = null;
        /**
         * StartRaw terrainHeight.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}terrainHeight
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.terrainHeight = null;
        /**
         * StartRaw placementGrid.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}placementGrid
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.placementGrid = null;
        /**
         * StartRaw playableArea.
         * @member {(SC2APIProtocol.IRectangleI|null|undefined)}playableArea
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.playableArea = null;
        /**
         * StartRaw startLocations.
         * @member {Array.<SC2APIProtocol.IPoint2D>}startLocations
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         */
        StartRaw.prototype.startLocations = $util.emptyArray;
        /**
         * Creates a new StartRaw instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {SC2APIProtocol.IStartRaw=} [properties] Properties to set
         * @returns {SC2APIProtocol.StartRaw} StartRaw instance
         */
        StartRaw.create = function create(properties) {
            return new StartRaw(properties);
        };
        /**
         * Encodes the specified StartRaw message. Does not implicitly {@link SC2APIProtocol.StartRaw.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {SC2APIProtocol.IStartRaw} message StartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapSize != null && message.hasOwnProperty("mapSize"))
                $root.SC2APIProtocol.Size2DI.encode(message.mapSize, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.pathingGrid != null && message.hasOwnProperty("pathingGrid"))
                $root.SC2APIProtocol.ImageData.encode(message.pathingGrid, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.terrainHeight != null && message.hasOwnProperty("terrainHeight"))
                $root.SC2APIProtocol.ImageData.encode(message.terrainHeight, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.placementGrid != null && message.hasOwnProperty("placementGrid"))
                $root.SC2APIProtocol.ImageData.encode(message.placementGrid, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.playableArea != null && message.hasOwnProperty("playableArea"))
                $root.SC2APIProtocol.RectangleI.encode(message.playableArea, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.startLocations != null && message.startLocations.length)
                for (var i = 0; i < message.startLocations.length; ++i)
                    $root.SC2APIProtocol.Point2D.encode(message.startLocations[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified StartRaw message, length delimited. Does not implicitly {@link SC2APIProtocol.StartRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {SC2APIProtocol.IStartRaw} message StartRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a StartRaw message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.StartRaw} StartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.StartRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapSize = $root.SC2APIProtocol.Size2DI.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.pathingGrid = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.terrainHeight = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.placementGrid = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.playableArea = $root.SC2APIProtocol.RectangleI.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.startLocations && message.startLocations.length))
                            message.startLocations = [];
                        message.startLocations.push($root.SC2APIProtocol.Point2D.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a StartRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.StartRaw} StartRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a StartRaw message.
         * @function verify
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapSize != null && message.hasOwnProperty("mapSize")) {
                var error = $root.SC2APIProtocol.Size2DI.verify(message.mapSize);
                if (error)
                    return "mapSize." + error;
            }
            if (message.pathingGrid != null && message.hasOwnProperty("pathingGrid")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.pathingGrid);
                if (error)
                    return "pathingGrid." + error;
            }
            if (message.terrainHeight != null && message.hasOwnProperty("terrainHeight")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.terrainHeight);
                if (error)
                    return "terrainHeight." + error;
            }
            if (message.placementGrid != null && message.hasOwnProperty("placementGrid")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.placementGrid);
                if (error)
                    return "placementGrid." + error;
            }
            if (message.playableArea != null && message.hasOwnProperty("playableArea")) {
                error = $root.SC2APIProtocol.RectangleI.verify(message.playableArea);
                if (error)
                    return "playableArea." + error;
            }
            if (message.startLocations != null && message.hasOwnProperty("startLocations")) {
                if (!Array.isArray(message.startLocations))
                    return "startLocations: array expected";
                for (var i = 0; i < message.startLocations.length; ++i) {
                    error = $root.SC2APIProtocol.Point2D.verify(message.startLocations[i]);
                    if (error)
                        return "startLocations." + error;
                }
            }
            return null;
        };
        /**
         * Creates a StartRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.StartRaw} StartRaw
         */
        StartRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.StartRaw)
                return object;
            var message = new $root.SC2APIProtocol.StartRaw();
            if (object.mapSize != null) {
                if (typeof object.mapSize !== "object")
                    throw TypeError(".SC2APIProtocol.StartRaw.mapSize: object expected");
                message.mapSize = $root.SC2APIProtocol.Size2DI.fromObject(object.mapSize);
            }
            if (object.pathingGrid != null) {
                if (typeof object.pathingGrid !== "object")
                    throw TypeError(".SC2APIProtocol.StartRaw.pathingGrid: object expected");
                message.pathingGrid = $root.SC2APIProtocol.ImageData.fromObject(object.pathingGrid);
            }
            if (object.terrainHeight != null) {
                if (typeof object.terrainHeight !== "object")
                    throw TypeError(".SC2APIProtocol.StartRaw.terrainHeight: object expected");
                message.terrainHeight = $root.SC2APIProtocol.ImageData.fromObject(object.terrainHeight);
            }
            if (object.placementGrid != null) {
                if (typeof object.placementGrid !== "object")
                    throw TypeError(".SC2APIProtocol.StartRaw.placementGrid: object expected");
                message.placementGrid = $root.SC2APIProtocol.ImageData.fromObject(object.placementGrid);
            }
            if (object.playableArea != null) {
                if (typeof object.playableArea !== "object")
                    throw TypeError(".SC2APIProtocol.StartRaw.playableArea: object expected");
                message.playableArea = $root.SC2APIProtocol.RectangleI.fromObject(object.playableArea);
            }
            if (object.startLocations) {
                if (!Array.isArray(object.startLocations))
                    throw TypeError(".SC2APIProtocol.StartRaw.startLocations: array expected");
                message.startLocations = [];
                for (var i = 0; i < object.startLocations.length; ++i) {
                    if (typeof object.startLocations[i] !== "object")
                        throw TypeError(".SC2APIProtocol.StartRaw.startLocations: object expected");
                    message.startLocations[i] = $root.SC2APIProtocol.Point2D.fromObject(object.startLocations[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a StartRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.StartRaw
         * @static
         * @param {SC2APIProtocol.StartRaw} message StartRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.startLocations = [];
            if (options.defaults) {
                object.mapSize = null;
                object.pathingGrid = null;
                object.terrainHeight = null;
                object.placementGrid = null;
                object.playableArea = null;
            }
            if (message.mapSize != null && message.hasOwnProperty("mapSize"))
                object.mapSize = $root.SC2APIProtocol.Size2DI.toObject(message.mapSize, options);
            if (message.pathingGrid != null && message.hasOwnProperty("pathingGrid"))
                object.pathingGrid = $root.SC2APIProtocol.ImageData.toObject(message.pathingGrid, options);
            if (message.terrainHeight != null && message.hasOwnProperty("terrainHeight"))
                object.terrainHeight = $root.SC2APIProtocol.ImageData.toObject(message.terrainHeight, options);
            if (message.placementGrid != null && message.hasOwnProperty("placementGrid"))
                object.placementGrid = $root.SC2APIProtocol.ImageData.toObject(message.placementGrid, options);
            if (message.playableArea != null && message.hasOwnProperty("playableArea"))
                object.playableArea = $root.SC2APIProtocol.RectangleI.toObject(message.playableArea, options);
            if (message.startLocations && message.startLocations.length) {
                object.startLocations = [];
                for (var j = 0; j < message.startLocations.length; ++j)
                    object.startLocations[j] = $root.SC2APIProtocol.Point2D.toObject(message.startLocations[j], options);
            }
            return object;
        };
        /**
         * Converts this StartRaw to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.StartRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return StartRaw;
    })();
    SC2APIProtocol.ObservationRaw = (function () {
        /**
         * Properties of an ObservationRaw.
         * @memberof SC2APIProtocol
         * @interface IObservationRaw
         * @property {SC2APIProtocol.IPlayerRaw} [player] ObservationRaw player
         * @property {Array.<SC2APIProtocol.IUnit>} [units] ObservationRaw units
         * @property {SC2APIProtocol.IMapState} [mapState] ObservationRaw mapState
         * @property {SC2APIProtocol.IEvent} [event] ObservationRaw event
         */
        /**
         * Constructs a new ObservationRaw.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ObservationRaw.
         * @constructor
         * @param {SC2APIProtocol.IObservationRaw=} [properties] Properties to set
         */
        function ObservationRaw(properties) {
            this.units = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ObservationRaw player.
         * @member {(SC2APIProtocol.IPlayerRaw|null|undefined)}player
         * @memberof SC2APIProtocol.ObservationRaw
         * @instance
         */
        ObservationRaw.prototype.player = null;
        /**
         * ObservationRaw units.
         * @member {Array.<SC2APIProtocol.IUnit>}units
         * @memberof SC2APIProtocol.ObservationRaw
         * @instance
         */
        ObservationRaw.prototype.units = $util.emptyArray;
        /**
         * ObservationRaw mapState.
         * @member {(SC2APIProtocol.IMapState|null|undefined)}mapState
         * @memberof SC2APIProtocol.ObservationRaw
         * @instance
         */
        ObservationRaw.prototype.mapState = null;
        /**
         * ObservationRaw event.
         * @member {(SC2APIProtocol.IEvent|null|undefined)}event
         * @memberof SC2APIProtocol.ObservationRaw
         * @instance
         */
        ObservationRaw.prototype.event = null;
        /**
         * Creates a new ObservationRaw instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {SC2APIProtocol.IObservationRaw=} [properties] Properties to set
         * @returns {SC2APIProtocol.ObservationRaw} ObservationRaw instance
         */
        ObservationRaw.create = function create(properties) {
            return new ObservationRaw(properties);
        };
        /**
         * Encodes the specified ObservationRaw message. Does not implicitly {@link SC2APIProtocol.ObservationRaw.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {SC2APIProtocol.IObservationRaw} message ObservationRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player != null && message.hasOwnProperty("player"))
                $root.SC2APIProtocol.PlayerRaw.encode(message.player, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    $root.SC2APIProtocol.Unit.encode(message.units[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.mapState != null && message.hasOwnProperty("mapState"))
                $root.SC2APIProtocol.MapState.encode(message.mapState, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.event != null && message.hasOwnProperty("event"))
                $root.SC2APIProtocol.Event.encode(message.event, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ObservationRaw message, length delimited. Does not implicitly {@link SC2APIProtocol.ObservationRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {SC2APIProtocol.IObservationRaw} message ObservationRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ObservationRaw message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ObservationRaw} ObservationRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ObservationRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.player = $root.SC2APIProtocol.PlayerRaw.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.units && message.units.length))
                            message.units = [];
                        message.units.push($root.SC2APIProtocol.Unit.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.mapState = $root.SC2APIProtocol.MapState.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.event = $root.SC2APIProtocol.Event.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ObservationRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ObservationRaw} ObservationRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ObservationRaw message.
         * @function verify
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ObservationRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player != null && message.hasOwnProperty("player")) {
                var error = $root.SC2APIProtocol.PlayerRaw.verify(message.player);
                if (error)
                    return "player." + error;
            }
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i) {
                    error = $root.SC2APIProtocol.Unit.verify(message.units[i]);
                    if (error)
                        return "units." + error;
                }
            }
            if (message.mapState != null && message.hasOwnProperty("mapState")) {
                error = $root.SC2APIProtocol.MapState.verify(message.mapState);
                if (error)
                    return "mapState." + error;
            }
            if (message.event != null && message.hasOwnProperty("event")) {
                error = $root.SC2APIProtocol.Event.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };
        /**
         * Creates an ObservationRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ObservationRaw} ObservationRaw
         */
        ObservationRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ObservationRaw)
                return object;
            var message = new $root.SC2APIProtocol.ObservationRaw();
            if (object.player != null) {
                if (typeof object.player !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationRaw.player: object expected");
                message.player = $root.SC2APIProtocol.PlayerRaw.fromObject(object.player);
            }
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".SC2APIProtocol.ObservationRaw.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i) {
                    if (typeof object.units[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ObservationRaw.units: object expected");
                    message.units[i] = $root.SC2APIProtocol.Unit.fromObject(object.units[i]);
                }
            }
            if (object.mapState != null) {
                if (typeof object.mapState !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationRaw.mapState: object expected");
                message.mapState = $root.SC2APIProtocol.MapState.fromObject(object.mapState);
            }
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationRaw.event: object expected");
                message.event = $root.SC2APIProtocol.Event.fromObject(object.event);
            }
            return message;
        };
        /**
         * Creates a plain object from an ObservationRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ObservationRaw
         * @static
         * @param {SC2APIProtocol.ObservationRaw} message ObservationRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ObservationRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.units = [];
            if (options.defaults) {
                object.player = null;
                object.mapState = null;
                object.event = null;
            }
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = $root.SC2APIProtocol.PlayerRaw.toObject(message.player, options);
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = $root.SC2APIProtocol.Unit.toObject(message.units[j], options);
            }
            if (message.mapState != null && message.hasOwnProperty("mapState"))
                object.mapState = $root.SC2APIProtocol.MapState.toObject(message.mapState, options);
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.SC2APIProtocol.Event.toObject(message.event, options);
            return object;
        };
        /**
         * Converts this ObservationRaw to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ObservationRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ObservationRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ObservationRaw;
    })();
    SC2APIProtocol.PowerSource = (function () {
        /**
         * Properties of a PowerSource.
         * @memberof SC2APIProtocol
         * @interface IPowerSource
         * @property {SC2APIProtocol.IPoint} [pos] PowerSource pos
         * @property {number} [radius] PowerSource radius
         * @property {number|Long} [tag] PowerSource tag
         */
        /**
         * Constructs a new PowerSource.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PowerSource.
         * @constructor
         * @param {SC2APIProtocol.IPowerSource=} [properties] Properties to set
         */
        function PowerSource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PowerSource pos.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}pos
         * @memberof SC2APIProtocol.PowerSource
         * @instance
         */
        PowerSource.prototype.pos = null;
        /**
         * PowerSource radius.
         * @member {number}radius
         * @memberof SC2APIProtocol.PowerSource
         * @instance
         */
        PowerSource.prototype.radius = 0;
        /**
         * PowerSource tag.
         * @member {number|Long}tag
         * @memberof SC2APIProtocol.PowerSource
         * @instance
         */
        PowerSource.prototype.tag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new PowerSource instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {SC2APIProtocol.IPowerSource=} [properties] Properties to set
         * @returns {SC2APIProtocol.PowerSource} PowerSource instance
         */
        PowerSource.create = function create(properties) {
            return new PowerSource(properties);
        };
        /**
         * Encodes the specified PowerSource message. Does not implicitly {@link SC2APIProtocol.PowerSource.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {SC2APIProtocol.IPowerSource} message PowerSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PowerSource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.SC2APIProtocol.Point.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.radius != null && message.hasOwnProperty("radius"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.radius);
            if (message.tag != null && message.hasOwnProperty("tag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.tag);
            return writer;
        };
        /**
         * Encodes the specified PowerSource message, length delimited. Does not implicitly {@link SC2APIProtocol.PowerSource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {SC2APIProtocol.IPowerSource} message PowerSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PowerSource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PowerSource message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PowerSource} PowerSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PowerSource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PowerSource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.pos = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.radius = reader.float();
                        break;
                    case 3:
                        message.tag = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PowerSource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PowerSource} PowerSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PowerSource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PowerSource message.
         * @function verify
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PowerSource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.SC2APIProtocol.Point.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag) && !(message.tag && $util.isInteger(message.tag.low) && $util.isInteger(message.tag.high)))
                    return "tag: integer|Long expected";
            return null;
        };
        /**
         * Creates a PowerSource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PowerSource} PowerSource
         */
        PowerSource.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PowerSource)
                return object;
            var message = new $root.SC2APIProtocol.PowerSource();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".SC2APIProtocol.PowerSource.pos: object expected");
                message.pos = $root.SC2APIProtocol.Point.fromObject(object.pos);
            }
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.tag != null)
                if ($util.Long)
                    (message.tag = $util.Long.fromValue(object.tag)).unsigned = true;
                else if (typeof object.tag === "string")
                    message.tag = parseInt(object.tag, 10);
                else if (typeof object.tag === "number")
                    message.tag = object.tag;
                else if (typeof object.tag === "object")
                    message.tag = new $util.LongBits(object.tag.low >>> 0, object.tag.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from a PowerSource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PowerSource
         * @static
         * @param {SC2APIProtocol.PowerSource} message PowerSource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PowerSource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.radius = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.tag = options.longs === String ? "0" : 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.SC2APIProtocol.Point.toObject(message.pos, options);
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (typeof message.tag === "number")
                    object.tag = options.longs === String ? String(message.tag) : message.tag;
                else
                    object.tag = options.longs === String ? $util.Long.prototype.toString.call(message.tag) : options.longs === Number ? new $util.LongBits(message.tag.low >>> 0, message.tag.high >>> 0).toNumber(true) : message.tag;
            return object;
        };
        /**
         * Converts this PowerSource to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PowerSource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PowerSource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PowerSource;
    })();
    SC2APIProtocol.PlayerRaw = (function () {
        /**
         * Properties of a PlayerRaw.
         * @memberof SC2APIProtocol
         * @interface IPlayerRaw
         * @property {Array.<SC2APIProtocol.IPowerSource>} [powerSources] PlayerRaw powerSources
         * @property {SC2APIProtocol.IPoint} [camera] PlayerRaw camera
         * @property {Array.<number>} [upgradeIds] PlayerRaw upgradeIds
         */
        /**
         * Constructs a new PlayerRaw.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerRaw.
         * @constructor
         * @param {SC2APIProtocol.IPlayerRaw=} [properties] Properties to set
         */
        function PlayerRaw(properties) {
            this.powerSources = [];
            this.upgradeIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerRaw powerSources.
         * @member {Array.<SC2APIProtocol.IPowerSource>}powerSources
         * @memberof SC2APIProtocol.PlayerRaw
         * @instance
         */
        PlayerRaw.prototype.powerSources = $util.emptyArray;
        /**
         * PlayerRaw camera.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}camera
         * @memberof SC2APIProtocol.PlayerRaw
         * @instance
         */
        PlayerRaw.prototype.camera = null;
        /**
         * PlayerRaw upgradeIds.
         * @member {Array.<number>}upgradeIds
         * @memberof SC2APIProtocol.PlayerRaw
         * @instance
         */
        PlayerRaw.prototype.upgradeIds = $util.emptyArray;
        /**
         * Creates a new PlayerRaw instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {SC2APIProtocol.IPlayerRaw=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerRaw} PlayerRaw instance
         */
        PlayerRaw.create = function create(properties) {
            return new PlayerRaw(properties);
        };
        /**
         * Encodes the specified PlayerRaw message. Does not implicitly {@link SC2APIProtocol.PlayerRaw.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {SC2APIProtocol.IPlayerRaw} message PlayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.powerSources != null && message.powerSources.length)
                for (var i = 0; i < message.powerSources.length; ++i)
                    $root.SC2APIProtocol.PowerSource.encode(message.powerSources[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.camera != null && message.hasOwnProperty("camera"))
                $root.SC2APIProtocol.Point.encode(message.camera, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.upgradeIds != null && message.upgradeIds.length)
                for (var i = 0; i < message.upgradeIds.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.upgradeIds[i]);
            return writer;
        };
        /**
         * Encodes the specified PlayerRaw message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {SC2APIProtocol.IPlayerRaw} message PlayerRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerRaw message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerRaw} PlayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.powerSources && message.powerSources.length))
                            message.powerSources = [];
                        message.powerSources.push($root.SC2APIProtocol.PowerSource.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.camera = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.upgradeIds && message.upgradeIds.length))
                            message.upgradeIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.upgradeIds.push(reader.uint32());
                        }
                        else
                            message.upgradeIds.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerRaw} PlayerRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerRaw message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.powerSources != null && message.hasOwnProperty("powerSources")) {
                if (!Array.isArray(message.powerSources))
                    return "powerSources: array expected";
                for (var i = 0; i < message.powerSources.length; ++i) {
                    var error = $root.SC2APIProtocol.PowerSource.verify(message.powerSources[i]);
                    if (error)
                        return "powerSources." + error;
                }
            }
            if (message.camera != null && message.hasOwnProperty("camera")) {
                error = $root.SC2APIProtocol.Point.verify(message.camera);
                if (error)
                    return "camera." + error;
            }
            if (message.upgradeIds != null && message.hasOwnProperty("upgradeIds")) {
                if (!Array.isArray(message.upgradeIds))
                    return "upgradeIds: array expected";
                for (var i = 0; i < message.upgradeIds.length; ++i)
                    if (!$util.isInteger(message.upgradeIds[i]))
                        return "upgradeIds: integer[] expected";
            }
            return null;
        };
        /**
         * Creates a PlayerRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerRaw} PlayerRaw
         */
        PlayerRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerRaw)
                return object;
            var message = new $root.SC2APIProtocol.PlayerRaw();
            if (object.powerSources) {
                if (!Array.isArray(object.powerSources))
                    throw TypeError(".SC2APIProtocol.PlayerRaw.powerSources: array expected");
                message.powerSources = [];
                for (var i = 0; i < object.powerSources.length; ++i) {
                    if (typeof object.powerSources[i] !== "object")
                        throw TypeError(".SC2APIProtocol.PlayerRaw.powerSources: object expected");
                    message.powerSources[i] = $root.SC2APIProtocol.PowerSource.fromObject(object.powerSources[i]);
                }
            }
            if (object.camera != null) {
                if (typeof object.camera !== "object")
                    throw TypeError(".SC2APIProtocol.PlayerRaw.camera: object expected");
                message.camera = $root.SC2APIProtocol.Point.fromObject(object.camera);
            }
            if (object.upgradeIds) {
                if (!Array.isArray(object.upgradeIds))
                    throw TypeError(".SC2APIProtocol.PlayerRaw.upgradeIds: array expected");
                message.upgradeIds = [];
                for (var i = 0; i < object.upgradeIds.length; ++i)
                    message.upgradeIds[i] = object.upgradeIds[i] >>> 0;
            }
            return message;
        };
        /**
         * Creates a plain object from a PlayerRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerRaw
         * @static
         * @param {SC2APIProtocol.PlayerRaw} message PlayerRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.powerSources = [];
                object.upgradeIds = [];
            }
            if (options.defaults)
                object.camera = null;
            if (message.powerSources && message.powerSources.length) {
                object.powerSources = [];
                for (var j = 0; j < message.powerSources.length; ++j)
                    object.powerSources[j] = $root.SC2APIProtocol.PowerSource.toObject(message.powerSources[j], options);
            }
            if (message.camera != null && message.hasOwnProperty("camera"))
                object.camera = $root.SC2APIProtocol.Point.toObject(message.camera, options);
            if (message.upgradeIds && message.upgradeIds.length) {
                object.upgradeIds = [];
                for (var j = 0; j < message.upgradeIds.length; ++j)
                    object.upgradeIds[j] = message.upgradeIds[j];
            }
            return object;
        };
        /**
         * Converts this PlayerRaw to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerRaw;
    })();
    SC2APIProtocol.UnitOrder = (function () {
        /**
         * Properties of an UnitOrder.
         * @memberof SC2APIProtocol
         * @interface IUnitOrder
         * @property {number} [abilityId] UnitOrder abilityId
         * @property {SC2APIProtocol.IPoint} [targetWorldSpacePos] UnitOrder targetWorldSpacePos
         * @property {number|Long} [targetUnitTag] UnitOrder targetUnitTag
         * @property {number} [progress] UnitOrder progress
         */
        /**
         * Constructs a new UnitOrder.
         * @memberof SC2APIProtocol
         * @classdesc Represents an UnitOrder.
         * @constructor
         * @param {SC2APIProtocol.IUnitOrder=} [properties] Properties to set
         */
        function UnitOrder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UnitOrder abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         */
        UnitOrder.prototype.abilityId = 0;
        /**
         * UnitOrder targetWorldSpacePos.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}targetWorldSpacePos
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         */
        UnitOrder.prototype.targetWorldSpacePos = null;
        /**
         * UnitOrder targetUnitTag.
         * @member {number|Long}targetUnitTag
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         */
        UnitOrder.prototype.targetUnitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * UnitOrder progress.
         * @member {number}progress
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         */
        UnitOrder.prototype.progress = 0;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * UnitOrder target.
         * @member {string|undefined} target
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         */
        Object.defineProperty(UnitOrder.prototype, "target", {
            get: $util.oneOfGetter($oneOfFields = ["targetWorldSpacePos", "targetUnitTag"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new UnitOrder instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {SC2APIProtocol.IUnitOrder=} [properties] Properties to set
         * @returns {SC2APIProtocol.UnitOrder} UnitOrder instance
         */
        UnitOrder.create = function create(properties) {
            return new UnitOrder(properties);
        };
        /**
         * Encodes the specified UnitOrder message. Does not implicitly {@link SC2APIProtocol.UnitOrder.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {SC2APIProtocol.IUnitOrder} message UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.abilityId);
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos"))
                $root.SC2APIProtocol.Point.encode(message.targetWorldSpacePos, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.targetUnitTag);
            if (message.progress != null && message.hasOwnProperty("progress"))
                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.progress);
            return writer;
        };
        /**
         * Encodes the specified UnitOrder message, length delimited. Does not implicitly {@link SC2APIProtocol.UnitOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {SC2APIProtocol.IUnitOrder} message UnitOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UnitOrder message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.UnitOrder} UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.UnitOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.uint32();
                        break;
                    case 2:
                        message.targetWorldSpacePos = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.targetUnitTag = reader.uint64();
                        break;
                    case 4:
                        message.progress = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UnitOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.UnitOrder} UnitOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UnitOrder message.
         * @function verify
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos")) {
                properties.target = 1;
                var error = $root.SC2APIProtocol.Point.verify(message.targetWorldSpacePos);
                if (error)
                    return "targetWorldSpacePos." + error;
            }
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag")) {
                if (properties.target === 1)
                    return "target: multiple values";
                properties.target = 1;
                if (!$util.isInteger(message.targetUnitTag) && !(message.targetUnitTag && $util.isInteger(message.targetUnitTag.low) && $util.isInteger(message.targetUnitTag.high)))
                    return "targetUnitTag: integer|Long expected";
            }
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (typeof message.progress !== "number")
                    return "progress: number expected";
            return null;
        };
        /**
         * Creates an UnitOrder message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.UnitOrder} UnitOrder
         */
        UnitOrder.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.UnitOrder)
                return object;
            var message = new $root.SC2APIProtocol.UnitOrder();
            if (object.abilityId != null)
                message.abilityId = object.abilityId >>> 0;
            if (object.targetWorldSpacePos != null) {
                if (typeof object.targetWorldSpacePos !== "object")
                    throw TypeError(".SC2APIProtocol.UnitOrder.targetWorldSpacePos: object expected");
                message.targetWorldSpacePos = $root.SC2APIProtocol.Point.fromObject(object.targetWorldSpacePos);
            }
            if (object.targetUnitTag != null)
                if ($util.Long)
                    (message.targetUnitTag = $util.Long.fromValue(object.targetUnitTag)).unsigned = true;
                else if (typeof object.targetUnitTag === "string")
                    message.targetUnitTag = parseInt(object.targetUnitTag, 10);
                else if (typeof object.targetUnitTag === "number")
                    message.targetUnitTag = object.targetUnitTag;
                else if (typeof object.targetUnitTag === "object")
                    message.targetUnitTag = new $util.LongBits(object.targetUnitTag.low >>> 0, object.targetUnitTag.high >>> 0).toNumber(true);
            if (object.progress != null)
                message.progress = Number(object.progress);
            return message;
        };
        /**
         * Creates a plain object from an UnitOrder message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.UnitOrder
         * @static
         * @param {SC2APIProtocol.UnitOrder} message UnitOrder
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitOrder.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = 0;
                object.progress = 0;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos")) {
                object.targetWorldSpacePos = $root.SC2APIProtocol.Point.toObject(message.targetWorldSpacePos, options);
                if (options.oneofs)
                    object.target = "targetWorldSpacePos";
            }
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag")) {
                if (typeof message.targetUnitTag === "number")
                    object.targetUnitTag = options.longs === String ? String(message.targetUnitTag) : message.targetUnitTag;
                else
                    object.targetUnitTag = options.longs === String ? $util.Long.prototype.toString.call(message.targetUnitTag) : options.longs === Number ? new $util.LongBits(message.targetUnitTag.low >>> 0, message.targetUnitTag.high >>> 0).toNumber(true) : message.targetUnitTag;
                if (options.oneofs)
                    object.target = "targetUnitTag";
            }
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
            return object;
        };
        /**
         * Converts this UnitOrder to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.UnitOrder
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitOrder.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnitOrder;
    })();
    /**
     * DisplayType enum.
     * @enum {string}
     * @property {number} Visible=1 Visible value
     * @property {number} Snapshot=2 Snapshot value
     * @property {number} Hidden=3 Hidden value
     */
    SC2APIProtocol.DisplayType = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Visible"] = 1;
        values[valuesById[2] = "Snapshot"] = 2;
        values[valuesById[3] = "Hidden"] = 3;
        return values;
    })();
    /**
     * Alliance enum.
     * @enum {string}
     * @property {number} Self=1 Self value
     * @property {number} Ally=2 Ally value
     * @property {number} Neutral=3 Neutral value
     * @property {number} Enemy=4 Enemy value
     */
    SC2APIProtocol.Alliance = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Self"] = 1;
        values[valuesById[2] = "Ally"] = 2;
        values[valuesById[3] = "Neutral"] = 3;
        values[valuesById[4] = "Enemy"] = 4;
        return values;
    })();
    /**
     * CloakState enum.
     * @enum {string}
     * @property {number} Cloaked=1 Cloaked value
     * @property {number} CloakedDetected=2 CloakedDetected value
     * @property {number} NotCloaked=3 NotCloaked value
     */
    SC2APIProtocol.CloakState = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Cloaked"] = 1;
        values[valuesById[2] = "CloakedDetected"] = 2;
        values[valuesById[3] = "NotCloaked"] = 3;
        return values;
    })();
    SC2APIProtocol.PassengerUnit = (function () {
        /**
         * Properties of a PassengerUnit.
         * @memberof SC2APIProtocol
         * @interface IPassengerUnit
         * @property {number|Long} [tag] PassengerUnit tag
         * @property {number} [health] PassengerUnit health
         * @property {number} [healthMax] PassengerUnit healthMax
         * @property {number} [shield] PassengerUnit shield
         * @property {number} [energy] PassengerUnit energy
         * @property {number} [unitType] PassengerUnit unitType
         */
        /**
         * Constructs a new PassengerUnit.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PassengerUnit.
         * @constructor
         * @param {SC2APIProtocol.IPassengerUnit=} [properties] Properties to set
         */
        function PassengerUnit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PassengerUnit tag.
         * @member {number|Long}tag
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.tag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * PassengerUnit health.
         * @member {number}health
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.health = 0;
        /**
         * PassengerUnit healthMax.
         * @member {number}healthMax
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.healthMax = 0;
        /**
         * PassengerUnit shield.
         * @member {number}shield
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.shield = 0;
        /**
         * PassengerUnit energy.
         * @member {number}energy
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.energy = 0;
        /**
         * PassengerUnit unitType.
         * @member {number}unitType
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         */
        PassengerUnit.prototype.unitType = 0;
        /**
         * Creates a new PassengerUnit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {SC2APIProtocol.IPassengerUnit=} [properties] Properties to set
         * @returns {SC2APIProtocol.PassengerUnit} PassengerUnit instance
         */
        PassengerUnit.create = function create(properties) {
            return new PassengerUnit(properties);
        };
        /**
         * Encodes the specified PassengerUnit message. Does not implicitly {@link SC2APIProtocol.PassengerUnit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {SC2APIProtocol.IPassengerUnit} message PassengerUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassengerUnit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tag != null && message.hasOwnProperty("tag"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.tag);
            if (message.health != null && message.hasOwnProperty("health"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.health);
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.healthMax);
            if (message.shield != null && message.hasOwnProperty("shield"))
                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.shield);
            if (message.energy != null && message.hasOwnProperty("energy"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.energy);
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).uint32(message.unitType);
            return writer;
        };
        /**
         * Encodes the specified PassengerUnit message, length delimited. Does not implicitly {@link SC2APIProtocol.PassengerUnit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {SC2APIProtocol.IPassengerUnit} message PassengerUnit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassengerUnit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PassengerUnit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PassengerUnit} PassengerUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassengerUnit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PassengerUnit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.tag = reader.uint64();
                        break;
                    case 2:
                        message.health = reader.float();
                        break;
                    case 3:
                        message.healthMax = reader.float();
                        break;
                    case 4:
                        message.shield = reader.float();
                        break;
                    case 5:
                        message.energy = reader.float();
                        break;
                    case 6:
                        message.unitType = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PassengerUnit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PassengerUnit} PassengerUnit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassengerUnit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PassengerUnit message.
         * @function verify
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PassengerUnit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag) && !(message.tag && $util.isInteger(message.tag.low) && $util.isInteger(message.tag.high)))
                    return "tag: integer|Long expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (typeof message.health !== "number")
                    return "health: number expected";
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                if (typeof message.healthMax !== "number")
                    return "healthMax: number expected";
            if (message.shield != null && message.hasOwnProperty("shield"))
                if (typeof message.shield !== "number")
                    return "shield: number expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (typeof message.energy !== "number")
                    return "energy: number expected";
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                if (!$util.isInteger(message.unitType))
                    return "unitType: integer expected";
            return null;
        };
        /**
         * Creates a PassengerUnit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PassengerUnit} PassengerUnit
         */
        PassengerUnit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PassengerUnit)
                return object;
            var message = new $root.SC2APIProtocol.PassengerUnit();
            if (object.tag != null)
                if ($util.Long)
                    (message.tag = $util.Long.fromValue(object.tag)).unsigned = true;
                else if (typeof object.tag === "string")
                    message.tag = parseInt(object.tag, 10);
                else if (typeof object.tag === "number")
                    message.tag = object.tag;
                else if (typeof object.tag === "object")
                    message.tag = new $util.LongBits(object.tag.low >>> 0, object.tag.high >>> 0).toNumber(true);
            if (object.health != null)
                message.health = Number(object.health);
            if (object.healthMax != null)
                message.healthMax = Number(object.healthMax);
            if (object.shield != null)
                message.shield = Number(object.shield);
            if (object.energy != null)
                message.energy = Number(object.energy);
            if (object.unitType != null)
                message.unitType = object.unitType >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a PassengerUnit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PassengerUnit
         * @static
         * @param {SC2APIProtocol.PassengerUnit} message PassengerUnit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PassengerUnit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.tag = options.longs === String ? "0" : 0;
                object.health = 0;
                object.healthMax = 0;
                object.shield = 0;
                object.energy = 0;
                object.unitType = 0;
            }
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (typeof message.tag === "number")
                    object.tag = options.longs === String ? String(message.tag) : message.tag;
                else
                    object.tag = options.longs === String ? $util.Long.prototype.toString.call(message.tag) : options.longs === Number ? new $util.LongBits(message.tag.low >>> 0, message.tag.high >>> 0).toNumber(true) : message.tag;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = options.json && !isFinite(message.health) ? String(message.health) : message.health;
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                object.healthMax = options.json && !isFinite(message.healthMax) ? String(message.healthMax) : message.healthMax;
            if (message.shield != null && message.hasOwnProperty("shield"))
                object.shield = options.json && !isFinite(message.shield) ? String(message.shield) : message.shield;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = options.json && !isFinite(message.energy) ? String(message.energy) : message.energy;
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = message.unitType;
            return object;
        };
        /**
         * Converts this PassengerUnit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PassengerUnit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PassengerUnit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PassengerUnit;
    })();
    SC2APIProtocol.Unit = (function () {
        /**
         * Properties of an Unit.
         * @memberof SC2APIProtocol
         * @interface IUnit
         * @property {SC2APIProtocol.DisplayType} [displayType] Unit displayType
         * @property {SC2APIProtocol.Alliance} [alliance] Unit alliance
         * @property {number|Long} [tag] Unit tag
         * @property {number} [unitType] Unit unitType
         * @property {number} [owner] Unit owner
         * @property {SC2APIProtocol.IPoint} [pos] Unit pos
         * @property {number} [facing] Unit facing
         * @property {number} [radius] Unit radius
         * @property {number} [buildProgress] Unit buildProgress
         * @property {SC2APIProtocol.CloakState} [cloak] Unit cloak
         * @property {number} [detectRange] Unit detectRange
         * @property {number} [radarRange] Unit radarRange
         * @property {boolean} [isSelected] Unit isSelected
         * @property {boolean} [isOnScreen] Unit isOnScreen
         * @property {boolean} [isBlip] Unit isBlip
         * @property {boolean} [isPowered] Unit isPowered
         * @property {number} [health] Unit health
         * @property {number} [healthMax] Unit healthMax
         * @property {number} [shield] Unit shield
         * @property {number} [energy] Unit energy
         * @property {number} [mineralContents] Unit mineralContents
         * @property {number} [vespeneContents] Unit vespeneContents
         * @property {boolean} [isFlying] Unit isFlying
         * @property {boolean} [isBurrowed] Unit isBurrowed
         * @property {Array.<SC2APIProtocol.IUnitOrder>} [orders] Unit orders
         * @property {number|Long} [addOnTag] Unit addOnTag
         * @property {Array.<SC2APIProtocol.IPassengerUnit>} [passengers] Unit passengers
         * @property {number} [cargoSpaceTaken] Unit cargoSpaceTaken
         * @property {number} [cargoSpaceMax] Unit cargoSpaceMax
         * @property {Array.<number>} [buffIds] Unit buffIds
         * @property {number} [assignedHarvesters] Unit assignedHarvesters
         * @property {number} [idealHarvesters] Unit idealHarvesters
         * @property {number} [weaponCooldown] Unit weaponCooldown
         * @property {number|Long} [engagedTargetTag] Unit engagedTargetTag
         */
        /**
         * Constructs a new Unit.
         * @memberof SC2APIProtocol
         * @classdesc Represents an Unit.
         * @constructor
         * @param {SC2APIProtocol.IUnit=} [properties] Properties to set
         */
        function Unit(properties) {
            this.orders = [];
            this.passengers = [];
            this.buffIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Unit displayType.
         * @member {SC2APIProtocol.DisplayType}displayType
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.displayType = 1;
        /**
         * Unit alliance.
         * @member {SC2APIProtocol.Alliance}alliance
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.alliance = 1;
        /**
         * Unit tag.
         * @member {number|Long}tag
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.tag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Unit unitType.
         * @member {number}unitType
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.unitType = 0;
        /**
         * Unit owner.
         * @member {number}owner
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.owner = 0;
        /**
         * Unit pos.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}pos
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.pos = null;
        /**
         * Unit facing.
         * @member {number}facing
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.facing = 0;
        /**
         * Unit radius.
         * @member {number}radius
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.radius = 0;
        /**
         * Unit buildProgress.
         * @member {number}buildProgress
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.buildProgress = 0;
        /**
         * Unit cloak.
         * @member {SC2APIProtocol.CloakState}cloak
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.cloak = 1;
        /**
         * Unit detectRange.
         * @member {number}detectRange
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.detectRange = 0;
        /**
         * Unit radarRange.
         * @member {number}radarRange
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.radarRange = 0;
        /**
         * Unit isSelected.
         * @member {boolean}isSelected
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isSelected = false;
        /**
         * Unit isOnScreen.
         * @member {boolean}isOnScreen
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isOnScreen = false;
        /**
         * Unit isBlip.
         * @member {boolean}isBlip
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isBlip = false;
        /**
         * Unit isPowered.
         * @member {boolean}isPowered
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isPowered = false;
        /**
         * Unit health.
         * @member {number}health
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.health = 0;
        /**
         * Unit healthMax.
         * @member {number}healthMax
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.healthMax = 0;
        /**
         * Unit shield.
         * @member {number}shield
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.shield = 0;
        /**
         * Unit energy.
         * @member {number}energy
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.energy = 0;
        /**
         * Unit mineralContents.
         * @member {number}mineralContents
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.mineralContents = 0;
        /**
         * Unit vespeneContents.
         * @member {number}vespeneContents
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.vespeneContents = 0;
        /**
         * Unit isFlying.
         * @member {boolean}isFlying
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isFlying = false;
        /**
         * Unit isBurrowed.
         * @member {boolean}isBurrowed
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.isBurrowed = false;
        /**
         * Unit orders.
         * @member {Array.<SC2APIProtocol.IUnitOrder>}orders
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.orders = $util.emptyArray;
        /**
         * Unit addOnTag.
         * @member {number|Long}addOnTag
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.addOnTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Unit passengers.
         * @member {Array.<SC2APIProtocol.IPassengerUnit>}passengers
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.passengers = $util.emptyArray;
        /**
         * Unit cargoSpaceTaken.
         * @member {number}cargoSpaceTaken
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.cargoSpaceTaken = 0;
        /**
         * Unit cargoSpaceMax.
         * @member {number}cargoSpaceMax
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.cargoSpaceMax = 0;
        /**
         * Unit buffIds.
         * @member {Array.<number>}buffIds
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.buffIds = $util.emptyArray;
        /**
         * Unit assignedHarvesters.
         * @member {number}assignedHarvesters
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.assignedHarvesters = 0;
        /**
         * Unit idealHarvesters.
         * @member {number}idealHarvesters
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.idealHarvesters = 0;
        /**
         * Unit weaponCooldown.
         * @member {number}weaponCooldown
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.weaponCooldown = 0;
        /**
         * Unit engagedTargetTag.
         * @member {number|Long}engagedTargetTag
         * @memberof SC2APIProtocol.Unit
         * @instance
         */
        Unit.prototype.engagedTargetTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Creates a new Unit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {SC2APIProtocol.IUnit=} [properties] Properties to set
         * @returns {SC2APIProtocol.Unit} Unit instance
         */
        Unit.create = function create(properties) {
            return new Unit(properties);
        };
        /**
         * Encodes the specified Unit message. Does not implicitly {@link SC2APIProtocol.Unit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {SC2APIProtocol.IUnit} message Unit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayType != null && message.hasOwnProperty("displayType"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.displayType);
            if (message.alliance != null && message.hasOwnProperty("alliance"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.alliance);
            if (message.tag != null && message.hasOwnProperty("tag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.tag);
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.unitType);
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.owner);
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.SC2APIProtocol.Point.encode(message.pos, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.facing != null && message.hasOwnProperty("facing"))
                writer.uint32(/* id 7, wireType 5 =*/ 61).float(message.facing);
            if (message.radius != null && message.hasOwnProperty("radius"))
                writer.uint32(/* id 8, wireType 5 =*/ 69).float(message.radius);
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                writer.uint32(/* id 9, wireType 5 =*/ 77).float(message.buildProgress);
            if (message.cloak != null && message.hasOwnProperty("cloak"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.cloak);
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.isSelected);
            if (message.isOnScreen != null && message.hasOwnProperty("isOnScreen"))
                writer.uint32(/* id 12, wireType 0 =*/ 96).bool(message.isOnScreen);
            if (message.isBlip != null && message.hasOwnProperty("isBlip"))
                writer.uint32(/* id 13, wireType 0 =*/ 104).bool(message.isBlip);
            if (message.health != null && message.hasOwnProperty("health"))
                writer.uint32(/* id 14, wireType 5 =*/ 117).float(message.health);
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                writer.uint32(/* id 15, wireType 5 =*/ 125).float(message.healthMax);
            if (message.shield != null && message.hasOwnProperty("shield"))
                writer.uint32(/* id 16, wireType 5 =*/ 133).float(message.shield);
            if (message.energy != null && message.hasOwnProperty("energy"))
                writer.uint32(/* id 17, wireType 5 =*/ 141).float(message.energy);
            if (message.mineralContents != null && message.hasOwnProperty("mineralContents"))
                writer.uint32(/* id 18, wireType 0 =*/ 144).int32(message.mineralContents);
            if (message.vespeneContents != null && message.hasOwnProperty("vespeneContents"))
                writer.uint32(/* id 19, wireType 0 =*/ 152).int32(message.vespeneContents);
            if (message.isFlying != null && message.hasOwnProperty("isFlying"))
                writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.isFlying);
            if (message.isBurrowed != null && message.hasOwnProperty("isBurrowed"))
                writer.uint32(/* id 21, wireType 0 =*/ 168).bool(message.isBurrowed);
            if (message.orders != null && message.orders.length)
                for (var i = 0; i < message.orders.length; ++i)
                    $root.SC2APIProtocol.UnitOrder.encode(message.orders[i], writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
            if (message.addOnTag != null && message.hasOwnProperty("addOnTag"))
                writer.uint32(/* id 23, wireType 0 =*/ 184).uint64(message.addOnTag);
            if (message.passengers != null && message.passengers.length)
                for (var i = 0; i < message.passengers.length; ++i)
                    $root.SC2APIProtocol.PassengerUnit.encode(message.passengers[i], writer.uint32(/* id 24, wireType 2 =*/ 194).fork()).ldelim();
            if (message.cargoSpaceTaken != null && message.hasOwnProperty("cargoSpaceTaken"))
                writer.uint32(/* id 25, wireType 0 =*/ 200).int32(message.cargoSpaceTaken);
            if (message.cargoSpaceMax != null && message.hasOwnProperty("cargoSpaceMax"))
                writer.uint32(/* id 26, wireType 0 =*/ 208).int32(message.cargoSpaceMax);
            if (message.buffIds != null && message.buffIds.length)
                for (var i = 0; i < message.buffIds.length; ++i)
                    writer.uint32(/* id 27, wireType 0 =*/ 216).uint32(message.buffIds[i]);
            if (message.assignedHarvesters != null && message.hasOwnProperty("assignedHarvesters"))
                writer.uint32(/* id 28, wireType 0 =*/ 224).int32(message.assignedHarvesters);
            if (message.idealHarvesters != null && message.hasOwnProperty("idealHarvesters"))
                writer.uint32(/* id 29, wireType 0 =*/ 232).int32(message.idealHarvesters);
            if (message.weaponCooldown != null && message.hasOwnProperty("weaponCooldown"))
                writer.uint32(/* id 30, wireType 5 =*/ 245).float(message.weaponCooldown);
            if (message.detectRange != null && message.hasOwnProperty("detectRange"))
                writer.uint32(/* id 31, wireType 5 =*/ 253).float(message.detectRange);
            if (message.radarRange != null && message.hasOwnProperty("radarRange"))
                writer.uint32(/* id 32, wireType 5 =*/ 261).float(message.radarRange);
            if (message.engagedTargetTag != null && message.hasOwnProperty("engagedTargetTag"))
                writer.uint32(/* id 34, wireType 0 =*/ 272).uint64(message.engagedTargetTag);
            if (message.isPowered != null && message.hasOwnProperty("isPowered"))
                writer.uint32(/* id 35, wireType 0 =*/ 280).bool(message.isPowered);
            return writer;
        };
        /**
         * Encodes the specified Unit message, length delimited. Does not implicitly {@link SC2APIProtocol.Unit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {SC2APIProtocol.IUnit} message Unit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Unit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Unit} Unit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Unit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.displayType = reader.int32();
                        break;
                    case 2:
                        message.alliance = reader.int32();
                        break;
                    case 3:
                        message.tag = reader.uint64();
                        break;
                    case 4:
                        message.unitType = reader.uint32();
                        break;
                    case 5:
                        message.owner = reader.int32();
                        break;
                    case 6:
                        message.pos = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.facing = reader.float();
                        break;
                    case 8:
                        message.radius = reader.float();
                        break;
                    case 9:
                        message.buildProgress = reader.float();
                        break;
                    case 10:
                        message.cloak = reader.int32();
                        break;
                    case 31:
                        message.detectRange = reader.float();
                        break;
                    case 32:
                        message.radarRange = reader.float();
                        break;
                    case 11:
                        message.isSelected = reader.bool();
                        break;
                    case 12:
                        message.isOnScreen = reader.bool();
                        break;
                    case 13:
                        message.isBlip = reader.bool();
                        break;
                    case 35:
                        message.isPowered = reader.bool();
                        break;
                    case 14:
                        message.health = reader.float();
                        break;
                    case 15:
                        message.healthMax = reader.float();
                        break;
                    case 16:
                        message.shield = reader.float();
                        break;
                    case 17:
                        message.energy = reader.float();
                        break;
                    case 18:
                        message.mineralContents = reader.int32();
                        break;
                    case 19:
                        message.vespeneContents = reader.int32();
                        break;
                    case 20:
                        message.isFlying = reader.bool();
                        break;
                    case 21:
                        message.isBurrowed = reader.bool();
                        break;
                    case 22:
                        if (!(message.orders && message.orders.length))
                            message.orders = [];
                        message.orders.push($root.SC2APIProtocol.UnitOrder.decode(reader, reader.uint32()));
                        break;
                    case 23:
                        message.addOnTag = reader.uint64();
                        break;
                    case 24:
                        if (!(message.passengers && message.passengers.length))
                            message.passengers = [];
                        message.passengers.push($root.SC2APIProtocol.PassengerUnit.decode(reader, reader.uint32()));
                        break;
                    case 25:
                        message.cargoSpaceTaken = reader.int32();
                        break;
                    case 26:
                        message.cargoSpaceMax = reader.int32();
                        break;
                    case 27:
                        if (!(message.buffIds && message.buffIds.length))
                            message.buffIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.buffIds.push(reader.uint32());
                        }
                        else
                            message.buffIds.push(reader.uint32());
                        break;
                    case 28:
                        message.assignedHarvesters = reader.int32();
                        break;
                    case 29:
                        message.idealHarvesters = reader.int32();
                        break;
                    case 30:
                        message.weaponCooldown = reader.float();
                        break;
                    case 34:
                        message.engagedTargetTag = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Unit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Unit} Unit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Unit message.
         * @function verify
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayType != null && message.hasOwnProperty("displayType"))
                switch (message.displayType) {
                    default:
                        return "displayType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.alliance != null && message.hasOwnProperty("alliance"))
                switch (message.alliance) {
                    default:
                        return "alliance: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag) && !(message.tag && $util.isInteger(message.tag.low) && $util.isInteger(message.tag.high)))
                    return "tag: integer|Long expected";
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                if (!$util.isInteger(message.unitType))
                    return "unitType: integer expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isInteger(message.owner))
                    return "owner: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.SC2APIProtocol.Point.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.facing != null && message.hasOwnProperty("facing"))
                if (typeof message.facing !== "number")
                    return "facing: number expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                if (typeof message.buildProgress !== "number")
                    return "buildProgress: number expected";
            if (message.cloak != null && message.hasOwnProperty("cloak"))
                switch (message.cloak) {
                    default:
                        return "cloak: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.detectRange != null && message.hasOwnProperty("detectRange"))
                if (typeof message.detectRange !== "number")
                    return "detectRange: number expected";
            if (message.radarRange != null && message.hasOwnProperty("radarRange"))
                if (typeof message.radarRange !== "number")
                    return "radarRange: number expected";
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                if (typeof message.isSelected !== "boolean")
                    return "isSelected: boolean expected";
            if (message.isOnScreen != null && message.hasOwnProperty("isOnScreen"))
                if (typeof message.isOnScreen !== "boolean")
                    return "isOnScreen: boolean expected";
            if (message.isBlip != null && message.hasOwnProperty("isBlip"))
                if (typeof message.isBlip !== "boolean")
                    return "isBlip: boolean expected";
            if (message.isPowered != null && message.hasOwnProperty("isPowered"))
                if (typeof message.isPowered !== "boolean")
                    return "isPowered: boolean expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (typeof message.health !== "number")
                    return "health: number expected";
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                if (typeof message.healthMax !== "number")
                    return "healthMax: number expected";
            if (message.shield != null && message.hasOwnProperty("shield"))
                if (typeof message.shield !== "number")
                    return "shield: number expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (typeof message.energy !== "number")
                    return "energy: number expected";
            if (message.mineralContents != null && message.hasOwnProperty("mineralContents"))
                if (!$util.isInteger(message.mineralContents))
                    return "mineralContents: integer expected";
            if (message.vespeneContents != null && message.hasOwnProperty("vespeneContents"))
                if (!$util.isInteger(message.vespeneContents))
                    return "vespeneContents: integer expected";
            if (message.isFlying != null && message.hasOwnProperty("isFlying"))
                if (typeof message.isFlying !== "boolean")
                    return "isFlying: boolean expected";
            if (message.isBurrowed != null && message.hasOwnProperty("isBurrowed"))
                if (typeof message.isBurrowed !== "boolean")
                    return "isBurrowed: boolean expected";
            if (message.orders != null && message.hasOwnProperty("orders")) {
                if (!Array.isArray(message.orders))
                    return "orders: array expected";
                for (var i = 0; i < message.orders.length; ++i) {
                    error = $root.SC2APIProtocol.UnitOrder.verify(message.orders[i]);
                    if (error)
                        return "orders." + error;
                }
            }
            if (message.addOnTag != null && message.hasOwnProperty("addOnTag"))
                if (!$util.isInteger(message.addOnTag) && !(message.addOnTag && $util.isInteger(message.addOnTag.low) && $util.isInteger(message.addOnTag.high)))
                    return "addOnTag: integer|Long expected";
            if (message.passengers != null && message.hasOwnProperty("passengers")) {
                if (!Array.isArray(message.passengers))
                    return "passengers: array expected";
                for (var i = 0; i < message.passengers.length; ++i) {
                    error = $root.SC2APIProtocol.PassengerUnit.verify(message.passengers[i]);
                    if (error)
                        return "passengers." + error;
                }
            }
            if (message.cargoSpaceTaken != null && message.hasOwnProperty("cargoSpaceTaken"))
                if (!$util.isInteger(message.cargoSpaceTaken))
                    return "cargoSpaceTaken: integer expected";
            if (message.cargoSpaceMax != null && message.hasOwnProperty("cargoSpaceMax"))
                if (!$util.isInteger(message.cargoSpaceMax))
                    return "cargoSpaceMax: integer expected";
            if (message.buffIds != null && message.hasOwnProperty("buffIds")) {
                if (!Array.isArray(message.buffIds))
                    return "buffIds: array expected";
                for (var i = 0; i < message.buffIds.length; ++i)
                    if (!$util.isInteger(message.buffIds[i]))
                        return "buffIds: integer[] expected";
            }
            if (message.assignedHarvesters != null && message.hasOwnProperty("assignedHarvesters"))
                if (!$util.isInteger(message.assignedHarvesters))
                    return "assignedHarvesters: integer expected";
            if (message.idealHarvesters != null && message.hasOwnProperty("idealHarvesters"))
                if (!$util.isInteger(message.idealHarvesters))
                    return "idealHarvesters: integer expected";
            if (message.weaponCooldown != null && message.hasOwnProperty("weaponCooldown"))
                if (typeof message.weaponCooldown !== "number")
                    return "weaponCooldown: number expected";
            if (message.engagedTargetTag != null && message.hasOwnProperty("engagedTargetTag"))
                if (!$util.isInteger(message.engagedTargetTag) && !(message.engagedTargetTag && $util.isInteger(message.engagedTargetTag.low) && $util.isInteger(message.engagedTargetTag.high)))
                    return "engagedTargetTag: integer|Long expected";
            return null;
        };
        /**
         * Creates an Unit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Unit} Unit
         */
        Unit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Unit)
                return object;
            var message = new $root.SC2APIProtocol.Unit();
            switch (object.displayType) {
                case "Visible":
                case 1:
                    message.displayType = 1;
                    break;
                case "Snapshot":
                case 2:
                    message.displayType = 2;
                    break;
                case "Hidden":
                case 3:
                    message.displayType = 3;
                    break;
            }
            switch (object.alliance) {
                case "Self":
                case 1:
                    message.alliance = 1;
                    break;
                case "Ally":
                case 2:
                    message.alliance = 2;
                    break;
                case "Neutral":
                case 3:
                    message.alliance = 3;
                    break;
                case "Enemy":
                case 4:
                    message.alliance = 4;
                    break;
            }
            if (object.tag != null)
                if ($util.Long)
                    (message.tag = $util.Long.fromValue(object.tag)).unsigned = true;
                else if (typeof object.tag === "string")
                    message.tag = parseInt(object.tag, 10);
                else if (typeof object.tag === "number")
                    message.tag = object.tag;
                else if (typeof object.tag === "object")
                    message.tag = new $util.LongBits(object.tag.low >>> 0, object.tag.high >>> 0).toNumber(true);
            if (object.unitType != null)
                message.unitType = object.unitType >>> 0;
            if (object.owner != null)
                message.owner = object.owner | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".SC2APIProtocol.Unit.pos: object expected");
                message.pos = $root.SC2APIProtocol.Point.fromObject(object.pos);
            }
            if (object.facing != null)
                message.facing = Number(object.facing);
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.buildProgress != null)
                message.buildProgress = Number(object.buildProgress);
            switch (object.cloak) {
                case "Cloaked":
                case 1:
                    message.cloak = 1;
                    break;
                case "CloakedDetected":
                case 2:
                    message.cloak = 2;
                    break;
                case "NotCloaked":
                case 3:
                    message.cloak = 3;
                    break;
            }
            if (object.detectRange != null)
                message.detectRange = Number(object.detectRange);
            if (object.radarRange != null)
                message.radarRange = Number(object.radarRange);
            if (object.isSelected != null)
                message.isSelected = Boolean(object.isSelected);
            if (object.isOnScreen != null)
                message.isOnScreen = Boolean(object.isOnScreen);
            if (object.isBlip != null)
                message.isBlip = Boolean(object.isBlip);
            if (object.isPowered != null)
                message.isPowered = Boolean(object.isPowered);
            if (object.health != null)
                message.health = Number(object.health);
            if (object.healthMax != null)
                message.healthMax = Number(object.healthMax);
            if (object.shield != null)
                message.shield = Number(object.shield);
            if (object.energy != null)
                message.energy = Number(object.energy);
            if (object.mineralContents != null)
                message.mineralContents = object.mineralContents | 0;
            if (object.vespeneContents != null)
                message.vespeneContents = object.vespeneContents | 0;
            if (object.isFlying != null)
                message.isFlying = Boolean(object.isFlying);
            if (object.isBurrowed != null)
                message.isBurrowed = Boolean(object.isBurrowed);
            if (object.orders) {
                if (!Array.isArray(object.orders))
                    throw TypeError(".SC2APIProtocol.Unit.orders: array expected");
                message.orders = [];
                for (var i = 0; i < object.orders.length; ++i) {
                    if (typeof object.orders[i] !== "object")
                        throw TypeError(".SC2APIProtocol.Unit.orders: object expected");
                    message.orders[i] = $root.SC2APIProtocol.UnitOrder.fromObject(object.orders[i]);
                }
            }
            if (object.addOnTag != null)
                if ($util.Long)
                    (message.addOnTag = $util.Long.fromValue(object.addOnTag)).unsigned = true;
                else if (typeof object.addOnTag === "string")
                    message.addOnTag = parseInt(object.addOnTag, 10);
                else if (typeof object.addOnTag === "number")
                    message.addOnTag = object.addOnTag;
                else if (typeof object.addOnTag === "object")
                    message.addOnTag = new $util.LongBits(object.addOnTag.low >>> 0, object.addOnTag.high >>> 0).toNumber(true);
            if (object.passengers) {
                if (!Array.isArray(object.passengers))
                    throw TypeError(".SC2APIProtocol.Unit.passengers: array expected");
                message.passengers = [];
                for (var i = 0; i < object.passengers.length; ++i) {
                    if (typeof object.passengers[i] !== "object")
                        throw TypeError(".SC2APIProtocol.Unit.passengers: object expected");
                    message.passengers[i] = $root.SC2APIProtocol.PassengerUnit.fromObject(object.passengers[i]);
                }
            }
            if (object.cargoSpaceTaken != null)
                message.cargoSpaceTaken = object.cargoSpaceTaken | 0;
            if (object.cargoSpaceMax != null)
                message.cargoSpaceMax = object.cargoSpaceMax | 0;
            if (object.buffIds) {
                if (!Array.isArray(object.buffIds))
                    throw TypeError(".SC2APIProtocol.Unit.buffIds: array expected");
                message.buffIds = [];
                for (var i = 0; i < object.buffIds.length; ++i)
                    message.buffIds[i] = object.buffIds[i] >>> 0;
            }
            if (object.assignedHarvesters != null)
                message.assignedHarvesters = object.assignedHarvesters | 0;
            if (object.idealHarvesters != null)
                message.idealHarvesters = object.idealHarvesters | 0;
            if (object.weaponCooldown != null)
                message.weaponCooldown = Number(object.weaponCooldown);
            if (object.engagedTargetTag != null)
                if ($util.Long)
                    (message.engagedTargetTag = $util.Long.fromValue(object.engagedTargetTag)).unsigned = true;
                else if (typeof object.engagedTargetTag === "string")
                    message.engagedTargetTag = parseInt(object.engagedTargetTag, 10);
                else if (typeof object.engagedTargetTag === "number")
                    message.engagedTargetTag = object.engagedTargetTag;
                else if (typeof object.engagedTargetTag === "object")
                    message.engagedTargetTag = new $util.LongBits(object.engagedTargetTag.low >>> 0, object.engagedTargetTag.high >>> 0).toNumber(true);
            return message;
        };
        /**
         * Creates a plain object from an Unit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Unit
         * @static
         * @param {SC2APIProtocol.Unit} message Unit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orders = [];
                object.passengers = [];
                object.buffIds = [];
            }
            if (options.defaults) {
                object.displayType = options.enums === String ? "Visible" : 1;
                object.alliance = options.enums === String ? "Self" : 1;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.tag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.tag = options.longs === String ? "0" : 0;
                object.unitType = 0;
                object.owner = 0;
                object.pos = null;
                object.facing = 0;
                object.radius = 0;
                object.buildProgress = 0;
                object.cloak = options.enums === String ? "Cloaked" : 1;
                object.isSelected = false;
                object.isOnScreen = false;
                object.isBlip = false;
                object.health = 0;
                object.healthMax = 0;
                object.shield = 0;
                object.energy = 0;
                object.mineralContents = 0;
                object.vespeneContents = 0;
                object.isFlying = false;
                object.isBurrowed = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.addOnTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.addOnTag = options.longs === String ? "0" : 0;
                object.cargoSpaceTaken = 0;
                object.cargoSpaceMax = 0;
                object.assignedHarvesters = 0;
                object.idealHarvesters = 0;
                object.weaponCooldown = 0;
                object.detectRange = 0;
                object.radarRange = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.engagedTargetTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.engagedTargetTag = options.longs === String ? "0" : 0;
                object.isPowered = false;
            }
            if (message.displayType != null && message.hasOwnProperty("displayType"))
                object.displayType = options.enums === String ? $root.SC2APIProtocol.DisplayType[message.displayType] : message.displayType;
            if (message.alliance != null && message.hasOwnProperty("alliance"))
                object.alliance = options.enums === String ? $root.SC2APIProtocol.Alliance[message.alliance] : message.alliance;
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (typeof message.tag === "number")
                    object.tag = options.longs === String ? String(message.tag) : message.tag;
                else
                    object.tag = options.longs === String ? $util.Long.prototype.toString.call(message.tag) : options.longs === Number ? new $util.LongBits(message.tag.low >>> 0, message.tag.high >>> 0).toNumber(true) : message.tag;
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = message.unitType;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.SC2APIProtocol.Point.toObject(message.pos, options);
            if (message.facing != null && message.hasOwnProperty("facing"))
                object.facing = options.json && !isFinite(message.facing) ? String(message.facing) : message.facing;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                object.buildProgress = options.json && !isFinite(message.buildProgress) ? String(message.buildProgress) : message.buildProgress;
            if (message.cloak != null && message.hasOwnProperty("cloak"))
                object.cloak = options.enums === String ? $root.SC2APIProtocol.CloakState[message.cloak] : message.cloak;
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                object.isSelected = message.isSelected;
            if (message.isOnScreen != null && message.hasOwnProperty("isOnScreen"))
                object.isOnScreen = message.isOnScreen;
            if (message.isBlip != null && message.hasOwnProperty("isBlip"))
                object.isBlip = message.isBlip;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = options.json && !isFinite(message.health) ? String(message.health) : message.health;
            if (message.healthMax != null && message.hasOwnProperty("healthMax"))
                object.healthMax = options.json && !isFinite(message.healthMax) ? String(message.healthMax) : message.healthMax;
            if (message.shield != null && message.hasOwnProperty("shield"))
                object.shield = options.json && !isFinite(message.shield) ? String(message.shield) : message.shield;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = options.json && !isFinite(message.energy) ? String(message.energy) : message.energy;
            if (message.mineralContents != null && message.hasOwnProperty("mineralContents"))
                object.mineralContents = message.mineralContents;
            if (message.vespeneContents != null && message.hasOwnProperty("vespeneContents"))
                object.vespeneContents = message.vespeneContents;
            if (message.isFlying != null && message.hasOwnProperty("isFlying"))
                object.isFlying = message.isFlying;
            if (message.isBurrowed != null && message.hasOwnProperty("isBurrowed"))
                object.isBurrowed = message.isBurrowed;
            if (message.orders && message.orders.length) {
                object.orders = [];
                for (var j = 0; j < message.orders.length; ++j)
                    object.orders[j] = $root.SC2APIProtocol.UnitOrder.toObject(message.orders[j], options);
            }
            if (message.addOnTag != null && message.hasOwnProperty("addOnTag"))
                if (typeof message.addOnTag === "number")
                    object.addOnTag = options.longs === String ? String(message.addOnTag) : message.addOnTag;
                else
                    object.addOnTag = options.longs === String ? $util.Long.prototype.toString.call(message.addOnTag) : options.longs === Number ? new $util.LongBits(message.addOnTag.low >>> 0, message.addOnTag.high >>> 0).toNumber(true) : message.addOnTag;
            if (message.passengers && message.passengers.length) {
                object.passengers = [];
                for (var j = 0; j < message.passengers.length; ++j)
                    object.passengers[j] = $root.SC2APIProtocol.PassengerUnit.toObject(message.passengers[j], options);
            }
            if (message.cargoSpaceTaken != null && message.hasOwnProperty("cargoSpaceTaken"))
                object.cargoSpaceTaken = message.cargoSpaceTaken;
            if (message.cargoSpaceMax != null && message.hasOwnProperty("cargoSpaceMax"))
                object.cargoSpaceMax = message.cargoSpaceMax;
            if (message.buffIds && message.buffIds.length) {
                object.buffIds = [];
                for (var j = 0; j < message.buffIds.length; ++j)
                    object.buffIds[j] = message.buffIds[j];
            }
            if (message.assignedHarvesters != null && message.hasOwnProperty("assignedHarvesters"))
                object.assignedHarvesters = message.assignedHarvesters;
            if (message.idealHarvesters != null && message.hasOwnProperty("idealHarvesters"))
                object.idealHarvesters = message.idealHarvesters;
            if (message.weaponCooldown != null && message.hasOwnProperty("weaponCooldown"))
                object.weaponCooldown = options.json && !isFinite(message.weaponCooldown) ? String(message.weaponCooldown) : message.weaponCooldown;
            if (message.detectRange != null && message.hasOwnProperty("detectRange"))
                object.detectRange = options.json && !isFinite(message.detectRange) ? String(message.detectRange) : message.detectRange;
            if (message.radarRange != null && message.hasOwnProperty("radarRange"))
                object.radarRange = options.json && !isFinite(message.radarRange) ? String(message.radarRange) : message.radarRange;
            if (message.engagedTargetTag != null && message.hasOwnProperty("engagedTargetTag"))
                if (typeof message.engagedTargetTag === "number")
                    object.engagedTargetTag = options.longs === String ? String(message.engagedTargetTag) : message.engagedTargetTag;
                else
                    object.engagedTargetTag = options.longs === String ? $util.Long.prototype.toString.call(message.engagedTargetTag) : options.longs === Number ? new $util.LongBits(message.engagedTargetTag.low >>> 0, message.engagedTargetTag.high >>> 0).toNumber(true) : message.engagedTargetTag;
            if (message.isPowered != null && message.hasOwnProperty("isPowered"))
                object.isPowered = message.isPowered;
            return object;
        };
        /**
         * Converts this Unit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Unit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Unit;
    })();
    SC2APIProtocol.MapState = (function () {
        /**
         * Properties of a MapState.
         * @memberof SC2APIProtocol
         * @interface IMapState
         * @property {SC2APIProtocol.IImageData} [visibility] MapState visibility
         * @property {SC2APIProtocol.IImageData} [creep] MapState creep
         */
        /**
         * Constructs a new MapState.
         * @memberof SC2APIProtocol
         * @classdesc Represents a MapState.
         * @constructor
         * @param {SC2APIProtocol.IMapState=} [properties] Properties to set
         */
        function MapState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MapState visibility.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}visibility
         * @memberof SC2APIProtocol.MapState
         * @instance
         */
        MapState.prototype.visibility = null;
        /**
         * MapState creep.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}creep
         * @memberof SC2APIProtocol.MapState
         * @instance
         */
        MapState.prototype.creep = null;
        /**
         * Creates a new MapState instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {SC2APIProtocol.IMapState=} [properties] Properties to set
         * @returns {SC2APIProtocol.MapState} MapState instance
         */
        MapState.create = function create(properties) {
            return new MapState(properties);
        };
        /**
         * Encodes the specified MapState message. Does not implicitly {@link SC2APIProtocol.MapState.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {SC2APIProtocol.IMapState} message MapState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                $root.SC2APIProtocol.ImageData.encode(message.visibility, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.creep != null && message.hasOwnProperty("creep"))
                $root.SC2APIProtocol.ImageData.encode(message.creep, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified MapState message, length delimited. Does not implicitly {@link SC2APIProtocol.MapState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {SC2APIProtocol.IMapState} message MapState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a MapState message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.MapState} MapState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.MapState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.visibility = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.creep = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a MapState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.MapState} MapState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a MapState message.
         * @function verify
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.visibility != null && message.hasOwnProperty("visibility")) {
                var error = $root.SC2APIProtocol.ImageData.verify(message.visibility);
                if (error)
                    return "visibility." + error;
            }
            if (message.creep != null && message.hasOwnProperty("creep")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.creep);
                if (error)
                    return "creep." + error;
            }
            return null;
        };
        /**
         * Creates a MapState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.MapState} MapState
         */
        MapState.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.MapState)
                return object;
            var message = new $root.SC2APIProtocol.MapState();
            if (object.visibility != null) {
                if (typeof object.visibility !== "object")
                    throw TypeError(".SC2APIProtocol.MapState.visibility: object expected");
                message.visibility = $root.SC2APIProtocol.ImageData.fromObject(object.visibility);
            }
            if (object.creep != null) {
                if (typeof object.creep !== "object")
                    throw TypeError(".SC2APIProtocol.MapState.creep: object expected");
                message.creep = $root.SC2APIProtocol.ImageData.fromObject(object.creep);
            }
            return message;
        };
        /**
         * Creates a plain object from a MapState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.MapState
         * @static
         * @param {SC2APIProtocol.MapState} message MapState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.visibility = null;
                object.creep = null;
            }
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                object.visibility = $root.SC2APIProtocol.ImageData.toObject(message.visibility, options);
            if (message.creep != null && message.hasOwnProperty("creep"))
                object.creep = $root.SC2APIProtocol.ImageData.toObject(message.creep, options);
            return object;
        };
        /**
         * Converts this MapState to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.MapState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return MapState;
    })();
    SC2APIProtocol.ActionRaw = (function () {
        /**
         * Properties of an ActionRaw.
         * @memberof SC2APIProtocol
         * @interface IActionRaw
         * @property {SC2APIProtocol.IActionRawUnitCommand} [unitCommand] ActionRaw unitCommand
         * @property {SC2APIProtocol.IActionRawCameraMove} [cameraMove] ActionRaw cameraMove
         * @property {SC2APIProtocol.IActionRawToggleAutocast} [toggleAutocast] ActionRaw toggleAutocast
         */
        /**
         * Constructs a new ActionRaw.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionRaw.
         * @constructor
         * @param {SC2APIProtocol.IActionRaw=} [properties] Properties to set
         */
        function ActionRaw(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionRaw unitCommand.
         * @member {(SC2APIProtocol.IActionRawUnitCommand|null|undefined)}unitCommand
         * @memberof SC2APIProtocol.ActionRaw
         * @instance
         */
        ActionRaw.prototype.unitCommand = null;
        /**
         * ActionRaw cameraMove.
         * @member {(SC2APIProtocol.IActionRawCameraMove|null|undefined)}cameraMove
         * @memberof SC2APIProtocol.ActionRaw
         * @instance
         */
        ActionRaw.prototype.cameraMove = null;
        /**
         * ActionRaw toggleAutocast.
         * @member {(SC2APIProtocol.IActionRawToggleAutocast|null|undefined)}toggleAutocast
         * @memberof SC2APIProtocol.ActionRaw
         * @instance
         */
        ActionRaw.prototype.toggleAutocast = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ActionRaw action.
         * @member {string|undefined} action
         * @memberof SC2APIProtocol.ActionRaw
         * @instance
         */
        Object.defineProperty(ActionRaw.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["unitCommand", "cameraMove", "toggleAutocast"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ActionRaw instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {SC2APIProtocol.IActionRaw=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionRaw} ActionRaw instance
         */
        ActionRaw.create = function create(properties) {
            return new ActionRaw(properties);
        };
        /**
         * Encodes the specified ActionRaw message. Does not implicitly {@link SC2APIProtocol.ActionRaw.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {SC2APIProtocol.IActionRaw} message ActionRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRaw.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand"))
                $root.SC2APIProtocol.ActionRawUnitCommand.encode(message.unitCommand, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove"))
                $root.SC2APIProtocol.ActionRawCameraMove.encode(message.cameraMove, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast"))
                $root.SC2APIProtocol.ActionRawToggleAutocast.encode(message.toggleAutocast, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ActionRaw message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {SC2APIProtocol.IActionRaw} message ActionRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRaw.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionRaw message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionRaw} ActionRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRaw.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionRaw();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitCommand = $root.SC2APIProtocol.ActionRawUnitCommand.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.cameraMove = $root.SC2APIProtocol.ActionRawCameraMove.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.toggleAutocast = $root.SC2APIProtocol.ActionRawToggleAutocast.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionRaw} ActionRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRaw.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionRaw message.
         * @function verify
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionRaw.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand")) {
                properties.action = 1;
                var error = $root.SC2APIProtocol.ActionRawUnitCommand.verify(message.unitCommand);
                if (error)
                    return "unitCommand." + error;
            }
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionRawCameraMove.verify(message.cameraMove);
                if (error)
                    return "cameraMove." + error;
            }
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionRawToggleAutocast.verify(message.toggleAutocast);
                if (error)
                    return "toggleAutocast." + error;
            }
            return null;
        };
        /**
         * Creates an ActionRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionRaw} ActionRaw
         */
        ActionRaw.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionRaw)
                return object;
            var message = new $root.SC2APIProtocol.ActionRaw();
            if (object.unitCommand != null) {
                if (typeof object.unitCommand !== "object")
                    throw TypeError(".SC2APIProtocol.ActionRaw.unitCommand: object expected");
                message.unitCommand = $root.SC2APIProtocol.ActionRawUnitCommand.fromObject(object.unitCommand);
            }
            if (object.cameraMove != null) {
                if (typeof object.cameraMove !== "object")
                    throw TypeError(".SC2APIProtocol.ActionRaw.cameraMove: object expected");
                message.cameraMove = $root.SC2APIProtocol.ActionRawCameraMove.fromObject(object.cameraMove);
            }
            if (object.toggleAutocast != null) {
                if (typeof object.toggleAutocast !== "object")
                    throw TypeError(".SC2APIProtocol.ActionRaw.toggleAutocast: object expected");
                message.toggleAutocast = $root.SC2APIProtocol.ActionRawToggleAutocast.fromObject(object.toggleAutocast);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionRaw
         * @static
         * @param {SC2APIProtocol.ActionRaw} message ActionRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionRaw.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand")) {
                object.unitCommand = $root.SC2APIProtocol.ActionRawUnitCommand.toObject(message.unitCommand, options);
                if (options.oneofs)
                    object.action = "unitCommand";
            }
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove")) {
                object.cameraMove = $root.SC2APIProtocol.ActionRawCameraMove.toObject(message.cameraMove, options);
                if (options.oneofs)
                    object.action = "cameraMove";
            }
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast")) {
                object.toggleAutocast = $root.SC2APIProtocol.ActionRawToggleAutocast.toObject(message.toggleAutocast, options);
                if (options.oneofs)
                    object.action = "toggleAutocast";
            }
            return object;
        };
        /**
         * Converts this ActionRaw to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionRaw.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionRaw;
    })();
    SC2APIProtocol.ActionRawUnitCommand = (function () {
        /**
         * Properties of an ActionRawUnitCommand.
         * @memberof SC2APIProtocol
         * @interface IActionRawUnitCommand
         * @property {number} [abilityId] ActionRawUnitCommand abilityId
         * @property {SC2APIProtocol.IPoint2D} [targetWorldSpacePos] ActionRawUnitCommand targetWorldSpacePos
         * @property {number|Long} [targetUnitTag] ActionRawUnitCommand targetUnitTag
         * @property {Array.<number|Long>} [unitTags] ActionRawUnitCommand unitTags
         * @property {boolean} [queueCommand] ActionRawUnitCommand queueCommand
         */
        /**
         * Constructs a new ActionRawUnitCommand.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionRawUnitCommand.
         * @constructor
         * @param {SC2APIProtocol.IActionRawUnitCommand=} [properties] Properties to set
         */
        function ActionRawUnitCommand(properties) {
            this.unitTags = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionRawUnitCommand abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        ActionRawUnitCommand.prototype.abilityId = 0;
        /**
         * ActionRawUnitCommand targetWorldSpacePos.
         * @member {(SC2APIProtocol.IPoint2D|null|undefined)}targetWorldSpacePos
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        ActionRawUnitCommand.prototype.targetWorldSpacePos = null;
        /**
         * ActionRawUnitCommand targetUnitTag.
         * @member {number|Long}targetUnitTag
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        ActionRawUnitCommand.prototype.targetUnitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * ActionRawUnitCommand unitTags.
         * @member {Array.<number|Long>}unitTags
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        ActionRawUnitCommand.prototype.unitTags = $util.emptyArray;
        /**
         * ActionRawUnitCommand queueCommand.
         * @member {boolean}queueCommand
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        ActionRawUnitCommand.prototype.queueCommand = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ActionRawUnitCommand target.
         * @member {string|undefined} target
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         */
        Object.defineProperty(ActionRawUnitCommand.prototype, "target", {
            get: $util.oneOfGetter($oneOfFields = ["targetWorldSpacePos", "targetUnitTag"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ActionRawUnitCommand instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionRawUnitCommand=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionRawUnitCommand} ActionRawUnitCommand instance
         */
        ActionRawUnitCommand.create = function create(properties) {
            return new ActionRawUnitCommand(properties);
        };
        /**
         * Encodes the specified ActionRawUnitCommand message. Does not implicitly {@link SC2APIProtocol.ActionRawUnitCommand.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionRawUnitCommand} message ActionRawUnitCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawUnitCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos"))
                $root.SC2APIProtocol.Point2D.encode(message.targetWorldSpacePos, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.targetUnitTag);
            if (message.unitTags != null && message.unitTags.length)
                for (var i = 0; i < message.unitTags.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.unitTags[i]);
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.queueCommand);
            return writer;
        };
        /**
         * Encodes the specified ActionRawUnitCommand message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionRawUnitCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionRawUnitCommand} message ActionRawUnitCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawUnitCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionRawUnitCommand message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionRawUnitCommand} ActionRawUnitCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawUnitCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionRawUnitCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    case 2:
                        message.targetWorldSpacePos = $root.SC2APIProtocol.Point2D.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.targetUnitTag = reader.uint64();
                        break;
                    case 4:
                        if (!(message.unitTags && message.unitTags.length))
                            message.unitTags = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.unitTags.push(reader.uint64());
                        }
                        else
                            message.unitTags.push(reader.uint64());
                        break;
                    case 5:
                        message.queueCommand = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionRawUnitCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionRawUnitCommand} ActionRawUnitCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawUnitCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionRawUnitCommand message.
         * @function verify
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionRawUnitCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos")) {
                properties.target = 1;
                var error = $root.SC2APIProtocol.Point2D.verify(message.targetWorldSpacePos);
                if (error)
                    return "targetWorldSpacePos." + error;
            }
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag")) {
                if (properties.target === 1)
                    return "target: multiple values";
                properties.target = 1;
                if (!$util.isInteger(message.targetUnitTag) && !(message.targetUnitTag && $util.isInteger(message.targetUnitTag.low) && $util.isInteger(message.targetUnitTag.high)))
                    return "targetUnitTag: integer|Long expected";
            }
            if (message.unitTags != null && message.hasOwnProperty("unitTags")) {
                if (!Array.isArray(message.unitTags))
                    return "unitTags: array expected";
                for (var i = 0; i < message.unitTags.length; ++i)
                    if (!$util.isInteger(message.unitTags[i]) && !(message.unitTags[i] && $util.isInteger(message.unitTags[i].low) && $util.isInteger(message.unitTags[i].high)))
                        return "unitTags: integer|Long[] expected";
            }
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                if (typeof message.queueCommand !== "boolean")
                    return "queueCommand: boolean expected";
            return null;
        };
        /**
         * Creates an ActionRawUnitCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionRawUnitCommand} ActionRawUnitCommand
         */
        ActionRawUnitCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionRawUnitCommand)
                return object;
            var message = new $root.SC2APIProtocol.ActionRawUnitCommand();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            if (object.targetWorldSpacePos != null) {
                if (typeof object.targetWorldSpacePos !== "object")
                    throw TypeError(".SC2APIProtocol.ActionRawUnitCommand.targetWorldSpacePos: object expected");
                message.targetWorldSpacePos = $root.SC2APIProtocol.Point2D.fromObject(object.targetWorldSpacePos);
            }
            if (object.targetUnitTag != null)
                if ($util.Long)
                    (message.targetUnitTag = $util.Long.fromValue(object.targetUnitTag)).unsigned = true;
                else if (typeof object.targetUnitTag === "string")
                    message.targetUnitTag = parseInt(object.targetUnitTag, 10);
                else if (typeof object.targetUnitTag === "number")
                    message.targetUnitTag = object.targetUnitTag;
                else if (typeof object.targetUnitTag === "object")
                    message.targetUnitTag = new $util.LongBits(object.targetUnitTag.low >>> 0, object.targetUnitTag.high >>> 0).toNumber(true);
            if (object.unitTags) {
                if (!Array.isArray(object.unitTags))
                    throw TypeError(".SC2APIProtocol.ActionRawUnitCommand.unitTags: array expected");
                message.unitTags = [];
                for (var i = 0; i < object.unitTags.length; ++i)
                    if ($util.Long)
                        (message.unitTags[i] = $util.Long.fromValue(object.unitTags[i])).unsigned = true;
                    else if (typeof object.unitTags[i] === "string")
                        message.unitTags[i] = parseInt(object.unitTags[i], 10);
                    else if (typeof object.unitTags[i] === "number")
                        message.unitTags[i] = object.unitTags[i];
                    else if (typeof object.unitTags[i] === "object")
                        message.unitTags[i] = new $util.LongBits(object.unitTags[i].low >>> 0, object.unitTags[i].high >>> 0).toNumber(true);
            }
            if (object.queueCommand != null)
                message.queueCommand = Boolean(object.queueCommand);
            return message;
        };
        /**
         * Creates a plain object from an ActionRawUnitCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @static
         * @param {SC2APIProtocol.ActionRawUnitCommand} message ActionRawUnitCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionRawUnitCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unitTags = [];
            if (options.defaults) {
                object.abilityId = 0;
                object.queueCommand = false;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.targetWorldSpacePos != null && message.hasOwnProperty("targetWorldSpacePos")) {
                object.targetWorldSpacePos = $root.SC2APIProtocol.Point2D.toObject(message.targetWorldSpacePos, options);
                if (options.oneofs)
                    object.target = "targetWorldSpacePos";
            }
            if (message.targetUnitTag != null && message.hasOwnProperty("targetUnitTag")) {
                if (typeof message.targetUnitTag === "number")
                    object.targetUnitTag = options.longs === String ? String(message.targetUnitTag) : message.targetUnitTag;
                else
                    object.targetUnitTag = options.longs === String ? $util.Long.prototype.toString.call(message.targetUnitTag) : options.longs === Number ? new $util.LongBits(message.targetUnitTag.low >>> 0, message.targetUnitTag.high >>> 0).toNumber(true) : message.targetUnitTag;
                if (options.oneofs)
                    object.target = "targetUnitTag";
            }
            if (message.unitTags && message.unitTags.length) {
                object.unitTags = [];
                for (var j = 0; j < message.unitTags.length; ++j)
                    if (typeof message.unitTags[j] === "number")
                        object.unitTags[j] = options.longs === String ? String(message.unitTags[j]) : message.unitTags[j];
                    else
                        object.unitTags[j] = options.longs === String ? $util.Long.prototype.toString.call(message.unitTags[j]) : options.longs === Number ? new $util.LongBits(message.unitTags[j].low >>> 0, message.unitTags[j].high >>> 0).toNumber(true) : message.unitTags[j];
            }
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                object.queueCommand = message.queueCommand;
            return object;
        };
        /**
         * Converts this ActionRawUnitCommand to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionRawUnitCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionRawUnitCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionRawUnitCommand;
    })();
    SC2APIProtocol.ActionRawCameraMove = (function () {
        /**
         * Properties of an ActionRawCameraMove.
         * @memberof SC2APIProtocol
         * @interface IActionRawCameraMove
         * @property {SC2APIProtocol.IPoint} [centerWorldSpace] ActionRawCameraMove centerWorldSpace
         */
        /**
         * Constructs a new ActionRawCameraMove.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionRawCameraMove.
         * @constructor
         * @param {SC2APIProtocol.IActionRawCameraMove=} [properties] Properties to set
         */
        function ActionRawCameraMove(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionRawCameraMove centerWorldSpace.
         * @member {(SC2APIProtocol.IPoint|null|undefined)}centerWorldSpace
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @instance
         */
        ActionRawCameraMove.prototype.centerWorldSpace = null;
        /**
         * Creates a new ActionRawCameraMove instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {SC2APIProtocol.IActionRawCameraMove=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionRawCameraMove} ActionRawCameraMove instance
         */
        ActionRawCameraMove.create = function create(properties) {
            return new ActionRawCameraMove(properties);
        };
        /**
         * Encodes the specified ActionRawCameraMove message. Does not implicitly {@link SC2APIProtocol.ActionRawCameraMove.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {SC2APIProtocol.IActionRawCameraMove} message ActionRawCameraMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawCameraMove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.centerWorldSpace != null && message.hasOwnProperty("centerWorldSpace"))
                $root.SC2APIProtocol.Point.encode(message.centerWorldSpace, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ActionRawCameraMove message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionRawCameraMove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {SC2APIProtocol.IActionRawCameraMove} message ActionRawCameraMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawCameraMove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionRawCameraMove message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionRawCameraMove} ActionRawCameraMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawCameraMove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionRawCameraMove();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.centerWorldSpace = $root.SC2APIProtocol.Point.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionRawCameraMove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionRawCameraMove} ActionRawCameraMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawCameraMove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionRawCameraMove message.
         * @function verify
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionRawCameraMove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.centerWorldSpace != null && message.hasOwnProperty("centerWorldSpace")) {
                var error = $root.SC2APIProtocol.Point.verify(message.centerWorldSpace);
                if (error)
                    return "centerWorldSpace." + error;
            }
            return null;
        };
        /**
         * Creates an ActionRawCameraMove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionRawCameraMove} ActionRawCameraMove
         */
        ActionRawCameraMove.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionRawCameraMove)
                return object;
            var message = new $root.SC2APIProtocol.ActionRawCameraMove();
            if (object.centerWorldSpace != null) {
                if (typeof object.centerWorldSpace !== "object")
                    throw TypeError(".SC2APIProtocol.ActionRawCameraMove.centerWorldSpace: object expected");
                message.centerWorldSpace = $root.SC2APIProtocol.Point.fromObject(object.centerWorldSpace);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionRawCameraMove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @static
         * @param {SC2APIProtocol.ActionRawCameraMove} message ActionRawCameraMove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionRawCameraMove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.centerWorldSpace = null;
            if (message.centerWorldSpace != null && message.hasOwnProperty("centerWorldSpace"))
                object.centerWorldSpace = $root.SC2APIProtocol.Point.toObject(message.centerWorldSpace, options);
            return object;
        };
        /**
         * Converts this ActionRawCameraMove to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionRawCameraMove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionRawCameraMove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionRawCameraMove;
    })();
    SC2APIProtocol.ActionRawToggleAutocast = (function () {
        /**
         * Properties of an ActionRawToggleAutocast.
         * @memberof SC2APIProtocol
         * @interface IActionRawToggleAutocast
         * @property {number} [abilityId] ActionRawToggleAutocast abilityId
         * @property {Array.<number|Long>} [unitTags] ActionRawToggleAutocast unitTags
         */
        /**
         * Constructs a new ActionRawToggleAutocast.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionRawToggleAutocast.
         * @constructor
         * @param {SC2APIProtocol.IActionRawToggleAutocast=} [properties] Properties to set
         */
        function ActionRawToggleAutocast(properties) {
            this.unitTags = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionRawToggleAutocast abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @instance
         */
        ActionRawToggleAutocast.prototype.abilityId = 0;
        /**
         * ActionRawToggleAutocast unitTags.
         * @member {Array.<number|Long>}unitTags
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @instance
         */
        ActionRawToggleAutocast.prototype.unitTags = $util.emptyArray;
        /**
         * Creates a new ActionRawToggleAutocast instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionRawToggleAutocast=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionRawToggleAutocast} ActionRawToggleAutocast instance
         */
        ActionRawToggleAutocast.create = function create(properties) {
            return new ActionRawToggleAutocast(properties);
        };
        /**
         * Encodes the specified ActionRawToggleAutocast message. Does not implicitly {@link SC2APIProtocol.ActionRawToggleAutocast.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionRawToggleAutocast} message ActionRawToggleAutocast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawToggleAutocast.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            if (message.unitTags != null && message.unitTags.length)
                for (var i = 0; i < message.unitTags.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.unitTags[i]);
            return writer;
        };
        /**
         * Encodes the specified ActionRawToggleAutocast message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionRawToggleAutocast.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionRawToggleAutocast} message ActionRawToggleAutocast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionRawToggleAutocast.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionRawToggleAutocast message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionRawToggleAutocast} ActionRawToggleAutocast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawToggleAutocast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionRawToggleAutocast();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    case 2:
                        if (!(message.unitTags && message.unitTags.length))
                            message.unitTags = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.unitTags.push(reader.uint64());
                        }
                        else
                            message.unitTags.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionRawToggleAutocast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionRawToggleAutocast} ActionRawToggleAutocast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionRawToggleAutocast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionRawToggleAutocast message.
         * @function verify
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionRawToggleAutocast.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.unitTags != null && message.hasOwnProperty("unitTags")) {
                if (!Array.isArray(message.unitTags))
                    return "unitTags: array expected";
                for (var i = 0; i < message.unitTags.length; ++i)
                    if (!$util.isInteger(message.unitTags[i]) && !(message.unitTags[i] && $util.isInteger(message.unitTags[i].low) && $util.isInteger(message.unitTags[i].high)))
                        return "unitTags: integer|Long[] expected";
            }
            return null;
        };
        /**
         * Creates an ActionRawToggleAutocast message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionRawToggleAutocast} ActionRawToggleAutocast
         */
        ActionRawToggleAutocast.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionRawToggleAutocast)
                return object;
            var message = new $root.SC2APIProtocol.ActionRawToggleAutocast();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            if (object.unitTags) {
                if (!Array.isArray(object.unitTags))
                    throw TypeError(".SC2APIProtocol.ActionRawToggleAutocast.unitTags: array expected");
                message.unitTags = [];
                for (var i = 0; i < object.unitTags.length; ++i)
                    if ($util.Long)
                        (message.unitTags[i] = $util.Long.fromValue(object.unitTags[i])).unsigned = true;
                    else if (typeof object.unitTags[i] === "string")
                        message.unitTags[i] = parseInt(object.unitTags[i], 10);
                    else if (typeof object.unitTags[i] === "number")
                        message.unitTags[i] = object.unitTags[i];
                    else if (typeof object.unitTags[i] === "object")
                        message.unitTags[i] = new $util.LongBits(object.unitTags[i].low >>> 0, object.unitTags[i].high >>> 0).toNumber(true);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionRawToggleAutocast message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @static
         * @param {SC2APIProtocol.ActionRawToggleAutocast} message ActionRawToggleAutocast
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionRawToggleAutocast.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unitTags = [];
            if (options.defaults)
                object.abilityId = 0;
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.unitTags && message.unitTags.length) {
                object.unitTags = [];
                for (var j = 0; j < message.unitTags.length; ++j)
                    if (typeof message.unitTags[j] === "number")
                        object.unitTags[j] = options.longs === String ? String(message.unitTags[j]) : message.unitTags[j];
                    else
                        object.unitTags[j] = options.longs === String ? $util.Long.prototype.toString.call(message.unitTags[j]) : options.longs === Number ? new $util.LongBits(message.unitTags[j].low >>> 0, message.unitTags[j].high >>> 0).toNumber(true) : message.unitTags[j];
            }
            return object;
        };
        /**
         * Converts this ActionRawToggleAutocast to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionRawToggleAutocast
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionRawToggleAutocast.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionRawToggleAutocast;
    })();
    SC2APIProtocol.Event = (function () {
        /**
         * Properties of an Event.
         * @memberof SC2APIProtocol
         * @interface IEvent
         * @property {Array.<number|Long>} [deadUnits] Event deadUnits
         */
        /**
         * Constructs a new Event.
         * @memberof SC2APIProtocol
         * @classdesc Represents an Event.
         * @constructor
         * @param {SC2APIProtocol.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            this.deadUnits = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Event deadUnits.
         * @member {Array.<number|Long>}deadUnits
         * @memberof SC2APIProtocol.Event
         * @instance
         */
        Event.prototype.deadUnits = $util.emptyArray;
        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {SC2APIProtocol.IEvent=} [properties] Properties to set
         * @returns {SC2APIProtocol.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };
        /**
         * Encodes the specified Event message. Does not implicitly {@link SC2APIProtocol.Event.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {SC2APIProtocol.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deadUnits != null && message.deadUnits.length)
                for (var i = 0; i < message.deadUnits.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.deadUnits[i]);
            return writer;
        };
        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link SC2APIProtocol.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {SC2APIProtocol.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.deadUnits && message.deadUnits.length))
                            message.deadUnits = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.deadUnits.push(reader.uint64());
                        }
                        else
                            message.deadUnits.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Event message.
         * @function verify
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deadUnits != null && message.hasOwnProperty("deadUnits")) {
                if (!Array.isArray(message.deadUnits))
                    return "deadUnits: array expected";
                for (var i = 0; i < message.deadUnits.length; ++i)
                    if (!$util.isInteger(message.deadUnits[i]) && !(message.deadUnits[i] && $util.isInteger(message.deadUnits[i].low) && $util.isInteger(message.deadUnits[i].high)))
                        return "deadUnits: integer|Long[] expected";
            }
            return null;
        };
        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Event)
                return object;
            var message = new $root.SC2APIProtocol.Event();
            if (object.deadUnits) {
                if (!Array.isArray(object.deadUnits))
                    throw TypeError(".SC2APIProtocol.Event.deadUnits: array expected");
                message.deadUnits = [];
                for (var i = 0; i < object.deadUnits.length; ++i)
                    if ($util.Long)
                        (message.deadUnits[i] = $util.Long.fromValue(object.deadUnits[i])).unsigned = true;
                    else if (typeof object.deadUnits[i] === "string")
                        message.deadUnits[i] = parseInt(object.deadUnits[i], 10);
                    else if (typeof object.deadUnits[i] === "number")
                        message.deadUnits[i] = object.deadUnits[i];
                    else if (typeof object.deadUnits[i] === "object")
                        message.deadUnits[i] = new $util.LongBits(object.deadUnits[i].low >>> 0, object.deadUnits[i].high >>> 0).toNumber(true);
            }
            return message;
        };
        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Event
         * @static
         * @param {SC2APIProtocol.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.deadUnits = [];
            if (message.deadUnits && message.deadUnits.length) {
                object.deadUnits = [];
                for (var j = 0; j < message.deadUnits.length; ++j)
                    if (typeof message.deadUnits[j] === "number")
                        object.deadUnits[j] = options.longs === String ? String(message.deadUnits[j]) : message.deadUnits[j];
                    else
                        object.deadUnits[j] = options.longs === String ? $util.Long.prototype.toString.call(message.deadUnits[j]) : options.longs === Number ? new $util.LongBits(message.deadUnits[j].low >>> 0, message.deadUnits[j].high >>> 0).toNumber(true) : message.deadUnits[j];
            }
            return object;
        };
        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Event;
    })();
    SC2APIProtocol.Request = (function () {
        /**
         * Properties of a Request.
         * @memberof SC2APIProtocol
         * @interface IRequest
         * @property {SC2APIProtocol.IRequestCreateGame} [createGame] Request createGame
         * @property {SC2APIProtocol.IRequestJoinGame} [joinGame] Request joinGame
         * @property {SC2APIProtocol.IRequestRestartGame} [restartGame] Request restartGame
         * @property {SC2APIProtocol.IRequestStartReplay} [startReplay] Request startReplay
         * @property {SC2APIProtocol.IRequestLeaveGame} [leaveGame] Request leaveGame
         * @property {SC2APIProtocol.IRequestQuickSave} [quickSave] Request quickSave
         * @property {SC2APIProtocol.IRequestQuickLoad} [quickLoad] Request quickLoad
         * @property {SC2APIProtocol.IRequestQuit} [quit] Request quit
         * @property {SC2APIProtocol.IRequestGameInfo} [gameInfo] Request gameInfo
         * @property {SC2APIProtocol.IRequestObservation} [observation] Request observation
         * @property {SC2APIProtocol.IRequestAction} [action] Request action
         * @property {SC2APIProtocol.IRequestStep} [step] Request step
         * @property {SC2APIProtocol.IRequestData} [data] Request data
         * @property {SC2APIProtocol.IRequestQuery} [query] Request query
         * @property {SC2APIProtocol.IRequestSaveReplay} [saveReplay] Request saveReplay
         * @property {SC2APIProtocol.IRequestReplayInfo} [replayInfo] Request replayInfo
         * @property {SC2APIProtocol.IRequestAvailableMaps} [availableMaps] Request availableMaps
         * @property {SC2APIProtocol.IRequestSaveMap} [saveMap] Request saveMap
         * @property {SC2APIProtocol.IRequestPing} [ping] Request ping
         * @property {SC2APIProtocol.IRequestDebug} [debug] Request debug
         */
        /**
         * Constructs a new Request.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Request.
         * @constructor
         * @param {SC2APIProtocol.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Request createGame.
         * @member {(SC2APIProtocol.IRequestCreateGame|null|undefined)}createGame
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.createGame = null;
        /**
         * Request joinGame.
         * @member {(SC2APIProtocol.IRequestJoinGame|null|undefined)}joinGame
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.joinGame = null;
        /**
         * Request restartGame.
         * @member {(SC2APIProtocol.IRequestRestartGame|null|undefined)}restartGame
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.restartGame = null;
        /**
         * Request startReplay.
         * @member {(SC2APIProtocol.IRequestStartReplay|null|undefined)}startReplay
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.startReplay = null;
        /**
         * Request leaveGame.
         * @member {(SC2APIProtocol.IRequestLeaveGame|null|undefined)}leaveGame
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.leaveGame = null;
        /**
         * Request quickSave.
         * @member {(SC2APIProtocol.IRequestQuickSave|null|undefined)}quickSave
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.quickSave = null;
        /**
         * Request quickLoad.
         * @member {(SC2APIProtocol.IRequestQuickLoad|null|undefined)}quickLoad
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.quickLoad = null;
        /**
         * Request quit.
         * @member {(SC2APIProtocol.IRequestQuit|null|undefined)}quit
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.quit = null;
        /**
         * Request gameInfo.
         * @member {(SC2APIProtocol.IRequestGameInfo|null|undefined)}gameInfo
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.gameInfo = null;
        /**
         * Request observation.
         * @member {(SC2APIProtocol.IRequestObservation|null|undefined)}observation
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.observation = null;
        /**
         * Request action.
         * @member {(SC2APIProtocol.IRequestAction|null|undefined)}action
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.action = null;
        /**
         * Request step.
         * @member {(SC2APIProtocol.IRequestStep|null|undefined)}step
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.step = null;
        /**
         * Request data.
         * @member {(SC2APIProtocol.IRequestData|null|undefined)}data
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.data = null;
        /**
         * Request query.
         * @member {(SC2APIProtocol.IRequestQuery|null|undefined)}query
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.query = null;
        /**
         * Request saveReplay.
         * @member {(SC2APIProtocol.IRequestSaveReplay|null|undefined)}saveReplay
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.saveReplay = null;
        /**
         * Request replayInfo.
         * @member {(SC2APIProtocol.IRequestReplayInfo|null|undefined)}replayInfo
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.replayInfo = null;
        /**
         * Request availableMaps.
         * @member {(SC2APIProtocol.IRequestAvailableMaps|null|undefined)}availableMaps
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.availableMaps = null;
        /**
         * Request saveMap.
         * @member {(SC2APIProtocol.IRequestSaveMap|null|undefined)}saveMap
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.saveMap = null;
        /**
         * Request ping.
         * @member {(SC2APIProtocol.IRequestPing|null|undefined)}ping
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.ping = null;
        /**
         * Request debug.
         * @member {(SC2APIProtocol.IRequestDebug|null|undefined)}debug
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Request.prototype.debug = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * Request request.
         * @member {string|undefined} request
         * @memberof SC2APIProtocol.Request
         * @instance
         */
        Object.defineProperty(Request.prototype, "request", {
            get: $util.oneOfGetter($oneOfFields = ["createGame", "joinGame", "restartGame", "startReplay", "leaveGame", "quickSave", "quickLoad", "quit", "gameInfo", "observation", "action", "step", "data", "query", "saveReplay", "replayInfo", "availableMaps", "saveMap", "ping", "debug"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {SC2APIProtocol.IRequest=} [properties] Properties to set
         * @returns {SC2APIProtocol.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };
        /**
         * Encodes the specified Request message. Does not implicitly {@link SC2APIProtocol.Request.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {SC2APIProtocol.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createGame != null && message.hasOwnProperty("createGame"))
                $root.SC2APIProtocol.RequestCreateGame.encode(message.createGame, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.joinGame != null && message.hasOwnProperty("joinGame"))
                $root.SC2APIProtocol.RequestJoinGame.encode(message.joinGame, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.restartGame != null && message.hasOwnProperty("restartGame"))
                $root.SC2APIProtocol.RequestRestartGame.encode(message.restartGame, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.startReplay != null && message.hasOwnProperty("startReplay"))
                $root.SC2APIProtocol.RequestStartReplay.encode(message.startReplay, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame"))
                $root.SC2APIProtocol.RequestLeaveGame.encode(message.leaveGame, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.quickSave != null && message.hasOwnProperty("quickSave"))
                $root.SC2APIProtocol.RequestQuickSave.encode(message.quickSave, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad"))
                $root.SC2APIProtocol.RequestQuickLoad.encode(message.quickLoad, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.quit != null && message.hasOwnProperty("quit"))
                $root.SC2APIProtocol.RequestQuit.encode(message.quit, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo"))
                $root.SC2APIProtocol.RequestGameInfo.encode(message.gameInfo, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.observation != null && message.hasOwnProperty("observation"))
                $root.SC2APIProtocol.RequestObservation.encode(message.observation, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
            if (message.action != null && message.hasOwnProperty("action"))
                $root.SC2APIProtocol.RequestAction.encode(message.action, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
            if (message.step != null && message.hasOwnProperty("step"))
                $root.SC2APIProtocol.RequestStep.encode(message.step, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.SC2APIProtocol.RequestData.encode(message.data, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                $root.SC2APIProtocol.RequestQuery.encode(message.query, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay"))
                $root.SC2APIProtocol.RequestSaveReplay.encode(message.saveReplay, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo"))
                $root.SC2APIProtocol.RequestReplayInfo.encode(message.replayInfo, writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps"))
                $root.SC2APIProtocol.RequestAvailableMaps.encode(message.availableMaps, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
            if (message.saveMap != null && message.hasOwnProperty("saveMap"))
                $root.SC2APIProtocol.RequestSaveMap.encode(message.saveMap, writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
            if (message.ping != null && message.hasOwnProperty("ping"))
                $root.SC2APIProtocol.RequestPing.encode(message.ping, writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
            if (message.debug != null && message.hasOwnProperty("debug"))
                $root.SC2APIProtocol.RequestDebug.encode(message.debug, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link SC2APIProtocol.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {SC2APIProtocol.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.createGame = $root.SC2APIProtocol.RequestCreateGame.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.joinGame = $root.SC2APIProtocol.RequestJoinGame.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.restartGame = $root.SC2APIProtocol.RequestRestartGame.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.startReplay = $root.SC2APIProtocol.RequestStartReplay.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.leaveGame = $root.SC2APIProtocol.RequestLeaveGame.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.quickSave = $root.SC2APIProtocol.RequestQuickSave.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.quickLoad = $root.SC2APIProtocol.RequestQuickLoad.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.quit = $root.SC2APIProtocol.RequestQuit.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.gameInfo = $root.SC2APIProtocol.RequestGameInfo.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.observation = $root.SC2APIProtocol.RequestObservation.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.action = $root.SC2APIProtocol.RequestAction.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.step = $root.SC2APIProtocol.RequestStep.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.data = $root.SC2APIProtocol.RequestData.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.query = $root.SC2APIProtocol.RequestQuery.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.saveReplay = $root.SC2APIProtocol.RequestSaveReplay.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.replayInfo = $root.SC2APIProtocol.RequestReplayInfo.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.availableMaps = $root.SC2APIProtocol.RequestAvailableMaps.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.saveMap = $root.SC2APIProtocol.RequestSaveMap.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.ping = $root.SC2APIProtocol.RequestPing.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.debug = $root.SC2APIProtocol.RequestDebug.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Request message.
         * @function verify
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.createGame != null && message.hasOwnProperty("createGame")) {
                properties.request = 1;
                var error = $root.SC2APIProtocol.RequestCreateGame.verify(message.createGame);
                if (error)
                    return "createGame." + error;
            }
            if (message.joinGame != null && message.hasOwnProperty("joinGame")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestJoinGame.verify(message.joinGame);
                if (error)
                    return "joinGame." + error;
            }
            if (message.restartGame != null && message.hasOwnProperty("restartGame")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestRestartGame.verify(message.restartGame);
                if (error)
                    return "restartGame." + error;
            }
            if (message.startReplay != null && message.hasOwnProperty("startReplay")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestStartReplay.verify(message.startReplay);
                if (error)
                    return "startReplay." + error;
            }
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestLeaveGame.verify(message.leaveGame);
                if (error)
                    return "leaveGame." + error;
            }
            if (message.quickSave != null && message.hasOwnProperty("quickSave")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestQuickSave.verify(message.quickSave);
                if (error)
                    return "quickSave." + error;
            }
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestQuickLoad.verify(message.quickLoad);
                if (error)
                    return "quickLoad." + error;
            }
            if (message.quit != null && message.hasOwnProperty("quit")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestQuit.verify(message.quit);
                if (error)
                    return "quit." + error;
            }
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestGameInfo.verify(message.gameInfo);
                if (error)
                    return "gameInfo." + error;
            }
            if (message.observation != null && message.hasOwnProperty("observation")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestObservation.verify(message.observation);
                if (error)
                    return "observation." + error;
            }
            if (message.action != null && message.hasOwnProperty("action")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestAction.verify(message.action);
                if (error)
                    return "action." + error;
            }
            if (message.step != null && message.hasOwnProperty("step")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestStep.verify(message.step);
                if (error)
                    return "step." + error;
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestData.verify(message.data);
                if (error)
                    return "data." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestSaveReplay.verify(message.saveReplay);
                if (error)
                    return "saveReplay." + error;
            }
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestReplayInfo.verify(message.replayInfo);
                if (error)
                    return "replayInfo." + error;
            }
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestAvailableMaps.verify(message.availableMaps);
                if (error)
                    return "availableMaps." + error;
            }
            if (message.saveMap != null && message.hasOwnProperty("saveMap")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestSaveMap.verify(message.saveMap);
                if (error)
                    return "saveMap." + error;
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestPing.verify(message.ping);
                if (error)
                    return "ping." + error;
            }
            if (message.debug != null && message.hasOwnProperty("debug")) {
                if (properties.request === 1)
                    return "request: multiple values";
                properties.request = 1;
                error = $root.SC2APIProtocol.RequestDebug.verify(message.debug);
                if (error)
                    return "debug." + error;
            }
            return null;
        };
        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Request)
                return object;
            var message = new $root.SC2APIProtocol.Request();
            if (object.createGame != null) {
                if (typeof object.createGame !== "object")
                    throw TypeError(".SC2APIProtocol.Request.createGame: object expected");
                message.createGame = $root.SC2APIProtocol.RequestCreateGame.fromObject(object.createGame);
            }
            if (object.joinGame != null) {
                if (typeof object.joinGame !== "object")
                    throw TypeError(".SC2APIProtocol.Request.joinGame: object expected");
                message.joinGame = $root.SC2APIProtocol.RequestJoinGame.fromObject(object.joinGame);
            }
            if (object.restartGame != null) {
                if (typeof object.restartGame !== "object")
                    throw TypeError(".SC2APIProtocol.Request.restartGame: object expected");
                message.restartGame = $root.SC2APIProtocol.RequestRestartGame.fromObject(object.restartGame);
            }
            if (object.startReplay != null) {
                if (typeof object.startReplay !== "object")
                    throw TypeError(".SC2APIProtocol.Request.startReplay: object expected");
                message.startReplay = $root.SC2APIProtocol.RequestStartReplay.fromObject(object.startReplay);
            }
            if (object.leaveGame != null) {
                if (typeof object.leaveGame !== "object")
                    throw TypeError(".SC2APIProtocol.Request.leaveGame: object expected");
                message.leaveGame = $root.SC2APIProtocol.RequestLeaveGame.fromObject(object.leaveGame);
            }
            if (object.quickSave != null) {
                if (typeof object.quickSave !== "object")
                    throw TypeError(".SC2APIProtocol.Request.quickSave: object expected");
                message.quickSave = $root.SC2APIProtocol.RequestQuickSave.fromObject(object.quickSave);
            }
            if (object.quickLoad != null) {
                if (typeof object.quickLoad !== "object")
                    throw TypeError(".SC2APIProtocol.Request.quickLoad: object expected");
                message.quickLoad = $root.SC2APIProtocol.RequestQuickLoad.fromObject(object.quickLoad);
            }
            if (object.quit != null) {
                if (typeof object.quit !== "object")
                    throw TypeError(".SC2APIProtocol.Request.quit: object expected");
                message.quit = $root.SC2APIProtocol.RequestQuit.fromObject(object.quit);
            }
            if (object.gameInfo != null) {
                if (typeof object.gameInfo !== "object")
                    throw TypeError(".SC2APIProtocol.Request.gameInfo: object expected");
                message.gameInfo = $root.SC2APIProtocol.RequestGameInfo.fromObject(object.gameInfo);
            }
            if (object.observation != null) {
                if (typeof object.observation !== "object")
                    throw TypeError(".SC2APIProtocol.Request.observation: object expected");
                message.observation = $root.SC2APIProtocol.RequestObservation.fromObject(object.observation);
            }
            if (object.action != null) {
                if (typeof object.action !== "object")
                    throw TypeError(".SC2APIProtocol.Request.action: object expected");
                message.action = $root.SC2APIProtocol.RequestAction.fromObject(object.action);
            }
            if (object.step != null) {
                if (typeof object.step !== "object")
                    throw TypeError(".SC2APIProtocol.Request.step: object expected");
                message.step = $root.SC2APIProtocol.RequestStep.fromObject(object.step);
            }
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".SC2APIProtocol.Request.data: object expected");
                message.data = $root.SC2APIProtocol.RequestData.fromObject(object.data);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".SC2APIProtocol.Request.query: object expected");
                message.query = $root.SC2APIProtocol.RequestQuery.fromObject(object.query);
            }
            if (object.saveReplay != null) {
                if (typeof object.saveReplay !== "object")
                    throw TypeError(".SC2APIProtocol.Request.saveReplay: object expected");
                message.saveReplay = $root.SC2APIProtocol.RequestSaveReplay.fromObject(object.saveReplay);
            }
            if (object.replayInfo != null) {
                if (typeof object.replayInfo !== "object")
                    throw TypeError(".SC2APIProtocol.Request.replayInfo: object expected");
                message.replayInfo = $root.SC2APIProtocol.RequestReplayInfo.fromObject(object.replayInfo);
            }
            if (object.availableMaps != null) {
                if (typeof object.availableMaps !== "object")
                    throw TypeError(".SC2APIProtocol.Request.availableMaps: object expected");
                message.availableMaps = $root.SC2APIProtocol.RequestAvailableMaps.fromObject(object.availableMaps);
            }
            if (object.saveMap != null) {
                if (typeof object.saveMap !== "object")
                    throw TypeError(".SC2APIProtocol.Request.saveMap: object expected");
                message.saveMap = $root.SC2APIProtocol.RequestSaveMap.fromObject(object.saveMap);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".SC2APIProtocol.Request.ping: object expected");
                message.ping = $root.SC2APIProtocol.RequestPing.fromObject(object.ping);
            }
            if (object.debug != null) {
                if (typeof object.debug !== "object")
                    throw TypeError(".SC2APIProtocol.Request.debug: object expected");
                message.debug = $root.SC2APIProtocol.RequestDebug.fromObject(object.debug);
            }
            return message;
        };
        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Request
         * @static
         * @param {SC2APIProtocol.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.createGame != null && message.hasOwnProperty("createGame")) {
                object.createGame = $root.SC2APIProtocol.RequestCreateGame.toObject(message.createGame, options);
                if (options.oneofs)
                    object.request = "createGame";
            }
            if (message.joinGame != null && message.hasOwnProperty("joinGame")) {
                object.joinGame = $root.SC2APIProtocol.RequestJoinGame.toObject(message.joinGame, options);
                if (options.oneofs)
                    object.request = "joinGame";
            }
            if (message.restartGame != null && message.hasOwnProperty("restartGame")) {
                object.restartGame = $root.SC2APIProtocol.RequestRestartGame.toObject(message.restartGame, options);
                if (options.oneofs)
                    object.request = "restartGame";
            }
            if (message.startReplay != null && message.hasOwnProperty("startReplay")) {
                object.startReplay = $root.SC2APIProtocol.RequestStartReplay.toObject(message.startReplay, options);
                if (options.oneofs)
                    object.request = "startReplay";
            }
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame")) {
                object.leaveGame = $root.SC2APIProtocol.RequestLeaveGame.toObject(message.leaveGame, options);
                if (options.oneofs)
                    object.request = "leaveGame";
            }
            if (message.quickSave != null && message.hasOwnProperty("quickSave")) {
                object.quickSave = $root.SC2APIProtocol.RequestQuickSave.toObject(message.quickSave, options);
                if (options.oneofs)
                    object.request = "quickSave";
            }
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad")) {
                object.quickLoad = $root.SC2APIProtocol.RequestQuickLoad.toObject(message.quickLoad, options);
                if (options.oneofs)
                    object.request = "quickLoad";
            }
            if (message.quit != null && message.hasOwnProperty("quit")) {
                object.quit = $root.SC2APIProtocol.RequestQuit.toObject(message.quit, options);
                if (options.oneofs)
                    object.request = "quit";
            }
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo")) {
                object.gameInfo = $root.SC2APIProtocol.RequestGameInfo.toObject(message.gameInfo, options);
                if (options.oneofs)
                    object.request = "gameInfo";
            }
            if (message.observation != null && message.hasOwnProperty("observation")) {
                object.observation = $root.SC2APIProtocol.RequestObservation.toObject(message.observation, options);
                if (options.oneofs)
                    object.request = "observation";
            }
            if (message.action != null && message.hasOwnProperty("action")) {
                object.action = $root.SC2APIProtocol.RequestAction.toObject(message.action, options);
                if (options.oneofs)
                    object.request = "action";
            }
            if (message.step != null && message.hasOwnProperty("step")) {
                object.step = $root.SC2APIProtocol.RequestStep.toObject(message.step, options);
                if (options.oneofs)
                    object.request = "step";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                object.data = $root.SC2APIProtocol.RequestData.toObject(message.data, options);
                if (options.oneofs)
                    object.request = "data";
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                object.query = $root.SC2APIProtocol.RequestQuery.toObject(message.query, options);
                if (options.oneofs)
                    object.request = "query";
            }
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay")) {
                object.saveReplay = $root.SC2APIProtocol.RequestSaveReplay.toObject(message.saveReplay, options);
                if (options.oneofs)
                    object.request = "saveReplay";
            }
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo")) {
                object.replayInfo = $root.SC2APIProtocol.RequestReplayInfo.toObject(message.replayInfo, options);
                if (options.oneofs)
                    object.request = "replayInfo";
            }
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps")) {
                object.availableMaps = $root.SC2APIProtocol.RequestAvailableMaps.toObject(message.availableMaps, options);
                if (options.oneofs)
                    object.request = "availableMaps";
            }
            if (message.saveMap != null && message.hasOwnProperty("saveMap")) {
                object.saveMap = $root.SC2APIProtocol.RequestSaveMap.toObject(message.saveMap, options);
                if (options.oneofs)
                    object.request = "saveMap";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.SC2APIProtocol.RequestPing.toObject(message.ping, options);
                if (options.oneofs)
                    object.request = "ping";
            }
            if (message.debug != null && message.hasOwnProperty("debug")) {
                object.debug = $root.SC2APIProtocol.RequestDebug.toObject(message.debug, options);
                if (options.oneofs)
                    object.request = "debug";
            }
            return object;
        };
        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Request;
    })();
    SC2APIProtocol.Response = (function () {
        /**
         * Properties of a Response.
         * @memberof SC2APIProtocol
         * @interface IResponse
         * @property {SC2APIProtocol.IResponseCreateGame} [createGame] Response createGame
         * @property {SC2APIProtocol.IResponseJoinGame} [joinGame] Response joinGame
         * @property {SC2APIProtocol.IResponseRestartGame} [restartGame] Response restartGame
         * @property {SC2APIProtocol.IResponseStartReplay} [startReplay] Response startReplay
         * @property {SC2APIProtocol.IResponseLeaveGame} [leaveGame] Response leaveGame
         * @property {SC2APIProtocol.IResponseQuickSave} [quickSave] Response quickSave
         * @property {SC2APIProtocol.IResponseQuickLoad} [quickLoad] Response quickLoad
         * @property {SC2APIProtocol.IResponseQuit} [quit] Response quit
         * @property {SC2APIProtocol.IResponseGameInfo} [gameInfo] Response gameInfo
         * @property {SC2APIProtocol.IResponseObservation} [observation] Response observation
         * @property {SC2APIProtocol.IResponseAction} [action] Response action
         * @property {SC2APIProtocol.IResponseStep} [step] Response step
         * @property {SC2APIProtocol.IResponseData} [data] Response data
         * @property {SC2APIProtocol.IResponseQuery} [query] Response query
         * @property {SC2APIProtocol.IResponseSaveReplay} [saveReplay] Response saveReplay
         * @property {SC2APIProtocol.IResponseReplayInfo} [replayInfo] Response replayInfo
         * @property {SC2APIProtocol.IResponseAvailableMaps} [availableMaps] Response availableMaps
         * @property {SC2APIProtocol.IResponseSaveMap} [saveMap] Response saveMap
         * @property {SC2APIProtocol.IResponsePing} [ping] Response ping
         * @property {SC2APIProtocol.IResponseDebug} [debug] Response debug
         * @property {Array.<string>} [error] Response error
         * @property {SC2APIProtocol.Status} [status] Response status
         */
        /**
         * Constructs a new Response.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Response.
         * @constructor
         * @param {SC2APIProtocol.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            this.error = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Response createGame.
         * @member {(SC2APIProtocol.IResponseCreateGame|null|undefined)}createGame
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.createGame = null;
        /**
         * Response joinGame.
         * @member {(SC2APIProtocol.IResponseJoinGame|null|undefined)}joinGame
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.joinGame = null;
        /**
         * Response restartGame.
         * @member {(SC2APIProtocol.IResponseRestartGame|null|undefined)}restartGame
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.restartGame = null;
        /**
         * Response startReplay.
         * @member {(SC2APIProtocol.IResponseStartReplay|null|undefined)}startReplay
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.startReplay = null;
        /**
         * Response leaveGame.
         * @member {(SC2APIProtocol.IResponseLeaveGame|null|undefined)}leaveGame
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.leaveGame = null;
        /**
         * Response quickSave.
         * @member {(SC2APIProtocol.IResponseQuickSave|null|undefined)}quickSave
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.quickSave = null;
        /**
         * Response quickLoad.
         * @member {(SC2APIProtocol.IResponseQuickLoad|null|undefined)}quickLoad
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.quickLoad = null;
        /**
         * Response quit.
         * @member {(SC2APIProtocol.IResponseQuit|null|undefined)}quit
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.quit = null;
        /**
         * Response gameInfo.
         * @member {(SC2APIProtocol.IResponseGameInfo|null|undefined)}gameInfo
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.gameInfo = null;
        /**
         * Response observation.
         * @member {(SC2APIProtocol.IResponseObservation|null|undefined)}observation
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.observation = null;
        /**
         * Response action.
         * @member {(SC2APIProtocol.IResponseAction|null|undefined)}action
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.action = null;
        /**
         * Response step.
         * @member {(SC2APIProtocol.IResponseStep|null|undefined)}step
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.step = null;
        /**
         * Response data.
         * @member {(SC2APIProtocol.IResponseData|null|undefined)}data
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.data = null;
        /**
         * Response query.
         * @member {(SC2APIProtocol.IResponseQuery|null|undefined)}query
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.query = null;
        /**
         * Response saveReplay.
         * @member {(SC2APIProtocol.IResponseSaveReplay|null|undefined)}saveReplay
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.saveReplay = null;
        /**
         * Response replayInfo.
         * @member {(SC2APIProtocol.IResponseReplayInfo|null|undefined)}replayInfo
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.replayInfo = null;
        /**
         * Response availableMaps.
         * @member {(SC2APIProtocol.IResponseAvailableMaps|null|undefined)}availableMaps
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.availableMaps = null;
        /**
         * Response saveMap.
         * @member {(SC2APIProtocol.IResponseSaveMap|null|undefined)}saveMap
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.saveMap = null;
        /**
         * Response ping.
         * @member {(SC2APIProtocol.IResponsePing|null|undefined)}ping
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.ping = null;
        /**
         * Response debug.
         * @member {(SC2APIProtocol.IResponseDebug|null|undefined)}debug
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.debug = null;
        /**
         * Response error.
         * @member {Array.<string>}error
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.error = $util.emptyArray;
        /**
         * Response status.
         * @member {SC2APIProtocol.Status}status
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Response.prototype.status = 1;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * Response response.
         * @member {string|undefined} response
         * @memberof SC2APIProtocol.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["createGame", "joinGame", "restartGame", "startReplay", "leaveGame", "quickSave", "quickLoad", "quit", "gameInfo", "observation", "action", "step", "data", "query", "saveReplay", "replayInfo", "availableMaps", "saveMap", "ping", "debug"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {SC2APIProtocol.IResponse=} [properties] Properties to set
         * @returns {SC2APIProtocol.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };
        /**
         * Encodes the specified Response message. Does not implicitly {@link SC2APIProtocol.Response.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {SC2APIProtocol.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createGame != null && message.hasOwnProperty("createGame"))
                $root.SC2APIProtocol.ResponseCreateGame.encode(message.createGame, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.joinGame != null && message.hasOwnProperty("joinGame"))
                $root.SC2APIProtocol.ResponseJoinGame.encode(message.joinGame, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.restartGame != null && message.hasOwnProperty("restartGame"))
                $root.SC2APIProtocol.ResponseRestartGame.encode(message.restartGame, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.startReplay != null && message.hasOwnProperty("startReplay"))
                $root.SC2APIProtocol.ResponseStartReplay.encode(message.startReplay, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame"))
                $root.SC2APIProtocol.ResponseLeaveGame.encode(message.leaveGame, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.quickSave != null && message.hasOwnProperty("quickSave"))
                $root.SC2APIProtocol.ResponseQuickSave.encode(message.quickSave, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad"))
                $root.SC2APIProtocol.ResponseQuickLoad.encode(message.quickLoad, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.quit != null && message.hasOwnProperty("quit"))
                $root.SC2APIProtocol.ResponseQuit.encode(message.quit, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo"))
                $root.SC2APIProtocol.ResponseGameInfo.encode(message.gameInfo, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.observation != null && message.hasOwnProperty("observation"))
                $root.SC2APIProtocol.ResponseObservation.encode(message.observation, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
            if (message.action != null && message.hasOwnProperty("action"))
                $root.SC2APIProtocol.ResponseAction.encode(message.action, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
            if (message.step != null && message.hasOwnProperty("step"))
                $root.SC2APIProtocol.ResponseStep.encode(message.step, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                $root.SC2APIProtocol.ResponseData.encode(message.data, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                $root.SC2APIProtocol.ResponseQuery.encode(message.query, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay"))
                $root.SC2APIProtocol.ResponseSaveReplay.encode(message.saveReplay, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo"))
                $root.SC2APIProtocol.ResponseReplayInfo.encode(message.replayInfo, writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps"))
                $root.SC2APIProtocol.ResponseAvailableMaps.encode(message.availableMaps, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
            if (message.saveMap != null && message.hasOwnProperty("saveMap"))
                $root.SC2APIProtocol.ResponseSaveMap.encode(message.saveMap, writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
            if (message.ping != null && message.hasOwnProperty("ping"))
                $root.SC2APIProtocol.ResponsePing.encode(message.ping, writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
            if (message.debug != null && message.hasOwnProperty("debug"))
                $root.SC2APIProtocol.ResponseDebug.encode(message.debug, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
            if (message.error != null && message.error.length)
                for (var i = 0; i < message.error.length; ++i)
                    writer.uint32(/* id 98, wireType 2 =*/ 786).string(message.error[i]);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 99, wireType 0 =*/ 792).int32(message.status);
            return writer;
        };
        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link SC2APIProtocol.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {SC2APIProtocol.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.createGame = $root.SC2APIProtocol.ResponseCreateGame.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.joinGame = $root.SC2APIProtocol.ResponseJoinGame.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.restartGame = $root.SC2APIProtocol.ResponseRestartGame.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.startReplay = $root.SC2APIProtocol.ResponseStartReplay.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.leaveGame = $root.SC2APIProtocol.ResponseLeaveGame.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.quickSave = $root.SC2APIProtocol.ResponseQuickSave.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.quickLoad = $root.SC2APIProtocol.ResponseQuickLoad.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.quit = $root.SC2APIProtocol.ResponseQuit.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.gameInfo = $root.SC2APIProtocol.ResponseGameInfo.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.observation = $root.SC2APIProtocol.ResponseObservation.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.action = $root.SC2APIProtocol.ResponseAction.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.step = $root.SC2APIProtocol.ResponseStep.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.data = $root.SC2APIProtocol.ResponseData.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.query = $root.SC2APIProtocol.ResponseQuery.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.saveReplay = $root.SC2APIProtocol.ResponseSaveReplay.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.replayInfo = $root.SC2APIProtocol.ResponseReplayInfo.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.availableMaps = $root.SC2APIProtocol.ResponseAvailableMaps.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.saveMap = $root.SC2APIProtocol.ResponseSaveMap.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.ping = $root.SC2APIProtocol.ResponsePing.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.debug = $root.SC2APIProtocol.ResponseDebug.decode(reader, reader.uint32());
                        break;
                    case 98:
                        if (!(message.error && message.error.length))
                            message.error = [];
                        message.error.push(reader.string());
                        break;
                    case 99:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Response message.
         * @function verify
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.createGame != null && message.hasOwnProperty("createGame")) {
                properties.response = 1;
                var error = $root.SC2APIProtocol.ResponseCreateGame.verify(message.createGame);
                if (error)
                    return "createGame." + error;
            }
            if (message.joinGame != null && message.hasOwnProperty("joinGame")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseJoinGame.verify(message.joinGame);
                if (error)
                    return "joinGame." + error;
            }
            if (message.restartGame != null && message.hasOwnProperty("restartGame")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseRestartGame.verify(message.restartGame);
                if (error)
                    return "restartGame." + error;
            }
            if (message.startReplay != null && message.hasOwnProperty("startReplay")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseStartReplay.verify(message.startReplay);
                if (error)
                    return "startReplay." + error;
            }
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseLeaveGame.verify(message.leaveGame);
                if (error)
                    return "leaveGame." + error;
            }
            if (message.quickSave != null && message.hasOwnProperty("quickSave")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseQuickSave.verify(message.quickSave);
                if (error)
                    return "quickSave." + error;
            }
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseQuickLoad.verify(message.quickLoad);
                if (error)
                    return "quickLoad." + error;
            }
            if (message.quit != null && message.hasOwnProperty("quit")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseQuit.verify(message.quit);
                if (error)
                    return "quit." + error;
            }
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseGameInfo.verify(message.gameInfo);
                if (error)
                    return "gameInfo." + error;
            }
            if (message.observation != null && message.hasOwnProperty("observation")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseObservation.verify(message.observation);
                if (error)
                    return "observation." + error;
            }
            if (message.action != null && message.hasOwnProperty("action")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseAction.verify(message.action);
                if (error)
                    return "action." + error;
            }
            if (message.step != null && message.hasOwnProperty("step")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseStep.verify(message.step);
                if (error)
                    return "step." + error;
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseData.verify(message.data);
                if (error)
                    return "data." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseSaveReplay.verify(message.saveReplay);
                if (error)
                    return "saveReplay." + error;
            }
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseReplayInfo.verify(message.replayInfo);
                if (error)
                    return "replayInfo." + error;
            }
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseAvailableMaps.verify(message.availableMaps);
                if (error)
                    return "availableMaps." + error;
            }
            if (message.saveMap != null && message.hasOwnProperty("saveMap")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseSaveMap.verify(message.saveMap);
                if (error)
                    return "saveMap." + error;
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponsePing.verify(message.ping);
                if (error)
                    return "ping." + error;
            }
            if (message.debug != null && message.hasOwnProperty("debug")) {
                if (properties.response === 1)
                    return "response: multiple values";
                properties.response = 1;
                error = $root.SC2APIProtocol.ResponseDebug.verify(message.debug);
                if (error)
                    return "debug." + error;
            }
            if (message.error != null && message.hasOwnProperty("error")) {
                if (!Array.isArray(message.error))
                    return "error: array expected";
                for (var i = 0; i < message.error.length; ++i)
                    if (!$util.isString(message.error[i]))
                        return "error: string[] expected";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 99:
                        break;
                }
            return null;
        };
        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Response)
                return object;
            var message = new $root.SC2APIProtocol.Response();
            if (object.createGame != null) {
                if (typeof object.createGame !== "object")
                    throw TypeError(".SC2APIProtocol.Response.createGame: object expected");
                message.createGame = $root.SC2APIProtocol.ResponseCreateGame.fromObject(object.createGame);
            }
            if (object.joinGame != null) {
                if (typeof object.joinGame !== "object")
                    throw TypeError(".SC2APIProtocol.Response.joinGame: object expected");
                message.joinGame = $root.SC2APIProtocol.ResponseJoinGame.fromObject(object.joinGame);
            }
            if (object.restartGame != null) {
                if (typeof object.restartGame !== "object")
                    throw TypeError(".SC2APIProtocol.Response.restartGame: object expected");
                message.restartGame = $root.SC2APIProtocol.ResponseRestartGame.fromObject(object.restartGame);
            }
            if (object.startReplay != null) {
                if (typeof object.startReplay !== "object")
                    throw TypeError(".SC2APIProtocol.Response.startReplay: object expected");
                message.startReplay = $root.SC2APIProtocol.ResponseStartReplay.fromObject(object.startReplay);
            }
            if (object.leaveGame != null) {
                if (typeof object.leaveGame !== "object")
                    throw TypeError(".SC2APIProtocol.Response.leaveGame: object expected");
                message.leaveGame = $root.SC2APIProtocol.ResponseLeaveGame.fromObject(object.leaveGame);
            }
            if (object.quickSave != null) {
                if (typeof object.quickSave !== "object")
                    throw TypeError(".SC2APIProtocol.Response.quickSave: object expected");
                message.quickSave = $root.SC2APIProtocol.ResponseQuickSave.fromObject(object.quickSave);
            }
            if (object.quickLoad != null) {
                if (typeof object.quickLoad !== "object")
                    throw TypeError(".SC2APIProtocol.Response.quickLoad: object expected");
                message.quickLoad = $root.SC2APIProtocol.ResponseQuickLoad.fromObject(object.quickLoad);
            }
            if (object.quit != null) {
                if (typeof object.quit !== "object")
                    throw TypeError(".SC2APIProtocol.Response.quit: object expected");
                message.quit = $root.SC2APIProtocol.ResponseQuit.fromObject(object.quit);
            }
            if (object.gameInfo != null) {
                if (typeof object.gameInfo !== "object")
                    throw TypeError(".SC2APIProtocol.Response.gameInfo: object expected");
                message.gameInfo = $root.SC2APIProtocol.ResponseGameInfo.fromObject(object.gameInfo);
            }
            if (object.observation != null) {
                if (typeof object.observation !== "object")
                    throw TypeError(".SC2APIProtocol.Response.observation: object expected");
                message.observation = $root.SC2APIProtocol.ResponseObservation.fromObject(object.observation);
            }
            if (object.action != null) {
                if (typeof object.action !== "object")
                    throw TypeError(".SC2APIProtocol.Response.action: object expected");
                message.action = $root.SC2APIProtocol.ResponseAction.fromObject(object.action);
            }
            if (object.step != null) {
                if (typeof object.step !== "object")
                    throw TypeError(".SC2APIProtocol.Response.step: object expected");
                message.step = $root.SC2APIProtocol.ResponseStep.fromObject(object.step);
            }
            if (object.data != null) {
                if (typeof object.data !== "object")
                    throw TypeError(".SC2APIProtocol.Response.data: object expected");
                message.data = $root.SC2APIProtocol.ResponseData.fromObject(object.data);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".SC2APIProtocol.Response.query: object expected");
                message.query = $root.SC2APIProtocol.ResponseQuery.fromObject(object.query);
            }
            if (object.saveReplay != null) {
                if (typeof object.saveReplay !== "object")
                    throw TypeError(".SC2APIProtocol.Response.saveReplay: object expected");
                message.saveReplay = $root.SC2APIProtocol.ResponseSaveReplay.fromObject(object.saveReplay);
            }
            if (object.replayInfo != null) {
                if (typeof object.replayInfo !== "object")
                    throw TypeError(".SC2APIProtocol.Response.replayInfo: object expected");
                message.replayInfo = $root.SC2APIProtocol.ResponseReplayInfo.fromObject(object.replayInfo);
            }
            if (object.availableMaps != null) {
                if (typeof object.availableMaps !== "object")
                    throw TypeError(".SC2APIProtocol.Response.availableMaps: object expected");
                message.availableMaps = $root.SC2APIProtocol.ResponseAvailableMaps.fromObject(object.availableMaps);
            }
            if (object.saveMap != null) {
                if (typeof object.saveMap !== "object")
                    throw TypeError(".SC2APIProtocol.Response.saveMap: object expected");
                message.saveMap = $root.SC2APIProtocol.ResponseSaveMap.fromObject(object.saveMap);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".SC2APIProtocol.Response.ping: object expected");
                message.ping = $root.SC2APIProtocol.ResponsePing.fromObject(object.ping);
            }
            if (object.debug != null) {
                if (typeof object.debug !== "object")
                    throw TypeError(".SC2APIProtocol.Response.debug: object expected");
                message.debug = $root.SC2APIProtocol.ResponseDebug.fromObject(object.debug);
            }
            if (object.error) {
                if (!Array.isArray(object.error))
                    throw TypeError(".SC2APIProtocol.Response.error: array expected");
                message.error = [];
                for (var i = 0; i < object.error.length; ++i)
                    message.error[i] = String(object.error[i]);
            }
            switch (object.status) {
                case "launched":
                case 1:
                    message.status = 1;
                    break;
                case "init_game":
                case 2:
                    message.status = 2;
                    break;
                case "in_game":
                case 3:
                    message.status = 3;
                    break;
                case "in_replay":
                case 4:
                    message.status = 4;
                    break;
                case "ended":
                case 5:
                    message.status = 5;
                    break;
                case "quit":
                case 6:
                    message.status = 6;
                    break;
                case "unknown":
                case 99:
                    message.status = 99;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Response
         * @static
         * @param {SC2APIProtocol.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.error = [];
            if (options.defaults)
                object.status = options.enums === String ? "launched" : 1;
            if (message.createGame != null && message.hasOwnProperty("createGame")) {
                object.createGame = $root.SC2APIProtocol.ResponseCreateGame.toObject(message.createGame, options);
                if (options.oneofs)
                    object.response = "createGame";
            }
            if (message.joinGame != null && message.hasOwnProperty("joinGame")) {
                object.joinGame = $root.SC2APIProtocol.ResponseJoinGame.toObject(message.joinGame, options);
                if (options.oneofs)
                    object.response = "joinGame";
            }
            if (message.restartGame != null && message.hasOwnProperty("restartGame")) {
                object.restartGame = $root.SC2APIProtocol.ResponseRestartGame.toObject(message.restartGame, options);
                if (options.oneofs)
                    object.response = "restartGame";
            }
            if (message.startReplay != null && message.hasOwnProperty("startReplay")) {
                object.startReplay = $root.SC2APIProtocol.ResponseStartReplay.toObject(message.startReplay, options);
                if (options.oneofs)
                    object.response = "startReplay";
            }
            if (message.leaveGame != null && message.hasOwnProperty("leaveGame")) {
                object.leaveGame = $root.SC2APIProtocol.ResponseLeaveGame.toObject(message.leaveGame, options);
                if (options.oneofs)
                    object.response = "leaveGame";
            }
            if (message.quickSave != null && message.hasOwnProperty("quickSave")) {
                object.quickSave = $root.SC2APIProtocol.ResponseQuickSave.toObject(message.quickSave, options);
                if (options.oneofs)
                    object.response = "quickSave";
            }
            if (message.quickLoad != null && message.hasOwnProperty("quickLoad")) {
                object.quickLoad = $root.SC2APIProtocol.ResponseQuickLoad.toObject(message.quickLoad, options);
                if (options.oneofs)
                    object.response = "quickLoad";
            }
            if (message.quit != null && message.hasOwnProperty("quit")) {
                object.quit = $root.SC2APIProtocol.ResponseQuit.toObject(message.quit, options);
                if (options.oneofs)
                    object.response = "quit";
            }
            if (message.gameInfo != null && message.hasOwnProperty("gameInfo")) {
                object.gameInfo = $root.SC2APIProtocol.ResponseGameInfo.toObject(message.gameInfo, options);
                if (options.oneofs)
                    object.response = "gameInfo";
            }
            if (message.observation != null && message.hasOwnProperty("observation")) {
                object.observation = $root.SC2APIProtocol.ResponseObservation.toObject(message.observation, options);
                if (options.oneofs)
                    object.response = "observation";
            }
            if (message.action != null && message.hasOwnProperty("action")) {
                object.action = $root.SC2APIProtocol.ResponseAction.toObject(message.action, options);
                if (options.oneofs)
                    object.response = "action";
            }
            if (message.step != null && message.hasOwnProperty("step")) {
                object.step = $root.SC2APIProtocol.ResponseStep.toObject(message.step, options);
                if (options.oneofs)
                    object.response = "step";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
                object.data = $root.SC2APIProtocol.ResponseData.toObject(message.data, options);
                if (options.oneofs)
                    object.response = "data";
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                object.query = $root.SC2APIProtocol.ResponseQuery.toObject(message.query, options);
                if (options.oneofs)
                    object.response = "query";
            }
            if (message.saveReplay != null && message.hasOwnProperty("saveReplay")) {
                object.saveReplay = $root.SC2APIProtocol.ResponseSaveReplay.toObject(message.saveReplay, options);
                if (options.oneofs)
                    object.response = "saveReplay";
            }
            if (message.replayInfo != null && message.hasOwnProperty("replayInfo")) {
                object.replayInfo = $root.SC2APIProtocol.ResponseReplayInfo.toObject(message.replayInfo, options);
                if (options.oneofs)
                    object.response = "replayInfo";
            }
            if (message.availableMaps != null && message.hasOwnProperty("availableMaps")) {
                object.availableMaps = $root.SC2APIProtocol.ResponseAvailableMaps.toObject(message.availableMaps, options);
                if (options.oneofs)
                    object.response = "availableMaps";
            }
            if (message.saveMap != null && message.hasOwnProperty("saveMap")) {
                object.saveMap = $root.SC2APIProtocol.ResponseSaveMap.toObject(message.saveMap, options);
                if (options.oneofs)
                    object.response = "saveMap";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.SC2APIProtocol.ResponsePing.toObject(message.ping, options);
                if (options.oneofs)
                    object.response = "ping";
            }
            if (message.debug != null && message.hasOwnProperty("debug")) {
                object.debug = $root.SC2APIProtocol.ResponseDebug.toObject(message.debug, options);
                if (options.oneofs)
                    object.response = "debug";
            }
            if (message.error && message.error.length) {
                object.error = [];
                for (var j = 0; j < message.error.length; ++j)
                    object.error[j] = message.error[j];
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.SC2APIProtocol.Status[message.status] : message.status;
            return object;
        };
        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Response;
    })();
    /**
     * Status enum.
     * @enum {string}
     * @property {number} launched=1 launched value
     * @property {number} init_game=2 init_game value
     * @property {number} in_game=3 in_game value
     * @property {number} in_replay=4 in_replay value
     * @property {number} ended=5 ended value
     * @property {number} quit=6 quit value
     * @property {number} unknown=99 unknown value
     */
    SC2APIProtocol.Status = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "launched"] = 1;
        values[valuesById[2] = "init_game"] = 2;
        values[valuesById[3] = "in_game"] = 3;
        values[valuesById[4] = "in_replay"] = 4;
        values[valuesById[5] = "ended"] = 5;
        values[valuesById[6] = "quit"] = 6;
        values[valuesById[99] = "unknown"] = 99;
        return values;
    })();
    SC2APIProtocol.RequestCreateGame = (function () {
        /**
         * Properties of a RequestCreateGame.
         * @memberof SC2APIProtocol
         * @interface IRequestCreateGame
         * @property {SC2APIProtocol.ILocalMap} [localMap] RequestCreateGame localMap
         * @property {string} [battlenetMapName] RequestCreateGame battlenetMapName
         * @property {Array.<SC2APIProtocol.IPlayerSetup>} [playerSetup] RequestCreateGame playerSetup
         * @property {boolean} [disableFog] RequestCreateGame disableFog
         * @property {number} [randomSeed] RequestCreateGame randomSeed
         * @property {boolean} [realtime] RequestCreateGame realtime
         */
        /**
         * Constructs a new RequestCreateGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestCreateGame.
         * @constructor
         * @param {SC2APIProtocol.IRequestCreateGame=} [properties] Properties to set
         */
        function RequestCreateGame(properties) {
            this.playerSetup = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestCreateGame localMap.
         * @member {(SC2APIProtocol.ILocalMap|null|undefined)}localMap
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.localMap = null;
        /**
         * RequestCreateGame battlenetMapName.
         * @member {string}battlenetMapName
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.battlenetMapName = "";
        /**
         * RequestCreateGame playerSetup.
         * @member {Array.<SC2APIProtocol.IPlayerSetup>}playerSetup
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.playerSetup = $util.emptyArray;
        /**
         * RequestCreateGame disableFog.
         * @member {boolean}disableFog
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.disableFog = false;
        /**
         * RequestCreateGame randomSeed.
         * @member {number}randomSeed
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.randomSeed = 0;
        /**
         * RequestCreateGame realtime.
         * @member {boolean}realtime
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        RequestCreateGame.prototype.realtime = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestCreateGame Map.
         * @member {string|undefined} Map
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         */
        Object.defineProperty(RequestCreateGame.prototype, "Map", {
            get: $util.oneOfGetter($oneOfFields = ["localMap", "battlenetMapName"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestCreateGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {SC2APIProtocol.IRequestCreateGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestCreateGame} RequestCreateGame instance
         */
        RequestCreateGame.create = function create(properties) {
            return new RequestCreateGame(properties);
        };
        /**
         * Encodes the specified RequestCreateGame message. Does not implicitly {@link SC2APIProtocol.RequestCreateGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {SC2APIProtocol.IRequestCreateGame} message RequestCreateGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCreateGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.localMap != null && message.hasOwnProperty("localMap"))
                $root.SC2APIProtocol.LocalMap.encode(message.localMap, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.battlenetMapName != null && message.hasOwnProperty("battlenetMapName"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.battlenetMapName);
            if (message.playerSetup != null && message.playerSetup.length)
                for (var i = 0; i < message.playerSetup.length; ++i)
                    $root.SC2APIProtocol.PlayerSetup.encode(message.playerSetup[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.disableFog);
            if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.randomSeed);
            if (message.realtime != null && message.hasOwnProperty("realtime"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.realtime);
            return writer;
        };
        /**
         * Encodes the specified RequestCreateGame message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestCreateGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {SC2APIProtocol.IRequestCreateGame} message RequestCreateGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestCreateGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestCreateGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestCreateGame} RequestCreateGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCreateGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestCreateGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.localMap = $root.SC2APIProtocol.LocalMap.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.battlenetMapName = reader.string();
                        break;
                    case 3:
                        if (!(message.playerSetup && message.playerSetup.length))
                            message.playerSetup = [];
                        message.playerSetup.push($root.SC2APIProtocol.PlayerSetup.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.disableFog = reader.bool();
                        break;
                    case 5:
                        message.randomSeed = reader.uint32();
                        break;
                    case 6:
                        message.realtime = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestCreateGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestCreateGame} RequestCreateGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestCreateGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestCreateGame message.
         * @function verify
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestCreateGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.localMap != null && message.hasOwnProperty("localMap")) {
                properties.Map = 1;
                var error = $root.SC2APIProtocol.LocalMap.verify(message.localMap);
                if (error)
                    return "localMap." + error;
            }
            if (message.battlenetMapName != null && message.hasOwnProperty("battlenetMapName")) {
                if (properties.Map === 1)
                    return "Map: multiple values";
                properties.Map = 1;
                if (!$util.isString(message.battlenetMapName))
                    return "battlenetMapName: string expected";
            }
            if (message.playerSetup != null && message.hasOwnProperty("playerSetup")) {
                if (!Array.isArray(message.playerSetup))
                    return "playerSetup: array expected";
                for (var i = 0; i < message.playerSetup.length; ++i) {
                    error = $root.SC2APIProtocol.PlayerSetup.verify(message.playerSetup[i]);
                    if (error)
                        return "playerSetup." + error;
                }
            }
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                if (typeof message.disableFog !== "boolean")
                    return "disableFog: boolean expected";
            if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                if (!$util.isInteger(message.randomSeed))
                    return "randomSeed: integer expected";
            if (message.realtime != null && message.hasOwnProperty("realtime"))
                if (typeof message.realtime !== "boolean")
                    return "realtime: boolean expected";
            return null;
        };
        /**
         * Creates a RequestCreateGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestCreateGame} RequestCreateGame
         */
        RequestCreateGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestCreateGame)
                return object;
            var message = new $root.SC2APIProtocol.RequestCreateGame();
            if (object.localMap != null) {
                if (typeof object.localMap !== "object")
                    throw TypeError(".SC2APIProtocol.RequestCreateGame.localMap: object expected");
                message.localMap = $root.SC2APIProtocol.LocalMap.fromObject(object.localMap);
            }
            if (object.battlenetMapName != null)
                message.battlenetMapName = String(object.battlenetMapName);
            if (object.playerSetup) {
                if (!Array.isArray(object.playerSetup))
                    throw TypeError(".SC2APIProtocol.RequestCreateGame.playerSetup: array expected");
                message.playerSetup = [];
                for (var i = 0; i < object.playerSetup.length; ++i) {
                    if (typeof object.playerSetup[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestCreateGame.playerSetup: object expected");
                    message.playerSetup[i] = $root.SC2APIProtocol.PlayerSetup.fromObject(object.playerSetup[i]);
                }
            }
            if (object.disableFog != null)
                message.disableFog = Boolean(object.disableFog);
            if (object.randomSeed != null)
                message.randomSeed = object.randomSeed >>> 0;
            if (object.realtime != null)
                message.realtime = Boolean(object.realtime);
            return message;
        };
        /**
         * Creates a plain object from a RequestCreateGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestCreateGame
         * @static
         * @param {SC2APIProtocol.RequestCreateGame} message RequestCreateGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestCreateGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.playerSetup = [];
            if (options.defaults) {
                object.disableFog = false;
                object.randomSeed = 0;
                object.realtime = false;
            }
            if (message.localMap != null && message.hasOwnProperty("localMap")) {
                object.localMap = $root.SC2APIProtocol.LocalMap.toObject(message.localMap, options);
                if (options.oneofs)
                    object.Map = "localMap";
            }
            if (message.battlenetMapName != null && message.hasOwnProperty("battlenetMapName")) {
                object.battlenetMapName = message.battlenetMapName;
                if (options.oneofs)
                    object.Map = "battlenetMapName";
            }
            if (message.playerSetup && message.playerSetup.length) {
                object.playerSetup = [];
                for (var j = 0; j < message.playerSetup.length; ++j)
                    object.playerSetup[j] = $root.SC2APIProtocol.PlayerSetup.toObject(message.playerSetup[j], options);
            }
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                object.disableFog = message.disableFog;
            if (message.randomSeed != null && message.hasOwnProperty("randomSeed"))
                object.randomSeed = message.randomSeed;
            if (message.realtime != null && message.hasOwnProperty("realtime"))
                object.realtime = message.realtime;
            return object;
        };
        /**
         * Converts this RequestCreateGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestCreateGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestCreateGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestCreateGame;
    })();
    SC2APIProtocol.LocalMap = (function () {
        /**
         * Properties of a LocalMap.
         * @memberof SC2APIProtocol
         * @interface ILocalMap
         * @property {string} [mapPath] LocalMap mapPath
         * @property {Uint8Array} [mapData] LocalMap mapData
         */
        /**
         * Constructs a new LocalMap.
         * @memberof SC2APIProtocol
         * @classdesc Represents a LocalMap.
         * @constructor
         * @param {SC2APIProtocol.ILocalMap=} [properties] Properties to set
         */
        function LocalMap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * LocalMap mapPath.
         * @member {string}mapPath
         * @memberof SC2APIProtocol.LocalMap
         * @instance
         */
        LocalMap.prototype.mapPath = "";
        /**
         * LocalMap mapData.
         * @member {Uint8Array}mapData
         * @memberof SC2APIProtocol.LocalMap
         * @instance
         */
        LocalMap.prototype.mapData = $util.newBuffer([]);
        /**
         * Creates a new LocalMap instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {SC2APIProtocol.ILocalMap=} [properties] Properties to set
         * @returns {SC2APIProtocol.LocalMap} LocalMap instance
         */
        LocalMap.create = function create(properties) {
            return new LocalMap(properties);
        };
        /**
         * Encodes the specified LocalMap message. Does not implicitly {@link SC2APIProtocol.LocalMap.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {SC2APIProtocol.ILocalMap} message LocalMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mapPath);
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.mapData);
            return writer;
        };
        /**
         * Encodes the specified LocalMap message, length delimited. Does not implicitly {@link SC2APIProtocol.LocalMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {SC2APIProtocol.ILocalMap} message LocalMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a LocalMap message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.LocalMap} LocalMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.LocalMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapPath = reader.string();
                        break;
                    case 7:
                        message.mapData = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a LocalMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.LocalMap} LocalMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a LocalMap message.
         * @function verify
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocalMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                if (!$util.isString(message.mapPath))
                    return "mapPath: string expected";
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                if (!(message.mapData && typeof message.mapData.length === "number" || $util.isString(message.mapData)))
                    return "mapData: buffer expected";
            return null;
        };
        /**
         * Creates a LocalMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.LocalMap} LocalMap
         */
        LocalMap.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.LocalMap)
                return object;
            var message = new $root.SC2APIProtocol.LocalMap();
            if (object.mapPath != null)
                message.mapPath = String(object.mapPath);
            if (object.mapData != null)
                if (typeof object.mapData === "string")
                    $util.base64.decode(object.mapData, message.mapData = $util.newBuffer($util.base64.length(object.mapData)), 0);
                else if (object.mapData.length)
                    message.mapData = object.mapData;
            return message;
        };
        /**
         * Creates a plain object from a LocalMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.LocalMap
         * @static
         * @param {SC2APIProtocol.LocalMap} message LocalMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocalMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mapPath = "";
                object.mapData = options.bytes === String ? "" : [];
            }
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                object.mapPath = message.mapPath;
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                object.mapData = options.bytes === String ? $util.base64.encode(message.mapData, 0, message.mapData.length) : options.bytes === Array ? Array.prototype.slice.call(message.mapData) : message.mapData;
            return object;
        };
        /**
         * Converts this LocalMap to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.LocalMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocalMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LocalMap;
    })();
    SC2APIProtocol.ResponseCreateGame = (function () {
        /**
         * Properties of a ResponseCreateGame.
         * @memberof SC2APIProtocol
         * @interface IResponseCreateGame
         * @property {SC2APIProtocol.ResponseCreateGame.Error} [error] ResponseCreateGame error
         * @property {string} [errorDetails] ResponseCreateGame errorDetails
         */
        /**
         * Constructs a new ResponseCreateGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseCreateGame.
         * @constructor
         * @param {SC2APIProtocol.IResponseCreateGame=} [properties] Properties to set
         */
        function ResponseCreateGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseCreateGame error.
         * @member {SC2APIProtocol.ResponseCreateGame.Error}error
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @instance
         */
        ResponseCreateGame.prototype.error = 1;
        /**
         * ResponseCreateGame errorDetails.
         * @member {string}errorDetails
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @instance
         */
        ResponseCreateGame.prototype.errorDetails = "";
        /**
         * Creates a new ResponseCreateGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {SC2APIProtocol.IResponseCreateGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseCreateGame} ResponseCreateGame instance
         */
        ResponseCreateGame.create = function create(properties) {
            return new ResponseCreateGame(properties);
        };
        /**
         * Encodes the specified ResponseCreateGame message. Does not implicitly {@link SC2APIProtocol.ResponseCreateGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {SC2APIProtocol.IResponseCreateGame} message ResponseCreateGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCreateGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.error);
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorDetails);
            return writer;
        };
        /**
         * Encodes the specified ResponseCreateGame message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseCreateGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {SC2APIProtocol.IResponseCreateGame} message ResponseCreateGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseCreateGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseCreateGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseCreateGame} ResponseCreateGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCreateGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseCreateGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.error = reader.int32();
                        break;
                    case 2:
                        message.errorDetails = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseCreateGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseCreateGame} ResponseCreateGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseCreateGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseCreateGame message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseCreateGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                }
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                if (!$util.isString(message.errorDetails))
                    return "errorDetails: string expected";
            return null;
        };
        /**
         * Creates a ResponseCreateGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseCreateGame} ResponseCreateGame
         */
        ResponseCreateGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseCreateGame)
                return object;
            var message = new $root.SC2APIProtocol.ResponseCreateGame();
            switch (object.error) {
                case "MissingMap":
                case 1:
                    message.error = 1;
                    break;
                case "InvalidMapPath":
                case 2:
                    message.error = 2;
                    break;
                case "InvalidMapData":
                case 3:
                    message.error = 3;
                    break;
                case "InvalidMapName":
                case 4:
                    message.error = 4;
                    break;
                case "InvalidMapHandle":
                case 5:
                    message.error = 5;
                    break;
                case "MissingPlayerSetup":
                case 6:
                    message.error = 6;
                    break;
                case "InvalidPlayerSetup":
                case 7:
                    message.error = 7;
                    break;
                case "MultiplayerUnsupported":
                case 8:
                    message.error = 8;
                    break;
            }
            if (object.errorDetails != null)
                message.errorDetails = String(object.errorDetails);
            return message;
        };
        /**
         * Creates a plain object from a ResponseCreateGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @static
         * @param {SC2APIProtocol.ResponseCreateGame} message ResponseCreateGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseCreateGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = options.enums === String ? "MissingMap" : 1;
                object.errorDetails = "";
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseCreateGame.Error[message.error] : message.error;
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                object.errorDetails = message.errorDetails;
            return object;
        };
        /**
         * Converts this ResponseCreateGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseCreateGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseCreateGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} MissingMap=1 MissingMap value
         * @property {number} InvalidMapPath=2 InvalidMapPath value
         * @property {number} InvalidMapData=3 InvalidMapData value
         * @property {number} InvalidMapName=4 InvalidMapName value
         * @property {number} InvalidMapHandle=5 InvalidMapHandle value
         * @property {number} MissingPlayerSetup=6 MissingPlayerSetup value
         * @property {number} InvalidPlayerSetup=7 InvalidPlayerSetup value
         * @property {number} MultiplayerUnsupported=8 MultiplayerUnsupported value
         */
        ResponseCreateGame.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MissingMap"] = 1;
            values[valuesById[2] = "InvalidMapPath"] = 2;
            values[valuesById[3] = "InvalidMapData"] = 3;
            values[valuesById[4] = "InvalidMapName"] = 4;
            values[valuesById[5] = "InvalidMapHandle"] = 5;
            values[valuesById[6] = "MissingPlayerSetup"] = 6;
            values[valuesById[7] = "InvalidPlayerSetup"] = 7;
            values[valuesById[8] = "MultiplayerUnsupported"] = 8;
            return values;
        })();
        return ResponseCreateGame;
    })();
    SC2APIProtocol.RequestJoinGame = (function () {
        /**
         * Properties of a RequestJoinGame.
         * @memberof SC2APIProtocol
         * @interface IRequestJoinGame
         * @property {SC2APIProtocol.Race} [race] RequestJoinGame race
         * @property {number} [observedPlayerId] RequestJoinGame observedPlayerId
         * @property {SC2APIProtocol.IInterfaceOptions} [options] RequestJoinGame options
         * @property {SC2APIProtocol.IPortSet} [serverPorts] RequestJoinGame serverPorts
         * @property {Array.<SC2APIProtocol.IPortSet>} [clientPorts] RequestJoinGame clientPorts
         * @property {number} [sharedPort] RequestJoinGame sharedPort
         */
        /**
         * Constructs a new RequestJoinGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestJoinGame.
         * @constructor
         * @param {SC2APIProtocol.IRequestJoinGame=} [properties] Properties to set
         */
        function RequestJoinGame(properties) {
            this.clientPorts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestJoinGame race.
         * @member {SC2APIProtocol.Race}race
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.race = 0;
        /**
         * RequestJoinGame observedPlayerId.
         * @member {number}observedPlayerId
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.observedPlayerId = 0;
        /**
         * RequestJoinGame options.
         * @member {(SC2APIProtocol.IInterfaceOptions|null|undefined)}options
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.options = null;
        /**
         * RequestJoinGame serverPorts.
         * @member {(SC2APIProtocol.IPortSet|null|undefined)}serverPorts
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.serverPorts = null;
        /**
         * RequestJoinGame clientPorts.
         * @member {Array.<SC2APIProtocol.IPortSet>}clientPorts
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.clientPorts = $util.emptyArray;
        /**
         * RequestJoinGame sharedPort.
         * @member {number}sharedPort
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        RequestJoinGame.prototype.sharedPort = 0;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestJoinGame participation.
         * @member {string|undefined} participation
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         */
        Object.defineProperty(RequestJoinGame.prototype, "participation", {
            get: $util.oneOfGetter($oneOfFields = ["race", "observedPlayerId"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestJoinGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {SC2APIProtocol.IRequestJoinGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestJoinGame} RequestJoinGame instance
         */
        RequestJoinGame.create = function create(properties) {
            return new RequestJoinGame(properties);
        };
        /**
         * Encodes the specified RequestJoinGame message. Does not implicitly {@link SC2APIProtocol.RequestJoinGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {SC2APIProtocol.IRequestJoinGame} message RequestJoinGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestJoinGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.race != null && message.hasOwnProperty("race"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.race);
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.observedPlayerId);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.SC2APIProtocol.InterfaceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.serverPorts != null && message.hasOwnProperty("serverPorts"))
                $root.SC2APIProtocol.PortSet.encode(message.serverPorts, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.clientPorts != null && message.clientPorts.length)
                for (var i = 0; i < message.clientPorts.length; ++i)
                    $root.SC2APIProtocol.PortSet.encode(message.clientPorts[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.sharedPort != null && message.hasOwnProperty("sharedPort"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.sharedPort);
            return writer;
        };
        /**
         * Encodes the specified RequestJoinGame message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestJoinGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {SC2APIProtocol.IRequestJoinGame} message RequestJoinGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestJoinGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestJoinGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestJoinGame} RequestJoinGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestJoinGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestJoinGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.race = reader.int32();
                        break;
                    case 2:
                        message.observedPlayerId = reader.uint32();
                        break;
                    case 3:
                        message.options = $root.SC2APIProtocol.InterfaceOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.serverPorts = $root.SC2APIProtocol.PortSet.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.clientPorts && message.clientPorts.length))
                            message.clientPorts = [];
                        message.clientPorts.push($root.SC2APIProtocol.PortSet.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.sharedPort = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestJoinGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestJoinGame} RequestJoinGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestJoinGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestJoinGame message.
         * @function verify
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestJoinGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.race != null && message.hasOwnProperty("race")) {
                properties.participation = 1;
                switch (message.race) {
                    default:
                        return "race: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            }
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId")) {
                if (properties.participation === 1)
                    return "participation: multiple values";
                properties.participation = 1;
                if (!$util.isInteger(message.observedPlayerId))
                    return "observedPlayerId: integer expected";
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.SC2APIProtocol.InterfaceOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.serverPorts != null && message.hasOwnProperty("serverPorts")) {
                error = $root.SC2APIProtocol.PortSet.verify(message.serverPorts);
                if (error)
                    return "serverPorts." + error;
            }
            if (message.clientPorts != null && message.hasOwnProperty("clientPorts")) {
                if (!Array.isArray(message.clientPorts))
                    return "clientPorts: array expected";
                for (var i = 0; i < message.clientPorts.length; ++i) {
                    error = $root.SC2APIProtocol.PortSet.verify(message.clientPorts[i]);
                    if (error)
                        return "clientPorts." + error;
                }
            }
            if (message.sharedPort != null && message.hasOwnProperty("sharedPort"))
                if (!$util.isInteger(message.sharedPort))
                    return "sharedPort: integer expected";
            return null;
        };
        /**
         * Creates a RequestJoinGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestJoinGame} RequestJoinGame
         */
        RequestJoinGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestJoinGame)
                return object;
            var message = new $root.SC2APIProtocol.RequestJoinGame();
            switch (object.race) {
                case "NoRace":
                case 0:
                    message.race = 0;
                    break;
                case "Terran":
                case 1:
                    message.race = 1;
                    break;
                case "Zerg":
                case 2:
                    message.race = 2;
                    break;
                case "Protoss":
                case 3:
                    message.race = 3;
                    break;
                case "Random":
                case 4:
                    message.race = 4;
                    break;
            }
            if (object.observedPlayerId != null)
                message.observedPlayerId = object.observedPlayerId >>> 0;
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".SC2APIProtocol.RequestJoinGame.options: object expected");
                message.options = $root.SC2APIProtocol.InterfaceOptions.fromObject(object.options);
            }
            if (object.serverPorts != null) {
                if (typeof object.serverPorts !== "object")
                    throw TypeError(".SC2APIProtocol.RequestJoinGame.serverPorts: object expected");
                message.serverPorts = $root.SC2APIProtocol.PortSet.fromObject(object.serverPorts);
            }
            if (object.clientPorts) {
                if (!Array.isArray(object.clientPorts))
                    throw TypeError(".SC2APIProtocol.RequestJoinGame.clientPorts: array expected");
                message.clientPorts = [];
                for (var i = 0; i < object.clientPorts.length; ++i) {
                    if (typeof object.clientPorts[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestJoinGame.clientPorts: object expected");
                    message.clientPorts[i] = $root.SC2APIProtocol.PortSet.fromObject(object.clientPorts[i]);
                }
            }
            if (object.sharedPort != null)
                message.sharedPort = object.sharedPort | 0;
            return message;
        };
        /**
         * Creates a plain object from a RequestJoinGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestJoinGame
         * @static
         * @param {SC2APIProtocol.RequestJoinGame} message RequestJoinGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestJoinGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clientPorts = [];
            if (options.defaults) {
                object.options = null;
                object.serverPorts = null;
                object.sharedPort = 0;
            }
            if (message.race != null && message.hasOwnProperty("race")) {
                object.race = options.enums === String ? $root.SC2APIProtocol.Race[message.race] : message.race;
                if (options.oneofs)
                    object.participation = "race";
            }
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId")) {
                object.observedPlayerId = message.observedPlayerId;
                if (options.oneofs)
                    object.participation = "observedPlayerId";
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.SC2APIProtocol.InterfaceOptions.toObject(message.options, options);
            if (message.serverPorts != null && message.hasOwnProperty("serverPorts"))
                object.serverPorts = $root.SC2APIProtocol.PortSet.toObject(message.serverPorts, options);
            if (message.clientPorts && message.clientPorts.length) {
                object.clientPorts = [];
                for (var j = 0; j < message.clientPorts.length; ++j)
                    object.clientPorts[j] = $root.SC2APIProtocol.PortSet.toObject(message.clientPorts[j], options);
            }
            if (message.sharedPort != null && message.hasOwnProperty("sharedPort"))
                object.sharedPort = message.sharedPort;
            return object;
        };
        /**
         * Converts this RequestJoinGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestJoinGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestJoinGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestJoinGame;
    })();
    SC2APIProtocol.PortSet = (function () {
        /**
         * Properties of a PortSet.
         * @memberof SC2APIProtocol
         * @interface IPortSet
         * @property {number} [gamePort] PortSet gamePort
         * @property {number} [basePort] PortSet basePort
         */
        /**
         * Constructs a new PortSet.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PortSet.
         * @constructor
         * @param {SC2APIProtocol.IPortSet=} [properties] Properties to set
         */
        function PortSet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PortSet gamePort.
         * @member {number}gamePort
         * @memberof SC2APIProtocol.PortSet
         * @instance
         */
        PortSet.prototype.gamePort = 0;
        /**
         * PortSet basePort.
         * @member {number}basePort
         * @memberof SC2APIProtocol.PortSet
         * @instance
         */
        PortSet.prototype.basePort = 0;
        /**
         * Creates a new PortSet instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {SC2APIProtocol.IPortSet=} [properties] Properties to set
         * @returns {SC2APIProtocol.PortSet} PortSet instance
         */
        PortSet.create = function create(properties) {
            return new PortSet(properties);
        };
        /**
         * Encodes the specified PortSet message. Does not implicitly {@link SC2APIProtocol.PortSet.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {SC2APIProtocol.IPortSet} message PortSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PortSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gamePort != null && message.hasOwnProperty("gamePort"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.gamePort);
            if (message.basePort != null && message.hasOwnProperty("basePort"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.basePort);
            return writer;
        };
        /**
         * Encodes the specified PortSet message, length delimited. Does not implicitly {@link SC2APIProtocol.PortSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {SC2APIProtocol.IPortSet} message PortSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PortSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PortSet message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PortSet} PortSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PortSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PortSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.gamePort = reader.int32();
                        break;
                    case 2:
                        message.basePort = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PortSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PortSet} PortSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PortSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PortSet message.
         * @function verify
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PortSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gamePort != null && message.hasOwnProperty("gamePort"))
                if (!$util.isInteger(message.gamePort))
                    return "gamePort: integer expected";
            if (message.basePort != null && message.hasOwnProperty("basePort"))
                if (!$util.isInteger(message.basePort))
                    return "basePort: integer expected";
            return null;
        };
        /**
         * Creates a PortSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PortSet} PortSet
         */
        PortSet.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PortSet)
                return object;
            var message = new $root.SC2APIProtocol.PortSet();
            if (object.gamePort != null)
                message.gamePort = object.gamePort | 0;
            if (object.basePort != null)
                message.basePort = object.basePort | 0;
            return message;
        };
        /**
         * Creates a plain object from a PortSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PortSet
         * @static
         * @param {SC2APIProtocol.PortSet} message PortSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PortSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gamePort = 0;
                object.basePort = 0;
            }
            if (message.gamePort != null && message.hasOwnProperty("gamePort"))
                object.gamePort = message.gamePort;
            if (message.basePort != null && message.hasOwnProperty("basePort"))
                object.basePort = message.basePort;
            return object;
        };
        /**
         * Converts this PortSet to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PortSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PortSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PortSet;
    })();
    SC2APIProtocol.ResponseJoinGame = (function () {
        /**
         * Properties of a ResponseJoinGame.
         * @memberof SC2APIProtocol
         * @interface IResponseJoinGame
         * @property {number} [playerId] ResponseJoinGame playerId
         * @property {SC2APIProtocol.ResponseJoinGame.Error} [error] ResponseJoinGame error
         * @property {string} [errorDetails] ResponseJoinGame errorDetails
         */
        /**
         * Constructs a new ResponseJoinGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseJoinGame.
         * @constructor
         * @param {SC2APIProtocol.IResponseJoinGame=} [properties] Properties to set
         */
        function ResponseJoinGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseJoinGame playerId.
         * @member {number}playerId
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @instance
         */
        ResponseJoinGame.prototype.playerId = 0;
        /**
         * ResponseJoinGame error.
         * @member {SC2APIProtocol.ResponseJoinGame.Error}error
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @instance
         */
        ResponseJoinGame.prototype.error = 1;
        /**
         * ResponseJoinGame errorDetails.
         * @member {string}errorDetails
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @instance
         */
        ResponseJoinGame.prototype.errorDetails = "";
        /**
         * Creates a new ResponseJoinGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {SC2APIProtocol.IResponseJoinGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseJoinGame} ResponseJoinGame instance
         */
        ResponseJoinGame.create = function create(properties) {
            return new ResponseJoinGame(properties);
        };
        /**
         * Encodes the specified ResponseJoinGame message. Does not implicitly {@link SC2APIProtocol.ResponseJoinGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {SC2APIProtocol.IResponseJoinGame} message ResponseJoinGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseJoinGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.playerId);
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.error);
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.errorDetails);
            return writer;
        };
        /**
         * Encodes the specified ResponseJoinGame message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseJoinGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {SC2APIProtocol.IResponseJoinGame} message ResponseJoinGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseJoinGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseJoinGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseJoinGame} ResponseJoinGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseJoinGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseJoinGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.error = reader.int32();
                        break;
                    case 3:
                        message.errorDetails = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseJoinGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseJoinGame} ResponseJoinGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseJoinGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseJoinGame message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseJoinGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId))
                    return "playerId: integer expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                        break;
                }
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                if (!$util.isString(message.errorDetails))
                    return "errorDetails: string expected";
            return null;
        };
        /**
         * Creates a ResponseJoinGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseJoinGame} ResponseJoinGame
         */
        ResponseJoinGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseJoinGame)
                return object;
            var message = new $root.SC2APIProtocol.ResponseJoinGame();
            if (object.playerId != null)
                message.playerId = object.playerId >>> 0;
            switch (object.error) {
                case "MissingParticipation":
                case 1:
                    message.error = 1;
                    break;
                case "InvalidObservedPlayerId":
                case 2:
                    message.error = 2;
                    break;
                case "MissingOptions":
                case 3:
                    message.error = 3;
                    break;
                case "MissingPorts":
                case 4:
                    message.error = 4;
                    break;
                case "GameFull":
                case 5:
                    message.error = 5;
                    break;
                case "LaunchError":
                case 6:
                    message.error = 6;
                    break;
                case "FeatureUnsupported":
                case 7:
                    message.error = 7;
                    break;
                case "NoSpaceForUser":
                case 8:
                    message.error = 8;
                    break;
                case "MapDoesNotExist":
                case 9:
                    message.error = 9;
                    break;
                case "CannotOpenMap":
                case 10:
                    message.error = 10;
                    break;
                case "ChecksumError":
                case 11:
                    message.error = 11;
                    break;
                case "NetworkError":
                case 12:
                    message.error = 12;
                    break;
                case "OtherError":
                case 13:
                    message.error = 13;
                    break;
            }
            if (object.errorDetails != null)
                message.errorDetails = String(object.errorDetails);
            return message;
        };
        /**
         * Creates a plain object from a ResponseJoinGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @static
         * @param {SC2APIProtocol.ResponseJoinGame} message ResponseJoinGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseJoinGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerId = 0;
                object.error = options.enums === String ? "MissingParticipation" : 1;
                object.errorDetails = "";
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseJoinGame.Error[message.error] : message.error;
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                object.errorDetails = message.errorDetails;
            return object;
        };
        /**
         * Converts this ResponseJoinGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseJoinGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseJoinGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} MissingParticipation=1 MissingParticipation value
         * @property {number} InvalidObservedPlayerId=2 InvalidObservedPlayerId value
         * @property {number} MissingOptions=3 MissingOptions value
         * @property {number} MissingPorts=4 MissingPorts value
         * @property {number} GameFull=5 GameFull value
         * @property {number} LaunchError=6 LaunchError value
         * @property {number} FeatureUnsupported=7 FeatureUnsupported value
         * @property {number} NoSpaceForUser=8 NoSpaceForUser value
         * @property {number} MapDoesNotExist=9 MapDoesNotExist value
         * @property {number} CannotOpenMap=10 CannotOpenMap value
         * @property {number} ChecksumError=11 ChecksumError value
         * @property {number} NetworkError=12 NetworkError value
         * @property {number} OtherError=13 OtherError value
         */
        ResponseJoinGame.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MissingParticipation"] = 1;
            values[valuesById[2] = "InvalidObservedPlayerId"] = 2;
            values[valuesById[3] = "MissingOptions"] = 3;
            values[valuesById[4] = "MissingPorts"] = 4;
            values[valuesById[5] = "GameFull"] = 5;
            values[valuesById[6] = "LaunchError"] = 6;
            values[valuesById[7] = "FeatureUnsupported"] = 7;
            values[valuesById[8] = "NoSpaceForUser"] = 8;
            values[valuesById[9] = "MapDoesNotExist"] = 9;
            values[valuesById[10] = "CannotOpenMap"] = 10;
            values[valuesById[11] = "ChecksumError"] = 11;
            values[valuesById[12] = "NetworkError"] = 12;
            values[valuesById[13] = "OtherError"] = 13;
            return values;
        })();
        return ResponseJoinGame;
    })();
    SC2APIProtocol.RequestRestartGame = (function () {
        /**
         * Properties of a RequestRestartGame.
         * @memberof SC2APIProtocol
         * @interface IRequestRestartGame
         */
        /**
         * Constructs a new RequestRestartGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestRestartGame.
         * @constructor
         * @param {SC2APIProtocol.IRequestRestartGame=} [properties] Properties to set
         */
        function RequestRestartGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestRestartGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {SC2APIProtocol.IRequestRestartGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestRestartGame} RequestRestartGame instance
         */
        RequestRestartGame.create = function create(properties) {
            return new RequestRestartGame(properties);
        };
        /**
         * Encodes the specified RequestRestartGame message. Does not implicitly {@link SC2APIProtocol.RequestRestartGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {SC2APIProtocol.IRequestRestartGame} message RequestRestartGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestRestartGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestRestartGame message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestRestartGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {SC2APIProtocol.IRequestRestartGame} message RequestRestartGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestRestartGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestRestartGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestRestartGame} RequestRestartGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestRestartGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestRestartGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestRestartGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestRestartGame} RequestRestartGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestRestartGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestRestartGame message.
         * @function verify
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestRestartGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestRestartGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestRestartGame} RequestRestartGame
         */
        RequestRestartGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestRestartGame)
                return object;
            return new $root.SC2APIProtocol.RequestRestartGame();
        };
        /**
         * Creates a plain object from a RequestRestartGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestRestartGame
         * @static
         * @param {SC2APIProtocol.RequestRestartGame} message RequestRestartGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestRestartGame.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestRestartGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestRestartGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestRestartGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestRestartGame;
    })();
    SC2APIProtocol.ResponseRestartGame = (function () {
        /**
         * Properties of a ResponseRestartGame.
         * @memberof SC2APIProtocol
         * @interface IResponseRestartGame
         * @property {SC2APIProtocol.ResponseRestartGame.Error} [error] ResponseRestartGame error
         * @property {string} [errorDetails] ResponseRestartGame errorDetails
         */
        /**
         * Constructs a new ResponseRestartGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseRestartGame.
         * @constructor
         * @param {SC2APIProtocol.IResponseRestartGame=} [properties] Properties to set
         */
        function ResponseRestartGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseRestartGame error.
         * @member {SC2APIProtocol.ResponseRestartGame.Error}error
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @instance
         */
        ResponseRestartGame.prototype.error = 1;
        /**
         * ResponseRestartGame errorDetails.
         * @member {string}errorDetails
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @instance
         */
        ResponseRestartGame.prototype.errorDetails = "";
        /**
         * Creates a new ResponseRestartGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {SC2APIProtocol.IResponseRestartGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseRestartGame} ResponseRestartGame instance
         */
        ResponseRestartGame.create = function create(properties) {
            return new ResponseRestartGame(properties);
        };
        /**
         * Encodes the specified ResponseRestartGame message. Does not implicitly {@link SC2APIProtocol.ResponseRestartGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {SC2APIProtocol.IResponseRestartGame} message ResponseRestartGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseRestartGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.error);
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorDetails);
            return writer;
        };
        /**
         * Encodes the specified ResponseRestartGame message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseRestartGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {SC2APIProtocol.IResponseRestartGame} message ResponseRestartGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseRestartGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseRestartGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseRestartGame} ResponseRestartGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseRestartGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseRestartGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.error = reader.int32();
                        break;
                    case 2:
                        message.errorDetails = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseRestartGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseRestartGame} ResponseRestartGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseRestartGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseRestartGame message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseRestartGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                        break;
                }
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                if (!$util.isString(message.errorDetails))
                    return "errorDetails: string expected";
            return null;
        };
        /**
         * Creates a ResponseRestartGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseRestartGame} ResponseRestartGame
         */
        ResponseRestartGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseRestartGame)
                return object;
            var message = new $root.SC2APIProtocol.ResponseRestartGame();
            switch (object.error) {
                case "LaunchError":
                case 1:
                    message.error = 1;
                    break;
            }
            if (object.errorDetails != null)
                message.errorDetails = String(object.errorDetails);
            return message;
        };
        /**
         * Creates a plain object from a ResponseRestartGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @static
         * @param {SC2APIProtocol.ResponseRestartGame} message ResponseRestartGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseRestartGame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = options.enums === String ? "LaunchError" : 1;
                object.errorDetails = "";
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseRestartGame.Error[message.error] : message.error;
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                object.errorDetails = message.errorDetails;
            return object;
        };
        /**
         * Converts this ResponseRestartGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseRestartGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseRestartGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} LaunchError=1 LaunchError value
         */
        ResponseRestartGame.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "LaunchError"] = 1;
            return values;
        })();
        return ResponseRestartGame;
    })();
    SC2APIProtocol.RequestStartReplay = (function () {
        /**
         * Properties of a RequestStartReplay.
         * @memberof SC2APIProtocol
         * @interface IRequestStartReplay
         * @property {string} [replayPath] RequestStartReplay replayPath
         * @property {Uint8Array} [replayData] RequestStartReplay replayData
         * @property {Uint8Array} [mapData] RequestStartReplay mapData
         * @property {number} [observedPlayerId] RequestStartReplay observedPlayerId
         * @property {SC2APIProtocol.IInterfaceOptions} [options] RequestStartReplay options
         * @property {boolean} [disableFog] RequestStartReplay disableFog
         */
        /**
         * Constructs a new RequestStartReplay.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestStartReplay.
         * @constructor
         * @param {SC2APIProtocol.IRequestStartReplay=} [properties] Properties to set
         */
        function RequestStartReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestStartReplay replayPath.
         * @member {string}replayPath
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.replayPath = "";
        /**
         * RequestStartReplay replayData.
         * @member {Uint8Array}replayData
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.replayData = $util.newBuffer([]);
        /**
         * RequestStartReplay mapData.
         * @member {Uint8Array}mapData
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.mapData = $util.newBuffer([]);
        /**
         * RequestStartReplay observedPlayerId.
         * @member {number}observedPlayerId
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.observedPlayerId = 0;
        /**
         * RequestStartReplay options.
         * @member {(SC2APIProtocol.IInterfaceOptions|null|undefined)}options
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.options = null;
        /**
         * RequestStartReplay disableFog.
         * @member {boolean}disableFog
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        RequestStartReplay.prototype.disableFog = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestStartReplay replay.
         * @member {string|undefined} replay
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         */
        Object.defineProperty(RequestStartReplay.prototype, "replay", {
            get: $util.oneOfGetter($oneOfFields = ["replayPath", "replayData"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestStartReplay instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {SC2APIProtocol.IRequestStartReplay=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestStartReplay} RequestStartReplay instance
         */
        RequestStartReplay.create = function create(properties) {
            return new RequestStartReplay(properties);
        };
        /**
         * Encodes the specified RequestStartReplay message. Does not implicitly {@link SC2APIProtocol.RequestStartReplay.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {SC2APIProtocol.IRequestStartReplay} message RequestStartReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestStartReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.replayPath != null && message.hasOwnProperty("replayPath"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.replayPath);
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.observedPlayerId);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.SC2APIProtocol.InterfaceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.disableFog);
            if (message.replayData != null && message.hasOwnProperty("replayData"))
                writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.replayData);
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.mapData);
            return writer;
        };
        /**
         * Encodes the specified RequestStartReplay message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestStartReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {SC2APIProtocol.IRequestStartReplay} message RequestStartReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestStartReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestStartReplay message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestStartReplay} RequestStartReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestStartReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestStartReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.replayPath = reader.string();
                        break;
                    case 5:
                        message.replayData = reader.bytes();
                        break;
                    case 6:
                        message.mapData = reader.bytes();
                        break;
                    case 2:
                        message.observedPlayerId = reader.int32();
                        break;
                    case 3:
                        message.options = $root.SC2APIProtocol.InterfaceOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.disableFog = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestStartReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestStartReplay} RequestStartReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestStartReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestStartReplay message.
         * @function verify
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestStartReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.replayPath != null && message.hasOwnProperty("replayPath")) {
                properties.replay = 1;
                if (!$util.isString(message.replayPath))
                    return "replayPath: string expected";
            }
            if (message.replayData != null && message.hasOwnProperty("replayData")) {
                if (properties.replay === 1)
                    return "replay: multiple values";
                properties.replay = 1;
                if (!(message.replayData && typeof message.replayData.length === "number" || $util.isString(message.replayData)))
                    return "replayData: buffer expected";
            }
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                if (!(message.mapData && typeof message.mapData.length === "number" || $util.isString(message.mapData)))
                    return "mapData: buffer expected";
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId"))
                if (!$util.isInteger(message.observedPlayerId))
                    return "observedPlayerId: integer expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.SC2APIProtocol.InterfaceOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                if (typeof message.disableFog !== "boolean")
                    return "disableFog: boolean expected";
            return null;
        };
        /**
         * Creates a RequestStartReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestStartReplay} RequestStartReplay
         */
        RequestStartReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestStartReplay)
                return object;
            var message = new $root.SC2APIProtocol.RequestStartReplay();
            if (object.replayPath != null)
                message.replayPath = String(object.replayPath);
            if (object.replayData != null)
                if (typeof object.replayData === "string")
                    $util.base64.decode(object.replayData, message.replayData = $util.newBuffer($util.base64.length(object.replayData)), 0);
                else if (object.replayData.length)
                    message.replayData = object.replayData;
            if (object.mapData != null)
                if (typeof object.mapData === "string")
                    $util.base64.decode(object.mapData, message.mapData = $util.newBuffer($util.base64.length(object.mapData)), 0);
                else if (object.mapData.length)
                    message.mapData = object.mapData;
            if (object.observedPlayerId != null)
                message.observedPlayerId = object.observedPlayerId | 0;
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".SC2APIProtocol.RequestStartReplay.options: object expected");
                message.options = $root.SC2APIProtocol.InterfaceOptions.fromObject(object.options);
            }
            if (object.disableFog != null)
                message.disableFog = Boolean(object.disableFog);
            return message;
        };
        /**
         * Creates a plain object from a RequestStartReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestStartReplay
         * @static
         * @param {SC2APIProtocol.RequestStartReplay} message RequestStartReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestStartReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.observedPlayerId = 0;
                object.options = null;
                object.disableFog = false;
                object.mapData = options.bytes === String ? "" : [];
            }
            if (message.replayPath != null && message.hasOwnProperty("replayPath")) {
                object.replayPath = message.replayPath;
                if (options.oneofs)
                    object.replay = "replayPath";
            }
            if (message.observedPlayerId != null && message.hasOwnProperty("observedPlayerId"))
                object.observedPlayerId = message.observedPlayerId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.SC2APIProtocol.InterfaceOptions.toObject(message.options, options);
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                object.disableFog = message.disableFog;
            if (message.replayData != null && message.hasOwnProperty("replayData")) {
                object.replayData = options.bytes === String ? $util.base64.encode(message.replayData, 0, message.replayData.length) : options.bytes === Array ? Array.prototype.slice.call(message.replayData) : message.replayData;
                if (options.oneofs)
                    object.replay = "replayData";
            }
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                object.mapData = options.bytes === String ? $util.base64.encode(message.mapData, 0, message.mapData.length) : options.bytes === Array ? Array.prototype.slice.call(message.mapData) : message.mapData;
            return object;
        };
        /**
         * Converts this RequestStartReplay to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestStartReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestStartReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestStartReplay;
    })();
    SC2APIProtocol.ResponseStartReplay = (function () {
        /**
         * Properties of a ResponseStartReplay.
         * @memberof SC2APIProtocol
         * @interface IResponseStartReplay
         * @property {SC2APIProtocol.ResponseStartReplay.Error} [error] ResponseStartReplay error
         * @property {string} [errorDetails] ResponseStartReplay errorDetails
         */
        /**
         * Constructs a new ResponseStartReplay.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseStartReplay.
         * @constructor
         * @param {SC2APIProtocol.IResponseStartReplay=} [properties] Properties to set
         */
        function ResponseStartReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseStartReplay error.
         * @member {SC2APIProtocol.ResponseStartReplay.Error}error
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @instance
         */
        ResponseStartReplay.prototype.error = 1;
        /**
         * ResponseStartReplay errorDetails.
         * @member {string}errorDetails
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @instance
         */
        ResponseStartReplay.prototype.errorDetails = "";
        /**
         * Creates a new ResponseStartReplay instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {SC2APIProtocol.IResponseStartReplay=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseStartReplay} ResponseStartReplay instance
         */
        ResponseStartReplay.create = function create(properties) {
            return new ResponseStartReplay(properties);
        };
        /**
         * Encodes the specified ResponseStartReplay message. Does not implicitly {@link SC2APIProtocol.ResponseStartReplay.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {SC2APIProtocol.IResponseStartReplay} message ResponseStartReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseStartReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.error);
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorDetails);
            return writer;
        };
        /**
         * Encodes the specified ResponseStartReplay message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseStartReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {SC2APIProtocol.IResponseStartReplay} message ResponseStartReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseStartReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseStartReplay message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseStartReplay} ResponseStartReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseStartReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseStartReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.error = reader.int32();
                        break;
                    case 2:
                        message.errorDetails = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseStartReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseStartReplay} ResponseStartReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseStartReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseStartReplay message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseStartReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                }
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                if (!$util.isString(message.errorDetails))
                    return "errorDetails: string expected";
            return null;
        };
        /**
         * Creates a ResponseStartReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseStartReplay} ResponseStartReplay
         */
        ResponseStartReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseStartReplay)
                return object;
            var message = new $root.SC2APIProtocol.ResponseStartReplay();
            switch (object.error) {
                case "MissingReplay":
                case 1:
                    message.error = 1;
                    break;
                case "InvalidReplayPath":
                case 2:
                    message.error = 2;
                    break;
                case "InvalidReplayData":
                case 3:
                    message.error = 3;
                    break;
                case "InvalidMapData":
                case 4:
                    message.error = 4;
                    break;
                case "InvalidObservedPlayerId":
                case 5:
                    message.error = 5;
                    break;
                case "MissingOptions":
                case 6:
                    message.error = 6;
                    break;
                case "LaunchError":
                case 7:
                    message.error = 7;
                    break;
            }
            if (object.errorDetails != null)
                message.errorDetails = String(object.errorDetails);
            return message;
        };
        /**
         * Creates a plain object from a ResponseStartReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @static
         * @param {SC2APIProtocol.ResponseStartReplay} message ResponseStartReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseStartReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = options.enums === String ? "MissingReplay" : 1;
                object.errorDetails = "";
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseStartReplay.Error[message.error] : message.error;
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                object.errorDetails = message.errorDetails;
            return object;
        };
        /**
         * Converts this ResponseStartReplay to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseStartReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseStartReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} MissingReplay=1 MissingReplay value
         * @property {number} InvalidReplayPath=2 InvalidReplayPath value
         * @property {number} InvalidReplayData=3 InvalidReplayData value
         * @property {number} InvalidMapData=4 InvalidMapData value
         * @property {number} InvalidObservedPlayerId=5 InvalidObservedPlayerId value
         * @property {number} MissingOptions=6 MissingOptions value
         * @property {number} LaunchError=7 LaunchError value
         */
        ResponseStartReplay.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MissingReplay"] = 1;
            values[valuesById[2] = "InvalidReplayPath"] = 2;
            values[valuesById[3] = "InvalidReplayData"] = 3;
            values[valuesById[4] = "InvalidMapData"] = 4;
            values[valuesById[5] = "InvalidObservedPlayerId"] = 5;
            values[valuesById[6] = "MissingOptions"] = 6;
            values[valuesById[7] = "LaunchError"] = 7;
            return values;
        })();
        return ResponseStartReplay;
    })();
    SC2APIProtocol.RequestLeaveGame = (function () {
        /**
         * Properties of a RequestLeaveGame.
         * @memberof SC2APIProtocol
         * @interface IRequestLeaveGame
         */
        /**
         * Constructs a new RequestLeaveGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestLeaveGame.
         * @constructor
         * @param {SC2APIProtocol.IRequestLeaveGame=} [properties] Properties to set
         */
        function RequestLeaveGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestLeaveGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {SC2APIProtocol.IRequestLeaveGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestLeaveGame} RequestLeaveGame instance
         */
        RequestLeaveGame.create = function create(properties) {
            return new RequestLeaveGame(properties);
        };
        /**
         * Encodes the specified RequestLeaveGame message. Does not implicitly {@link SC2APIProtocol.RequestLeaveGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {SC2APIProtocol.IRequestLeaveGame} message RequestLeaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLeaveGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestLeaveGame message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestLeaveGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {SC2APIProtocol.IRequestLeaveGame} message RequestLeaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestLeaveGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestLeaveGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestLeaveGame} RequestLeaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLeaveGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestLeaveGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestLeaveGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestLeaveGame} RequestLeaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestLeaveGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestLeaveGame message.
         * @function verify
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestLeaveGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestLeaveGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestLeaveGame} RequestLeaveGame
         */
        RequestLeaveGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestLeaveGame)
                return object;
            return new $root.SC2APIProtocol.RequestLeaveGame();
        };
        /**
         * Creates a plain object from a RequestLeaveGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @static
         * @param {SC2APIProtocol.RequestLeaveGame} message RequestLeaveGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestLeaveGame.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestLeaveGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestLeaveGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestLeaveGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestLeaveGame;
    })();
    SC2APIProtocol.ResponseLeaveGame = (function () {
        /**
         * Properties of a ResponseLeaveGame.
         * @memberof SC2APIProtocol
         * @interface IResponseLeaveGame
         */
        /**
         * Constructs a new ResponseLeaveGame.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseLeaveGame.
         * @constructor
         * @param {SC2APIProtocol.IResponseLeaveGame=} [properties] Properties to set
         */
        function ResponseLeaveGame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseLeaveGame instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {SC2APIProtocol.IResponseLeaveGame=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseLeaveGame} ResponseLeaveGame instance
         */
        ResponseLeaveGame.create = function create(properties) {
            return new ResponseLeaveGame(properties);
        };
        /**
         * Encodes the specified ResponseLeaveGame message. Does not implicitly {@link SC2APIProtocol.ResponseLeaveGame.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {SC2APIProtocol.IResponseLeaveGame} message ResponseLeaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseLeaveGame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseLeaveGame message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseLeaveGame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {SC2APIProtocol.IResponseLeaveGame} message ResponseLeaveGame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseLeaveGame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseLeaveGame message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseLeaveGame} ResponseLeaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseLeaveGame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseLeaveGame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseLeaveGame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseLeaveGame} ResponseLeaveGame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseLeaveGame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseLeaveGame message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseLeaveGame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseLeaveGame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseLeaveGame} ResponseLeaveGame
         */
        ResponseLeaveGame.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseLeaveGame)
                return object;
            return new $root.SC2APIProtocol.ResponseLeaveGame();
        };
        /**
         * Creates a plain object from a ResponseLeaveGame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @static
         * @param {SC2APIProtocol.ResponseLeaveGame} message ResponseLeaveGame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseLeaveGame.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseLeaveGame to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseLeaveGame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseLeaveGame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseLeaveGame;
    })();
    SC2APIProtocol.RequestQuickSave = (function () {
        /**
         * Properties of a RequestQuickSave.
         * @memberof SC2APIProtocol
         * @interface IRequestQuickSave
         */
        /**
         * Constructs a new RequestQuickSave.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQuickSave.
         * @constructor
         * @param {SC2APIProtocol.IRequestQuickSave=} [properties] Properties to set
         */
        function RequestQuickSave(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestQuickSave instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {SC2APIProtocol.IRequestQuickSave=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQuickSave} RequestQuickSave instance
         */
        RequestQuickSave.create = function create(properties) {
            return new RequestQuickSave(properties);
        };
        /**
         * Encodes the specified RequestQuickSave message. Does not implicitly {@link SC2APIProtocol.RequestQuickSave.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {SC2APIProtocol.IRequestQuickSave} message RequestQuickSave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuickSave.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestQuickSave message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQuickSave.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {SC2APIProtocol.IRequestQuickSave} message RequestQuickSave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuickSave.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQuickSave message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQuickSave} RequestQuickSave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuickSave.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQuickSave();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQuickSave message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQuickSave} RequestQuickSave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuickSave.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQuickSave message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQuickSave.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestQuickSave message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQuickSave} RequestQuickSave
         */
        RequestQuickSave.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQuickSave)
                return object;
            return new $root.SC2APIProtocol.RequestQuickSave();
        };
        /**
         * Creates a plain object from a RequestQuickSave message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQuickSave
         * @static
         * @param {SC2APIProtocol.RequestQuickSave} message RequestQuickSave
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQuickSave.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestQuickSave to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQuickSave
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQuickSave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQuickSave;
    })();
    SC2APIProtocol.ResponseQuickSave = (function () {
        /**
         * Properties of a ResponseQuickSave.
         * @memberof SC2APIProtocol
         * @interface IResponseQuickSave
         */
        /**
         * Constructs a new ResponseQuickSave.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQuickSave.
         * @constructor
         * @param {SC2APIProtocol.IResponseQuickSave=} [properties] Properties to set
         */
        function ResponseQuickSave(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseQuickSave instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {SC2APIProtocol.IResponseQuickSave=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQuickSave} ResponseQuickSave instance
         */
        ResponseQuickSave.create = function create(properties) {
            return new ResponseQuickSave(properties);
        };
        /**
         * Encodes the specified ResponseQuickSave message. Does not implicitly {@link SC2APIProtocol.ResponseQuickSave.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {SC2APIProtocol.IResponseQuickSave} message ResponseQuickSave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuickSave.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseQuickSave message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQuickSave.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {SC2APIProtocol.IResponseQuickSave} message ResponseQuickSave message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuickSave.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQuickSave message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQuickSave} ResponseQuickSave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuickSave.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQuickSave();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQuickSave message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQuickSave} ResponseQuickSave
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuickSave.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQuickSave message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQuickSave.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseQuickSave message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQuickSave} ResponseQuickSave
         */
        ResponseQuickSave.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQuickSave)
                return object;
            return new $root.SC2APIProtocol.ResponseQuickSave();
        };
        /**
         * Creates a plain object from a ResponseQuickSave message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @static
         * @param {SC2APIProtocol.ResponseQuickSave} message ResponseQuickSave
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQuickSave.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseQuickSave to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQuickSave
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQuickSave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQuickSave;
    })();
    SC2APIProtocol.RequestQuickLoad = (function () {
        /**
         * Properties of a RequestQuickLoad.
         * @memberof SC2APIProtocol
         * @interface IRequestQuickLoad
         */
        /**
         * Constructs a new RequestQuickLoad.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQuickLoad.
         * @constructor
         * @param {SC2APIProtocol.IRequestQuickLoad=} [properties] Properties to set
         */
        function RequestQuickLoad(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestQuickLoad instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {SC2APIProtocol.IRequestQuickLoad=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQuickLoad} RequestQuickLoad instance
         */
        RequestQuickLoad.create = function create(properties) {
            return new RequestQuickLoad(properties);
        };
        /**
         * Encodes the specified RequestQuickLoad message. Does not implicitly {@link SC2APIProtocol.RequestQuickLoad.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {SC2APIProtocol.IRequestQuickLoad} message RequestQuickLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuickLoad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestQuickLoad message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQuickLoad.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {SC2APIProtocol.IRequestQuickLoad} message RequestQuickLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuickLoad.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQuickLoad message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQuickLoad} RequestQuickLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuickLoad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQuickLoad();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQuickLoad message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQuickLoad} RequestQuickLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuickLoad.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQuickLoad message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQuickLoad.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestQuickLoad message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQuickLoad} RequestQuickLoad
         */
        RequestQuickLoad.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQuickLoad)
                return object;
            return new $root.SC2APIProtocol.RequestQuickLoad();
        };
        /**
         * Creates a plain object from a RequestQuickLoad message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @static
         * @param {SC2APIProtocol.RequestQuickLoad} message RequestQuickLoad
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQuickLoad.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestQuickLoad to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQuickLoad
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQuickLoad.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQuickLoad;
    })();
    SC2APIProtocol.ResponseQuickLoad = (function () {
        /**
         * Properties of a ResponseQuickLoad.
         * @memberof SC2APIProtocol
         * @interface IResponseQuickLoad
         */
        /**
         * Constructs a new ResponseQuickLoad.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQuickLoad.
         * @constructor
         * @param {SC2APIProtocol.IResponseQuickLoad=} [properties] Properties to set
         */
        function ResponseQuickLoad(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseQuickLoad instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {SC2APIProtocol.IResponseQuickLoad=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQuickLoad} ResponseQuickLoad instance
         */
        ResponseQuickLoad.create = function create(properties) {
            return new ResponseQuickLoad(properties);
        };
        /**
         * Encodes the specified ResponseQuickLoad message. Does not implicitly {@link SC2APIProtocol.ResponseQuickLoad.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {SC2APIProtocol.IResponseQuickLoad} message ResponseQuickLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuickLoad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseQuickLoad message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQuickLoad.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {SC2APIProtocol.IResponseQuickLoad} message ResponseQuickLoad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuickLoad.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQuickLoad message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQuickLoad} ResponseQuickLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuickLoad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQuickLoad();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQuickLoad message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQuickLoad} ResponseQuickLoad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuickLoad.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQuickLoad message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQuickLoad.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseQuickLoad message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQuickLoad} ResponseQuickLoad
         */
        ResponseQuickLoad.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQuickLoad)
                return object;
            return new $root.SC2APIProtocol.ResponseQuickLoad();
        };
        /**
         * Creates a plain object from a ResponseQuickLoad message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @static
         * @param {SC2APIProtocol.ResponseQuickLoad} message ResponseQuickLoad
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQuickLoad.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseQuickLoad to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQuickLoad
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQuickLoad.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQuickLoad;
    })();
    SC2APIProtocol.RequestQuit = (function () {
        /**
         * Properties of a RequestQuit.
         * @memberof SC2APIProtocol
         * @interface IRequestQuit
         */
        /**
         * Constructs a new RequestQuit.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestQuit.
         * @constructor
         * @param {SC2APIProtocol.IRequestQuit=} [properties] Properties to set
         */
        function RequestQuit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestQuit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {SC2APIProtocol.IRequestQuit=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestQuit} RequestQuit instance
         */
        RequestQuit.create = function create(properties) {
            return new RequestQuit(properties);
        };
        /**
         * Encodes the specified RequestQuit message. Does not implicitly {@link SC2APIProtocol.RequestQuit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {SC2APIProtocol.IRequestQuit} message RequestQuit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestQuit message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestQuit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {SC2APIProtocol.IRequestQuit} message RequestQuit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestQuit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestQuit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestQuit} RequestQuit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestQuit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestQuit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestQuit} RequestQuit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestQuit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestQuit message.
         * @function verify
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestQuit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestQuit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestQuit} RequestQuit
         */
        RequestQuit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestQuit)
                return object;
            return new $root.SC2APIProtocol.RequestQuit();
        };
        /**
         * Creates a plain object from a RequestQuit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestQuit
         * @static
         * @param {SC2APIProtocol.RequestQuit} message RequestQuit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestQuit.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestQuit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestQuit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestQuit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestQuit;
    })();
    SC2APIProtocol.ResponseQuit = (function () {
        /**
         * Properties of a ResponseQuit.
         * @memberof SC2APIProtocol
         * @interface IResponseQuit
         */
        /**
         * Constructs a new ResponseQuit.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseQuit.
         * @constructor
         * @param {SC2APIProtocol.IResponseQuit=} [properties] Properties to set
         */
        function ResponseQuit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseQuit instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {SC2APIProtocol.IResponseQuit=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseQuit} ResponseQuit instance
         */
        ResponseQuit.create = function create(properties) {
            return new ResponseQuit(properties);
        };
        /**
         * Encodes the specified ResponseQuit message. Does not implicitly {@link SC2APIProtocol.ResponseQuit.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {SC2APIProtocol.IResponseQuit} message ResponseQuit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseQuit message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseQuit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {SC2APIProtocol.IResponseQuit} message ResponseQuit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseQuit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseQuit message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseQuit} ResponseQuit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseQuit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseQuit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseQuit} ResponseQuit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseQuit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseQuit message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseQuit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseQuit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseQuit} ResponseQuit
         */
        ResponseQuit.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseQuit)
                return object;
            return new $root.SC2APIProtocol.ResponseQuit();
        };
        /**
         * Creates a plain object from a ResponseQuit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseQuit
         * @static
         * @param {SC2APIProtocol.ResponseQuit} message ResponseQuit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseQuit.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseQuit to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseQuit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseQuit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseQuit;
    })();
    SC2APIProtocol.RequestGameInfo = (function () {
        /**
         * Properties of a RequestGameInfo.
         * @memberof SC2APIProtocol
         * @interface IRequestGameInfo
         */
        /**
         * Constructs a new RequestGameInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestGameInfo.
         * @constructor
         * @param {SC2APIProtocol.IRequestGameInfo=} [properties] Properties to set
         */
        function RequestGameInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestGameInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {SC2APIProtocol.IRequestGameInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestGameInfo} RequestGameInfo instance
         */
        RequestGameInfo.create = function create(properties) {
            return new RequestGameInfo(properties);
        };
        /**
         * Encodes the specified RequestGameInfo message. Does not implicitly {@link SC2APIProtocol.RequestGameInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {SC2APIProtocol.IRequestGameInfo} message RequestGameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestGameInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestGameInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestGameInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {SC2APIProtocol.IRequestGameInfo} message RequestGameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestGameInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestGameInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestGameInfo} RequestGameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestGameInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestGameInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestGameInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestGameInfo} RequestGameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestGameInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestGameInfo message.
         * @function verify
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestGameInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestGameInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestGameInfo} RequestGameInfo
         */
        RequestGameInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestGameInfo)
                return object;
            return new $root.SC2APIProtocol.RequestGameInfo();
        };
        /**
         * Creates a plain object from a RequestGameInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestGameInfo
         * @static
         * @param {SC2APIProtocol.RequestGameInfo} message RequestGameInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestGameInfo.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestGameInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestGameInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestGameInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestGameInfo;
    })();
    SC2APIProtocol.ResponseGameInfo = (function () {
        /**
         * Properties of a ResponseGameInfo.
         * @memberof SC2APIProtocol
         * @interface IResponseGameInfo
         * @property {string} [mapName] ResponseGameInfo mapName
         * @property {Array.<string>} [modNames] ResponseGameInfo modNames
         * @property {string} [localMapPath] ResponseGameInfo localMapPath
         * @property {Array.<SC2APIProtocol.IPlayerInfo>} [playerInfo] ResponseGameInfo playerInfo
         * @property {SC2APIProtocol.IStartRaw} [startRaw] ResponseGameInfo startRaw
         * @property {SC2APIProtocol.IInterfaceOptions} [options] ResponseGameInfo options
         */
        /**
         * Constructs a new ResponseGameInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseGameInfo.
         * @constructor
         * @param {SC2APIProtocol.IResponseGameInfo=} [properties] Properties to set
         */
        function ResponseGameInfo(properties) {
            this.modNames = [];
            this.playerInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseGameInfo mapName.
         * @member {string}mapName
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.mapName = "";
        /**
         * ResponseGameInfo modNames.
         * @member {Array.<string>}modNames
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.modNames = $util.emptyArray;
        /**
         * ResponseGameInfo localMapPath.
         * @member {string}localMapPath
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.localMapPath = "";
        /**
         * ResponseGameInfo playerInfo.
         * @member {Array.<SC2APIProtocol.IPlayerInfo>}playerInfo
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.playerInfo = $util.emptyArray;
        /**
         * ResponseGameInfo startRaw.
         * @member {(SC2APIProtocol.IStartRaw|null|undefined)}startRaw
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.startRaw = null;
        /**
         * ResponseGameInfo options.
         * @member {(SC2APIProtocol.IInterfaceOptions|null|undefined)}options
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         */
        ResponseGameInfo.prototype.options = null;
        /**
         * Creates a new ResponseGameInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {SC2APIProtocol.IResponseGameInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseGameInfo} ResponseGameInfo instance
         */
        ResponseGameInfo.create = function create(properties) {
            return new ResponseGameInfo(properties);
        };
        /**
         * Encodes the specified ResponseGameInfo message. Does not implicitly {@link SC2APIProtocol.ResponseGameInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {SC2APIProtocol.IResponseGameInfo} message ResponseGameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseGameInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mapName);
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.localMapPath);
            if (message.playerInfo != null && message.playerInfo.length)
                for (var i = 0; i < message.playerInfo.length; ++i)
                    $root.SC2APIProtocol.PlayerInfo.encode(message.playerInfo[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.startRaw != null && message.hasOwnProperty("startRaw"))
                $root.SC2APIProtocol.StartRaw.encode(message.startRaw, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.options != null && message.hasOwnProperty("options"))
                $root.SC2APIProtocol.InterfaceOptions.encode(message.options, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.modNames != null && message.modNames.length)
                for (var i = 0; i < message.modNames.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.modNames[i]);
            return writer;
        };
        /**
         * Encodes the specified ResponseGameInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseGameInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {SC2APIProtocol.IResponseGameInfo} message ResponseGameInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseGameInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseGameInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseGameInfo} ResponseGameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseGameInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseGameInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapName = reader.string();
                        break;
                    case 6:
                        if (!(message.modNames && message.modNames.length))
                            message.modNames = [];
                        message.modNames.push(reader.string());
                        break;
                    case 2:
                        message.localMapPath = reader.string();
                        break;
                    case 3:
                        if (!(message.playerInfo && message.playerInfo.length))
                            message.playerInfo = [];
                        message.playerInfo.push($root.SC2APIProtocol.PlayerInfo.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.startRaw = $root.SC2APIProtocol.StartRaw.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.options = $root.SC2APIProtocol.InterfaceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseGameInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseGameInfo} ResponseGameInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseGameInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseGameInfo message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseGameInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                if (!$util.isString(message.mapName))
                    return "mapName: string expected";
            if (message.modNames != null && message.hasOwnProperty("modNames")) {
                if (!Array.isArray(message.modNames))
                    return "modNames: array expected";
                for (var i = 0; i < message.modNames.length; ++i)
                    if (!$util.isString(message.modNames[i]))
                        return "modNames: string[] expected";
            }
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                if (!$util.isString(message.localMapPath))
                    return "localMapPath: string expected";
            if (message.playerInfo != null && message.hasOwnProperty("playerInfo")) {
                if (!Array.isArray(message.playerInfo))
                    return "playerInfo: array expected";
                for (var i = 0; i < message.playerInfo.length; ++i) {
                    var error = $root.SC2APIProtocol.PlayerInfo.verify(message.playerInfo[i]);
                    if (error)
                        return "playerInfo." + error;
                }
            }
            if (message.startRaw != null && message.hasOwnProperty("startRaw")) {
                error = $root.SC2APIProtocol.StartRaw.verify(message.startRaw);
                if (error)
                    return "startRaw." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                error = $root.SC2APIProtocol.InterfaceOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };
        /**
         * Creates a ResponseGameInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseGameInfo} ResponseGameInfo
         */
        ResponseGameInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseGameInfo)
                return object;
            var message = new $root.SC2APIProtocol.ResponseGameInfo();
            if (object.mapName != null)
                message.mapName = String(object.mapName);
            if (object.modNames) {
                if (!Array.isArray(object.modNames))
                    throw TypeError(".SC2APIProtocol.ResponseGameInfo.modNames: array expected");
                message.modNames = [];
                for (var i = 0; i < object.modNames.length; ++i)
                    message.modNames[i] = String(object.modNames[i]);
            }
            if (object.localMapPath != null)
                message.localMapPath = String(object.localMapPath);
            if (object.playerInfo) {
                if (!Array.isArray(object.playerInfo))
                    throw TypeError(".SC2APIProtocol.ResponseGameInfo.playerInfo: array expected");
                message.playerInfo = [];
                for (var i = 0; i < object.playerInfo.length; ++i) {
                    if (typeof object.playerInfo[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseGameInfo.playerInfo: object expected");
                    message.playerInfo[i] = $root.SC2APIProtocol.PlayerInfo.fromObject(object.playerInfo[i]);
                }
            }
            if (object.startRaw != null) {
                if (typeof object.startRaw !== "object")
                    throw TypeError(".SC2APIProtocol.ResponseGameInfo.startRaw: object expected");
                message.startRaw = $root.SC2APIProtocol.StartRaw.fromObject(object.startRaw);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".SC2APIProtocol.ResponseGameInfo.options: object expected");
                message.options = $root.SC2APIProtocol.InterfaceOptions.fromObject(object.options);
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseGameInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @static
         * @param {SC2APIProtocol.ResponseGameInfo} message ResponseGameInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseGameInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.playerInfo = [];
                object.modNames = [];
            }
            if (options.defaults) {
                object.mapName = "";
                object.localMapPath = "";
                object.startRaw = null;
                object.options = null;
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                object.mapName = message.mapName;
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                object.localMapPath = message.localMapPath;
            if (message.playerInfo && message.playerInfo.length) {
                object.playerInfo = [];
                for (var j = 0; j < message.playerInfo.length; ++j)
                    object.playerInfo[j] = $root.SC2APIProtocol.PlayerInfo.toObject(message.playerInfo[j], options);
            }
            if (message.startRaw != null && message.hasOwnProperty("startRaw"))
                object.startRaw = $root.SC2APIProtocol.StartRaw.toObject(message.startRaw, options);
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.SC2APIProtocol.InterfaceOptions.toObject(message.options, options);
            if (message.modNames && message.modNames.length) {
                object.modNames = [];
                for (var j = 0; j < message.modNames.length; ++j)
                    object.modNames[j] = message.modNames[j];
            }
            return object;
        };
        /**
         * Converts this ResponseGameInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseGameInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseGameInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseGameInfo;
    })();
    SC2APIProtocol.RequestObservation = (function () {
        /**
         * Properties of a RequestObservation.
         * @memberof SC2APIProtocol
         * @interface IRequestObservation
         * @property {boolean} [disableFog] RequestObservation disableFog
         */
        /**
         * Constructs a new RequestObservation.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestObservation.
         * @constructor
         * @param {SC2APIProtocol.IRequestObservation=} [properties] Properties to set
         */
        function RequestObservation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestObservation disableFog.
         * @member {boolean}disableFog
         * @memberof SC2APIProtocol.RequestObservation
         * @instance
         */
        RequestObservation.prototype.disableFog = false;
        /**
         * Creates a new RequestObservation instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {SC2APIProtocol.IRequestObservation=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestObservation} RequestObservation instance
         */
        RequestObservation.create = function create(properties) {
            return new RequestObservation(properties);
        };
        /**
         * Encodes the specified RequestObservation message. Does not implicitly {@link SC2APIProtocol.RequestObservation.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {SC2APIProtocol.IRequestObservation} message RequestObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestObservation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.disableFog);
            return writer;
        };
        /**
         * Encodes the specified RequestObservation message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestObservation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {SC2APIProtocol.IRequestObservation} message RequestObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestObservation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestObservation message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestObservation} RequestObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestObservation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestObservation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.disableFog = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestObservation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestObservation} RequestObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestObservation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestObservation message.
         * @function verify
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestObservation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                if (typeof message.disableFog !== "boolean")
                    return "disableFog: boolean expected";
            return null;
        };
        /**
         * Creates a RequestObservation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestObservation} RequestObservation
         */
        RequestObservation.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestObservation)
                return object;
            var message = new $root.SC2APIProtocol.RequestObservation();
            if (object.disableFog != null)
                message.disableFog = Boolean(object.disableFog);
            return message;
        };
        /**
         * Creates a plain object from a RequestObservation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestObservation
         * @static
         * @param {SC2APIProtocol.RequestObservation} message RequestObservation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestObservation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.disableFog = false;
            if (message.disableFog != null && message.hasOwnProperty("disableFog"))
                object.disableFog = message.disableFog;
            return object;
        };
        /**
         * Converts this RequestObservation to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestObservation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestObservation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestObservation;
    })();
    SC2APIProtocol.ResponseObservation = (function () {
        /**
         * Properties of a ResponseObservation.
         * @memberof SC2APIProtocol
         * @interface IResponseObservation
         * @property {Array.<SC2APIProtocol.IAction>} [actions] ResponseObservation actions
         * @property {Array.<SC2APIProtocol.IActionError>} [actionErrors] ResponseObservation actionErrors
         * @property {SC2APIProtocol.IObservation} [observation] ResponseObservation observation
         * @property {Array.<SC2APIProtocol.IPlayerResult>} [playerResult] ResponseObservation playerResult
         * @property {Array.<SC2APIProtocol.IChatReceived>} [chat] ResponseObservation chat
         */
        /**
         * Constructs a new ResponseObservation.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseObservation.
         * @constructor
         * @param {SC2APIProtocol.IResponseObservation=} [properties] Properties to set
         */
        function ResponseObservation(properties) {
            this.actions = [];
            this.actionErrors = [];
            this.playerResult = [];
            this.chat = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseObservation actions.
         * @member {Array.<SC2APIProtocol.IAction>}actions
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         */
        ResponseObservation.prototype.actions = $util.emptyArray;
        /**
         * ResponseObservation actionErrors.
         * @member {Array.<SC2APIProtocol.IActionError>}actionErrors
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         */
        ResponseObservation.prototype.actionErrors = $util.emptyArray;
        /**
         * ResponseObservation observation.
         * @member {(SC2APIProtocol.IObservation|null|undefined)}observation
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         */
        ResponseObservation.prototype.observation = null;
        /**
         * ResponseObservation playerResult.
         * @member {Array.<SC2APIProtocol.IPlayerResult>}playerResult
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         */
        ResponseObservation.prototype.playerResult = $util.emptyArray;
        /**
         * ResponseObservation chat.
         * @member {Array.<SC2APIProtocol.IChatReceived>}chat
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         */
        ResponseObservation.prototype.chat = $util.emptyArray;
        /**
         * Creates a new ResponseObservation instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {SC2APIProtocol.IResponseObservation=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseObservation} ResponseObservation instance
         */
        ResponseObservation.create = function create(properties) {
            return new ResponseObservation(properties);
        };
        /**
         * Encodes the specified ResponseObservation message. Does not implicitly {@link SC2APIProtocol.ResponseObservation.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {SC2APIProtocol.IResponseObservation} message ResponseObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseObservation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (var i = 0; i < message.actions.length; ++i)
                    $root.SC2APIProtocol.Action.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.actionErrors != null && message.actionErrors.length)
                for (var i = 0; i < message.actionErrors.length; ++i)
                    $root.SC2APIProtocol.ActionError.encode(message.actionErrors[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.observation != null && message.hasOwnProperty("observation"))
                $root.SC2APIProtocol.Observation.encode(message.observation, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.playerResult != null && message.playerResult.length)
                for (var i = 0; i < message.playerResult.length; ++i)
                    $root.SC2APIProtocol.PlayerResult.encode(message.playerResult[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.chat != null && message.chat.length)
                for (var i = 0; i < message.chat.length; ++i)
                    $root.SC2APIProtocol.ChatReceived.encode(message.chat[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ResponseObservation message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseObservation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {SC2APIProtocol.IResponseObservation} message ResponseObservation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseObservation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseObservation message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseObservation} ResponseObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseObservation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseObservation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.SC2APIProtocol.Action.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.actionErrors && message.actionErrors.length))
                            message.actionErrors = [];
                        message.actionErrors.push($root.SC2APIProtocol.ActionError.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.observation = $root.SC2APIProtocol.Observation.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.playerResult && message.playerResult.length))
                            message.playerResult = [];
                        message.playerResult.push($root.SC2APIProtocol.PlayerResult.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.chat && message.chat.length))
                            message.chat = [];
                        message.chat.push($root.SC2APIProtocol.ChatReceived.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseObservation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseObservation} ResponseObservation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseObservation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseObservation message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseObservation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (var i = 0; i < message.actions.length; ++i) {
                    var error = $root.SC2APIProtocol.Action.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.actionErrors != null && message.hasOwnProperty("actionErrors")) {
                if (!Array.isArray(message.actionErrors))
                    return "actionErrors: array expected";
                for (var i = 0; i < message.actionErrors.length; ++i) {
                    error = $root.SC2APIProtocol.ActionError.verify(message.actionErrors[i]);
                    if (error)
                        return "actionErrors." + error;
                }
            }
            if (message.observation != null && message.hasOwnProperty("observation")) {
                error = $root.SC2APIProtocol.Observation.verify(message.observation);
                if (error)
                    return "observation." + error;
            }
            if (message.playerResult != null && message.hasOwnProperty("playerResult")) {
                if (!Array.isArray(message.playerResult))
                    return "playerResult: array expected";
                for (var i = 0; i < message.playerResult.length; ++i) {
                    error = $root.SC2APIProtocol.PlayerResult.verify(message.playerResult[i]);
                    if (error)
                        return "playerResult." + error;
                }
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                if (!Array.isArray(message.chat))
                    return "chat: array expected";
                for (var i = 0; i < message.chat.length; ++i) {
                    error = $root.SC2APIProtocol.ChatReceived.verify(message.chat[i]);
                    if (error)
                        return "chat." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ResponseObservation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseObservation} ResponseObservation
         */
        ResponseObservation.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseObservation)
                return object;
            var message = new $root.SC2APIProtocol.ResponseObservation();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".SC2APIProtocol.ResponseObservation.actions: array expected");
                message.actions = [];
                for (var i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseObservation.actions: object expected");
                    message.actions[i] = $root.SC2APIProtocol.Action.fromObject(object.actions[i]);
                }
            }
            if (object.actionErrors) {
                if (!Array.isArray(object.actionErrors))
                    throw TypeError(".SC2APIProtocol.ResponseObservation.actionErrors: array expected");
                message.actionErrors = [];
                for (var i = 0; i < object.actionErrors.length; ++i) {
                    if (typeof object.actionErrors[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseObservation.actionErrors: object expected");
                    message.actionErrors[i] = $root.SC2APIProtocol.ActionError.fromObject(object.actionErrors[i]);
                }
            }
            if (object.observation != null) {
                if (typeof object.observation !== "object")
                    throw TypeError(".SC2APIProtocol.ResponseObservation.observation: object expected");
                message.observation = $root.SC2APIProtocol.Observation.fromObject(object.observation);
            }
            if (object.playerResult) {
                if (!Array.isArray(object.playerResult))
                    throw TypeError(".SC2APIProtocol.ResponseObservation.playerResult: array expected");
                message.playerResult = [];
                for (var i = 0; i < object.playerResult.length; ++i) {
                    if (typeof object.playerResult[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseObservation.playerResult: object expected");
                    message.playerResult[i] = $root.SC2APIProtocol.PlayerResult.fromObject(object.playerResult[i]);
                }
            }
            if (object.chat) {
                if (!Array.isArray(object.chat))
                    throw TypeError(".SC2APIProtocol.ResponseObservation.chat: array expected");
                message.chat = [];
                for (var i = 0; i < object.chat.length; ++i) {
                    if (typeof object.chat[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseObservation.chat: object expected");
                    message.chat[i] = $root.SC2APIProtocol.ChatReceived.fromObject(object.chat[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseObservation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseObservation
         * @static
         * @param {SC2APIProtocol.ResponseObservation} message ResponseObservation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseObservation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.actionErrors = [];
                object.playerResult = [];
                object.chat = [];
            }
            if (options.defaults)
                object.observation = null;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (var j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.SC2APIProtocol.Action.toObject(message.actions[j], options);
            }
            if (message.actionErrors && message.actionErrors.length) {
                object.actionErrors = [];
                for (var j = 0; j < message.actionErrors.length; ++j)
                    object.actionErrors[j] = $root.SC2APIProtocol.ActionError.toObject(message.actionErrors[j], options);
            }
            if (message.observation != null && message.hasOwnProperty("observation"))
                object.observation = $root.SC2APIProtocol.Observation.toObject(message.observation, options);
            if (message.playerResult && message.playerResult.length) {
                object.playerResult = [];
                for (var j = 0; j < message.playerResult.length; ++j)
                    object.playerResult[j] = $root.SC2APIProtocol.PlayerResult.toObject(message.playerResult[j], options);
            }
            if (message.chat && message.chat.length) {
                object.chat = [];
                for (var j = 0; j < message.chat.length; ++j)
                    object.chat[j] = $root.SC2APIProtocol.ChatReceived.toObject(message.chat[j], options);
            }
            return object;
        };
        /**
         * Converts this ResponseObservation to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseObservation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseObservation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseObservation;
    })();
    SC2APIProtocol.ChatReceived = (function () {
        /**
         * Properties of a ChatReceived.
         * @memberof SC2APIProtocol
         * @interface IChatReceived
         * @property {number} [playerId] ChatReceived playerId
         * @property {string} [message] ChatReceived message
         */
        /**
         * Constructs a new ChatReceived.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ChatReceived.
         * @constructor
         * @param {SC2APIProtocol.IChatReceived=} [properties] Properties to set
         */
        function ChatReceived(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ChatReceived playerId.
         * @member {number}playerId
         * @memberof SC2APIProtocol.ChatReceived
         * @instance
         */
        ChatReceived.prototype.playerId = 0;
        /**
         * ChatReceived message.
         * @member {string}message
         * @memberof SC2APIProtocol.ChatReceived
         * @instance
         */
        ChatReceived.prototype.message = "";
        /**
         * Creates a new ChatReceived instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {SC2APIProtocol.IChatReceived=} [properties] Properties to set
         * @returns {SC2APIProtocol.ChatReceived} ChatReceived instance
         */
        ChatReceived.create = function create(properties) {
            return new ChatReceived(properties);
        };
        /**
         * Encodes the specified ChatReceived message. Does not implicitly {@link SC2APIProtocol.ChatReceived.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {SC2APIProtocol.IChatReceived} message ChatReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatReceived.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.playerId);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.message);
            return writer;
        };
        /**
         * Encodes the specified ChatReceived message, length delimited. Does not implicitly {@link SC2APIProtocol.ChatReceived.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {SC2APIProtocol.IChatReceived} message ChatReceived message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatReceived.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ChatReceived message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ChatReceived} ChatReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatReceived.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ChatReceived();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ChatReceived message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ChatReceived} ChatReceived
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatReceived.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ChatReceived message.
         * @function verify
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatReceived.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId))
                    return "playerId: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
        /**
         * Creates a ChatReceived message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ChatReceived} ChatReceived
         */
        ChatReceived.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ChatReceived)
                return object;
            var message = new $root.SC2APIProtocol.ChatReceived();
            if (object.playerId != null)
                message.playerId = object.playerId | 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
        /**
         * Creates a plain object from a ChatReceived message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ChatReceived
         * @static
         * @param {SC2APIProtocol.ChatReceived} message ChatReceived
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatReceived.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerId = 0;
                object.message = "";
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
        /**
         * Converts this ChatReceived to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ChatReceived
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatReceived.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ChatReceived;
    })();
    SC2APIProtocol.RequestAction = (function () {
        /**
         * Properties of a RequestAction.
         * @memberof SC2APIProtocol
         * @interface IRequestAction
         * @property {Array.<SC2APIProtocol.IAction>} [actions] RequestAction actions
         */
        /**
         * Constructs a new RequestAction.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestAction.
         * @constructor
         * @param {SC2APIProtocol.IRequestAction=} [properties] Properties to set
         */
        function RequestAction(properties) {
            this.actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestAction actions.
         * @member {Array.<SC2APIProtocol.IAction>}actions
         * @memberof SC2APIProtocol.RequestAction
         * @instance
         */
        RequestAction.prototype.actions = $util.emptyArray;
        /**
         * Creates a new RequestAction instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {SC2APIProtocol.IRequestAction=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestAction} RequestAction instance
         */
        RequestAction.create = function create(properties) {
            return new RequestAction(properties);
        };
        /**
         * Encodes the specified RequestAction message. Does not implicitly {@link SC2APIProtocol.RequestAction.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {SC2APIProtocol.IRequestAction} message RequestAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (var i = 0; i < message.actions.length; ++i)
                    $root.SC2APIProtocol.Action.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified RequestAction message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {SC2APIProtocol.IRequestAction} message RequestAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestAction message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestAction} RequestAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.SC2APIProtocol.Action.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestAction} RequestAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestAction message.
         * @function verify
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (var i = 0; i < message.actions.length; ++i) {
                    var error = $root.SC2APIProtocol.Action.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };
        /**
         * Creates a RequestAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestAction} RequestAction
         */
        RequestAction.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestAction)
                return object;
            var message = new $root.SC2APIProtocol.RequestAction();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".SC2APIProtocol.RequestAction.actions: array expected");
                message.actions = [];
                for (var i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestAction.actions: object expected");
                    message.actions[i] = $root.SC2APIProtocol.Action.fromObject(object.actions[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a RequestAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestAction
         * @static
         * @param {SC2APIProtocol.RequestAction} message RequestAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (var j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.SC2APIProtocol.Action.toObject(message.actions[j], options);
            }
            return object;
        };
        /**
         * Converts this RequestAction to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestAction;
    })();
    SC2APIProtocol.ResponseAction = (function () {
        /**
         * Properties of a ResponseAction.
         * @memberof SC2APIProtocol
         * @interface IResponseAction
         * @property {Array.<SC2APIProtocol.ActionResult>} [result] ResponseAction result
         */
        /**
         * Constructs a new ResponseAction.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseAction.
         * @constructor
         * @param {SC2APIProtocol.IResponseAction=} [properties] Properties to set
         */
        function ResponseAction(properties) {
            this.result = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseAction result.
         * @member {Array.<SC2APIProtocol.ActionResult>}result
         * @memberof SC2APIProtocol.ResponseAction
         * @instance
         */
        ResponseAction.prototype.result = $util.emptyArray;
        /**
         * Creates a new ResponseAction instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {SC2APIProtocol.IResponseAction=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseAction} ResponseAction instance
         */
        ResponseAction.create = function create(properties) {
            return new ResponseAction(properties);
        };
        /**
         * Encodes the specified ResponseAction message. Does not implicitly {@link SC2APIProtocol.ResponseAction.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {SC2APIProtocol.IResponseAction} message ResponseAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.result.length)
                for (var i = 0; i < message.result.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result[i]);
            return writer;
        };
        /**
         * Encodes the specified ResponseAction message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {SC2APIProtocol.IResponseAction} message ResponseAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseAction message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseAction} ResponseAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.result && message.result.length))
                            message.result = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.result.push(reader.int32());
                        }
                        else
                            message.result.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseAction} ResponseAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseAction message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                if (!Array.isArray(message.result))
                    return "result: array expected";
                for (var i = 0; i < message.result.length; ++i)
                    switch (message.result[i]) {
                        default:
                            return "result: enum value[] expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                        case 27:
                        case 28:
                        case 29:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                        case 34:
                        case 35:
                        case 36:
                        case 37:
                        case 38:
                        case 39:
                        case 40:
                        case 41:
                        case 42:
                        case 43:
                        case 44:
                        case 45:
                        case 46:
                        case 47:
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                        case 56:
                        case 57:
                        case 58:
                        case 59:
                        case 60:
                        case 61:
                        case 62:
                        case 63:
                        case 64:
                        case 65:
                        case 66:
                        case 67:
                        case 68:
                        case 69:
                        case 70:
                        case 71:
                        case 72:
                        case 73:
                        case 74:
                        case 75:
                        case 76:
                        case 77:
                        case 78:
                        case 79:
                        case 80:
                        case 81:
                        case 82:
                        case 83:
                        case 84:
                        case 85:
                        case 86:
                        case 87:
                        case 88:
                        case 89:
                        case 90:
                        case 91:
                        case 92:
                        case 93:
                        case 94:
                        case 95:
                        case 96:
                        case 97:
                        case 98:
                        case 99:
                        case 100:
                        case 101:
                        case 102:
                        case 103:
                        case 104:
                        case 105:
                        case 106:
                        case 107:
                        case 108:
                        case 109:
                        case 110:
                        case 111:
                        case 112:
                        case 113:
                        case 114:
                        case 115:
                        case 116:
                        case 117:
                        case 118:
                        case 119:
                        case 120:
                        case 121:
                        case 122:
                        case 123:
                        case 124:
                        case 125:
                        case 126:
                        case 127:
                        case 128:
                        case 129:
                        case 130:
                        case 131:
                        case 132:
                        case 133:
                        case 134:
                        case 135:
                        case 136:
                        case 137:
                        case 138:
                        case 139:
                        case 140:
                        case 141:
                        case 142:
                        case 143:
                        case 144:
                        case 145:
                        case 146:
                        case 147:
                        case 148:
                        case 149:
                        case 150:
                        case 151:
                        case 152:
                        case 153:
                        case 154:
                        case 155:
                        case 156:
                        case 157:
                        case 158:
                        case 159:
                        case 160:
                        case 161:
                        case 162:
                        case 163:
                        case 164:
                        case 165:
                        case 166:
                        case 167:
                        case 168:
                        case 169:
                        case 170:
                        case 171:
                        case 172:
                        case 173:
                        case 174:
                        case 175:
                        case 176:
                        case 177:
                        case 178:
                        case 179:
                        case 180:
                        case 181:
                        case 182:
                        case 183:
                        case 184:
                        case 185:
                        case 186:
                        case 187:
                        case 188:
                        case 189:
                        case 190:
                        case 191:
                        case 192:
                        case 193:
                        case 194:
                        case 195:
                        case 196:
                        case 197:
                        case 198:
                        case 199:
                        case 200:
                        case 201:
                        case 202:
                        case 203:
                        case 204:
                        case 205:
                        case 206:
                        case 207:
                        case 208:
                        case 209:
                        case 210:
                        case 211:
                        case 212:
                        case 213:
                        case 214:
                            break;
                    }
            }
            return null;
        };
        /**
         * Creates a ResponseAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseAction} ResponseAction
         */
        ResponseAction.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseAction)
                return object;
            var message = new $root.SC2APIProtocol.ResponseAction();
            if (object.result) {
                if (!Array.isArray(object.result))
                    throw TypeError(".SC2APIProtocol.ResponseAction.result: array expected");
                message.result = [];
                for (var i = 0; i < object.result.length; ++i)
                    switch (object.result[i]) {
                        default:
                        case "Success":
                        case 1:
                            message.result[i] = 1;
                            break;
                        case "NotSupported":
                        case 2:
                            message.result[i] = 2;
                            break;
                        case "Error":
                        case 3:
                            message.result[i] = 3;
                            break;
                        case "CantQueueThatOrder":
                        case 4:
                            message.result[i] = 4;
                            break;
                        case "Retry":
                        case 5:
                            message.result[i] = 5;
                            break;
                        case "Cooldown":
                        case 6:
                            message.result[i] = 6;
                            break;
                        case "QueueIsFull":
                        case 7:
                            message.result[i] = 7;
                            break;
                        case "RallyQueueIsFull":
                        case 8:
                            message.result[i] = 8;
                            break;
                        case "NotEnoughMinerals":
                        case 9:
                            message.result[i] = 9;
                            break;
                        case "NotEnoughVespene":
                        case 10:
                            message.result[i] = 10;
                            break;
                        case "NotEnoughTerrazine":
                        case 11:
                            message.result[i] = 11;
                            break;
                        case "NotEnoughCustom":
                        case 12:
                            message.result[i] = 12;
                            break;
                        case "NotEnoughFood":
                        case 13:
                            message.result[i] = 13;
                            break;
                        case "FoodUsageImpossible":
                        case 14:
                            message.result[i] = 14;
                            break;
                        case "NotEnoughLife":
                        case 15:
                            message.result[i] = 15;
                            break;
                        case "NotEnoughShields":
                        case 16:
                            message.result[i] = 16;
                            break;
                        case "NotEnoughEnergy":
                        case 17:
                            message.result[i] = 17;
                            break;
                        case "LifeSuppressed":
                        case 18:
                            message.result[i] = 18;
                            break;
                        case "ShieldsSuppressed":
                        case 19:
                            message.result[i] = 19;
                            break;
                        case "EnergySuppressed":
                        case 20:
                            message.result[i] = 20;
                            break;
                        case "NotEnoughCharges":
                        case 21:
                            message.result[i] = 21;
                            break;
                        case "CantAddMoreCharges":
                        case 22:
                            message.result[i] = 22;
                            break;
                        case "TooMuchMinerals":
                        case 23:
                            message.result[i] = 23;
                            break;
                        case "TooMuchVespene":
                        case 24:
                            message.result[i] = 24;
                            break;
                        case "TooMuchTerrazine":
                        case 25:
                            message.result[i] = 25;
                            break;
                        case "TooMuchCustom":
                        case 26:
                            message.result[i] = 26;
                            break;
                        case "TooMuchFood":
                        case 27:
                            message.result[i] = 27;
                            break;
                        case "TooMuchLife":
                        case 28:
                            message.result[i] = 28;
                            break;
                        case "TooMuchShields":
                        case 29:
                            message.result[i] = 29;
                            break;
                        case "TooMuchEnergy":
                        case 30:
                            message.result[i] = 30;
                            break;
                        case "MustTargetUnitWithLife":
                        case 31:
                            message.result[i] = 31;
                            break;
                        case "MustTargetUnitWithShields":
                        case 32:
                            message.result[i] = 32;
                            break;
                        case "MustTargetUnitWithEnergy":
                        case 33:
                            message.result[i] = 33;
                            break;
                        case "CantTrade":
                        case 34:
                            message.result[i] = 34;
                            break;
                        case "CantSpend":
                        case 35:
                            message.result[i] = 35;
                            break;
                        case "CantTargetThatUnit":
                        case 36:
                            message.result[i] = 36;
                            break;
                        case "CouldntAllocateUnit":
                        case 37:
                            message.result[i] = 37;
                            break;
                        case "UnitCantMove":
                        case 38:
                            message.result[i] = 38;
                            break;
                        case "TransportIsHoldingPosition":
                        case 39:
                            message.result[i] = 39;
                            break;
                        case "BuildTechRequirementsNotMet":
                        case 40:
                            message.result[i] = 40;
                            break;
                        case "CantFindPlacementLocation":
                        case 41:
                            message.result[i] = 41;
                            break;
                        case "CantBuildOnThat":
                        case 42:
                            message.result[i] = 42;
                            break;
                        case "CantBuildTooCloseToDropOff":
                        case 43:
                            message.result[i] = 43;
                            break;
                        case "CantBuildLocationInvalid":
                        case 44:
                            message.result[i] = 44;
                            break;
                        case "CantSeeBuildLocation":
                        case 45:
                            message.result[i] = 45;
                            break;
                        case "CantBuildTooCloseToCreepSource":
                        case 46:
                            message.result[i] = 46;
                            break;
                        case "CantBuildTooCloseToResources":
                        case 47:
                            message.result[i] = 47;
                            break;
                        case "CantBuildTooFarFromWater":
                        case 48:
                            message.result[i] = 48;
                            break;
                        case "CantBuildTooFarFromCreepSource":
                        case 49:
                            message.result[i] = 49;
                            break;
                        case "CantBuildTooFarFromBuildPowerSource":
                        case 50:
                            message.result[i] = 50;
                            break;
                        case "CantBuildOnDenseTerrain":
                        case 51:
                            message.result[i] = 51;
                            break;
                        case "CantTrainTooFarFromTrainPowerSource":
                        case 52:
                            message.result[i] = 52;
                            break;
                        case "CantLandLocationInvalid":
                        case 53:
                            message.result[i] = 53;
                            break;
                        case "CantSeeLandLocation":
                        case 54:
                            message.result[i] = 54;
                            break;
                        case "CantLandTooCloseToCreepSource":
                        case 55:
                            message.result[i] = 55;
                            break;
                        case "CantLandTooCloseToResources":
                        case 56:
                            message.result[i] = 56;
                            break;
                        case "CantLandTooFarFromWater":
                        case 57:
                            message.result[i] = 57;
                            break;
                        case "CantLandTooFarFromCreepSource":
                        case 58:
                            message.result[i] = 58;
                            break;
                        case "CantLandTooFarFromBuildPowerSource":
                        case 59:
                            message.result[i] = 59;
                            break;
                        case "CantLandTooFarFromTrainPowerSource":
                        case 60:
                            message.result[i] = 60;
                            break;
                        case "CantLandOnDenseTerrain":
                        case 61:
                            message.result[i] = 61;
                            break;
                        case "AddOnTooFarFromBuilding":
                        case 62:
                            message.result[i] = 62;
                            break;
                        case "MustBuildRefineryFirst":
                        case 63:
                            message.result[i] = 63;
                            break;
                        case "BuildingIsUnderConstruction":
                        case 64:
                            message.result[i] = 64;
                            break;
                        case "CantFindDropOff":
                        case 65:
                            message.result[i] = 65;
                            break;
                        case "CantLoadOtherPlayersUnits":
                        case 66:
                            message.result[i] = 66;
                            break;
                        case "NotEnoughRoomToLoadUnit":
                        case 67:
                            message.result[i] = 67;
                            break;
                        case "CantUnloadUnitsThere":
                        case 68:
                            message.result[i] = 68;
                            break;
                        case "CantWarpInUnitsThere":
                        case 69:
                            message.result[i] = 69;
                            break;
                        case "CantLoadImmobileUnits":
                        case 70:
                            message.result[i] = 70;
                            break;
                        case "CantRechargeImmobileUnits":
                        case 71:
                            message.result[i] = 71;
                            break;
                        case "CantRechargeUnderConstructionUnits":
                        case 72:
                            message.result[i] = 72;
                            break;
                        case "CantLoadThatUnit":
                        case 73:
                            message.result[i] = 73;
                            break;
                        case "NoCargoToUnload":
                        case 74:
                            message.result[i] = 74;
                            break;
                        case "LoadAllNoTargetsFound":
                        case 75:
                            message.result[i] = 75;
                            break;
                        case "NotWhileOccupied":
                        case 76:
                            message.result[i] = 76;
                            break;
                        case "CantAttackWithoutAmmo":
                        case 77:
                            message.result[i] = 77;
                            break;
                        case "CantHoldAnyMoreAmmo":
                        case 78:
                            message.result[i] = 78;
                            break;
                        case "TechRequirementsNotMet":
                        case 79:
                            message.result[i] = 79;
                            break;
                        case "MustLockdownUnitFirst":
                        case 80:
                            message.result[i] = 80;
                            break;
                        case "MustTargetUnit":
                        case 81:
                            message.result[i] = 81;
                            break;
                        case "MustTargetInventory":
                        case 82:
                            message.result[i] = 82;
                            break;
                        case "MustTargetVisibleUnit":
                        case 83:
                            message.result[i] = 83;
                            break;
                        case "MustTargetVisibleLocation":
                        case 84:
                            message.result[i] = 84;
                            break;
                        case "MustTargetWalkableLocation":
                        case 85:
                            message.result[i] = 85;
                            break;
                        case "MustTargetPawnableUnit":
                        case 86:
                            message.result[i] = 86;
                            break;
                        case "YouCantControlThatUnit":
                        case 87:
                            message.result[i] = 87;
                            break;
                        case "YouCantIssueCommandsToThatUnit":
                        case 88:
                            message.result[i] = 88;
                            break;
                        case "MustTargetResources":
                        case 89:
                            message.result[i] = 89;
                            break;
                        case "RequiresHealTarget":
                        case 90:
                            message.result[i] = 90;
                            break;
                        case "RequiresRepairTarget":
                        case 91:
                            message.result[i] = 91;
                            break;
                        case "NoItemsToDrop":
                        case 92:
                            message.result[i] = 92;
                            break;
                        case "CantHoldAnyMoreItems":
                        case 93:
                            message.result[i] = 93;
                            break;
                        case "CantHoldThat":
                        case 94:
                            message.result[i] = 94;
                            break;
                        case "TargetHasNoInventory":
                        case 95:
                            message.result[i] = 95;
                            break;
                        case "CantDropThisItem":
                        case 96:
                            message.result[i] = 96;
                            break;
                        case "CantMoveThisItem":
                        case 97:
                            message.result[i] = 97;
                            break;
                        case "CantPawnThisUnit":
                        case 98:
                            message.result[i] = 98;
                            break;
                        case "MustTargetCaster":
                        case 99:
                            message.result[i] = 99;
                            break;
                        case "CantTargetCaster":
                        case 100:
                            message.result[i] = 100;
                            break;
                        case "MustTargetOuter":
                        case 101:
                            message.result[i] = 101;
                            break;
                        case "CantTargetOuter":
                        case 102:
                            message.result[i] = 102;
                            break;
                        case "MustTargetYourOwnUnits":
                        case 103:
                            message.result[i] = 103;
                            break;
                        case "CantTargetYourOwnUnits":
                        case 104:
                            message.result[i] = 104;
                            break;
                        case "MustTargetFriendlyUnits":
                        case 105:
                            message.result[i] = 105;
                            break;
                        case "CantTargetFriendlyUnits":
                        case 106:
                            message.result[i] = 106;
                            break;
                        case "MustTargetNeutralUnits":
                        case 107:
                            message.result[i] = 107;
                            break;
                        case "CantTargetNeutralUnits":
                        case 108:
                            message.result[i] = 108;
                            break;
                        case "MustTargetEnemyUnits":
                        case 109:
                            message.result[i] = 109;
                            break;
                        case "CantTargetEnemyUnits":
                        case 110:
                            message.result[i] = 110;
                            break;
                        case "MustTargetAirUnits":
                        case 111:
                            message.result[i] = 111;
                            break;
                        case "CantTargetAirUnits":
                        case 112:
                            message.result[i] = 112;
                            break;
                        case "MustTargetGroundUnits":
                        case 113:
                            message.result[i] = 113;
                            break;
                        case "CantTargetGroundUnits":
                        case 114:
                            message.result[i] = 114;
                            break;
                        case "MustTargetStructures":
                        case 115:
                            message.result[i] = 115;
                            break;
                        case "CantTargetStructures":
                        case 116:
                            message.result[i] = 116;
                            break;
                        case "MustTargetLightUnits":
                        case 117:
                            message.result[i] = 117;
                            break;
                        case "CantTargetLightUnits":
                        case 118:
                            message.result[i] = 118;
                            break;
                        case "MustTargetArmoredUnits":
                        case 119:
                            message.result[i] = 119;
                            break;
                        case "CantTargetArmoredUnits":
                        case 120:
                            message.result[i] = 120;
                            break;
                        case "MustTargetBiologicalUnits":
                        case 121:
                            message.result[i] = 121;
                            break;
                        case "CantTargetBiologicalUnits":
                        case 122:
                            message.result[i] = 122;
                            break;
                        case "MustTargetHeroicUnits":
                        case 123:
                            message.result[i] = 123;
                            break;
                        case "CantTargetHeroicUnits":
                        case 124:
                            message.result[i] = 124;
                            break;
                        case "MustTargetRoboticUnits":
                        case 125:
                            message.result[i] = 125;
                            break;
                        case "CantTargetRoboticUnits":
                        case 126:
                            message.result[i] = 126;
                            break;
                        case "MustTargetMechanicalUnits":
                        case 127:
                            message.result[i] = 127;
                            break;
                        case "CantTargetMechanicalUnits":
                        case 128:
                            message.result[i] = 128;
                            break;
                        case "MustTargetPsionicUnits":
                        case 129:
                            message.result[i] = 129;
                            break;
                        case "CantTargetPsionicUnits":
                        case 130:
                            message.result[i] = 130;
                            break;
                        case "MustTargetMassiveUnits":
                        case 131:
                            message.result[i] = 131;
                            break;
                        case "CantTargetMassiveUnits":
                        case 132:
                            message.result[i] = 132;
                            break;
                        case "MustTargetMissile":
                        case 133:
                            message.result[i] = 133;
                            break;
                        case "CantTargetMissile":
                        case 134:
                            message.result[i] = 134;
                            break;
                        case "MustTargetWorkerUnits":
                        case 135:
                            message.result[i] = 135;
                            break;
                        case "CantTargetWorkerUnits":
                        case 136:
                            message.result[i] = 136;
                            break;
                        case "MustTargetEnergyCapableUnits":
                        case 137:
                            message.result[i] = 137;
                            break;
                        case "CantTargetEnergyCapableUnits":
                        case 138:
                            message.result[i] = 138;
                            break;
                        case "MustTargetShieldCapableUnits":
                        case 139:
                            message.result[i] = 139;
                            break;
                        case "CantTargetShieldCapableUnits":
                        case 140:
                            message.result[i] = 140;
                            break;
                        case "MustTargetFlyers":
                        case 141:
                            message.result[i] = 141;
                            break;
                        case "CantTargetFlyers":
                        case 142:
                            message.result[i] = 142;
                            break;
                        case "MustTargetBuriedUnits":
                        case 143:
                            message.result[i] = 143;
                            break;
                        case "CantTargetBuriedUnits":
                        case 144:
                            message.result[i] = 144;
                            break;
                        case "MustTargetCloakedUnits":
                        case 145:
                            message.result[i] = 145;
                            break;
                        case "CantTargetCloakedUnits":
                        case 146:
                            message.result[i] = 146;
                            break;
                        case "MustTargetUnitsInAStasisField":
                        case 147:
                            message.result[i] = 147;
                            break;
                        case "CantTargetUnitsInAStasisField":
                        case 148:
                            message.result[i] = 148;
                            break;
                        case "MustTargetUnderConstructionUnits":
                        case 149:
                            message.result[i] = 149;
                            break;
                        case "CantTargetUnderConstructionUnits":
                        case 150:
                            message.result[i] = 150;
                            break;
                        case "MustTargetDeadUnits":
                        case 151:
                            message.result[i] = 151;
                            break;
                        case "CantTargetDeadUnits":
                        case 152:
                            message.result[i] = 152;
                            break;
                        case "MustTargetRevivableUnits":
                        case 153:
                            message.result[i] = 153;
                            break;
                        case "CantTargetRevivableUnits":
                        case 154:
                            message.result[i] = 154;
                            break;
                        case "MustTargetHiddenUnits":
                        case 155:
                            message.result[i] = 155;
                            break;
                        case "CantTargetHiddenUnits":
                        case 156:
                            message.result[i] = 156;
                            break;
                        case "CantRechargeOtherPlayersUnits":
                        case 157:
                            message.result[i] = 157;
                            break;
                        case "MustTargetHallucinations":
                        case 158:
                            message.result[i] = 158;
                            break;
                        case "CantTargetHallucinations":
                        case 159:
                            message.result[i] = 159;
                            break;
                        case "MustTargetInvulnerableUnits":
                        case 160:
                            message.result[i] = 160;
                            break;
                        case "CantTargetInvulnerableUnits":
                        case 161:
                            message.result[i] = 161;
                            break;
                        case "MustTargetDetectedUnits":
                        case 162:
                            message.result[i] = 162;
                            break;
                        case "CantTargetDetectedUnits":
                        case 163:
                            message.result[i] = 163;
                            break;
                        case "CantTargetUnitWithEnergy":
                        case 164:
                            message.result[i] = 164;
                            break;
                        case "CantTargetUnitWithShields":
                        case 165:
                            message.result[i] = 165;
                            break;
                        case "MustTargetUncommandableUnits":
                        case 166:
                            message.result[i] = 166;
                            break;
                        case "CantTargetUncommandableUnits":
                        case 167:
                            message.result[i] = 167;
                            break;
                        case "MustTargetPreventDefeatUnits":
                        case 168:
                            message.result[i] = 168;
                            break;
                        case "CantTargetPreventDefeatUnits":
                        case 169:
                            message.result[i] = 169;
                            break;
                        case "MustTargetPreventRevealUnits":
                        case 170:
                            message.result[i] = 170;
                            break;
                        case "CantTargetPreventRevealUnits":
                        case 171:
                            message.result[i] = 171;
                            break;
                        case "MustTargetPassiveUnits":
                        case 172:
                            message.result[i] = 172;
                            break;
                        case "CantTargetPassiveUnits":
                        case 173:
                            message.result[i] = 173;
                            break;
                        case "MustTargetStunnedUnits":
                        case 174:
                            message.result[i] = 174;
                            break;
                        case "CantTargetStunnedUnits":
                        case 175:
                            message.result[i] = 175;
                            break;
                        case "MustTargetSummonedUnits":
                        case 176:
                            message.result[i] = 176;
                            break;
                        case "CantTargetSummonedUnits":
                        case 177:
                            message.result[i] = 177;
                            break;
                        case "MustTargetUser1":
                        case 178:
                            message.result[i] = 178;
                            break;
                        case "CantTargetUser1":
                        case 179:
                            message.result[i] = 179;
                            break;
                        case "MustTargetUnstoppableUnits":
                        case 180:
                            message.result[i] = 180;
                            break;
                        case "CantTargetUnstoppableUnits":
                        case 181:
                            message.result[i] = 181;
                            break;
                        case "MustTargetResistantUnits":
                        case 182:
                            message.result[i] = 182;
                            break;
                        case "CantTargetResistantUnits":
                        case 183:
                            message.result[i] = 183;
                            break;
                        case "MustTargetDazedUnits":
                        case 184:
                            message.result[i] = 184;
                            break;
                        case "CantTargetDazedUnits":
                        case 185:
                            message.result[i] = 185;
                            break;
                        case "CantLockdown":
                        case 186:
                            message.result[i] = 186;
                            break;
                        case "CantMindControl":
                        case 187:
                            message.result[i] = 187;
                            break;
                        case "MustTargetDestructibles":
                        case 188:
                            message.result[i] = 188;
                            break;
                        case "CantTargetDestructibles":
                        case 189:
                            message.result[i] = 189;
                            break;
                        case "MustTargetItems":
                        case 190:
                            message.result[i] = 190;
                            break;
                        case "CantTargetItems":
                        case 191:
                            message.result[i] = 191;
                            break;
                        case "NoCalldownAvailable":
                        case 192:
                            message.result[i] = 192;
                            break;
                        case "WaypointListFull":
                        case 193:
                            message.result[i] = 193;
                            break;
                        case "MustTargetRace":
                        case 194:
                            message.result[i] = 194;
                            break;
                        case "CantTargetRace":
                        case 195:
                            message.result[i] = 195;
                            break;
                        case "MustTargetSimilarUnits":
                        case 196:
                            message.result[i] = 196;
                            break;
                        case "CantTargetSimilarUnits":
                        case 197:
                            message.result[i] = 197;
                            break;
                        case "CantFindEnoughTargets":
                        case 198:
                            message.result[i] = 198;
                            break;
                        case "AlreadySpawningLarva":
                        case 199:
                            message.result[i] = 199;
                            break;
                        case "CantTargetExhaustedResources":
                        case 200:
                            message.result[i] = 200;
                            break;
                        case "CantUseMinimap":
                        case 201:
                            message.result[i] = 201;
                            break;
                        case "CantUseInfoPanel":
                        case 202:
                            message.result[i] = 202;
                            break;
                        case "OrderQueueIsFull":
                        case 203:
                            message.result[i] = 203;
                            break;
                        case "CantHarvestThatResource":
                        case 204:
                            message.result[i] = 204;
                            break;
                        case "HarvestersNotRequired":
                        case 205:
                            message.result[i] = 205;
                            break;
                        case "AlreadyTargeted":
                        case 206:
                            message.result[i] = 206;
                            break;
                        case "CantAttackWeaponsDisabled":
                        case 207:
                            message.result[i] = 207;
                            break;
                        case "CouldntReachTarget":
                        case 208:
                            message.result[i] = 208;
                            break;
                        case "TargetIsOutOfRange":
                        case 209:
                            message.result[i] = 209;
                            break;
                        case "TargetIsTooClose":
                        case 210:
                            message.result[i] = 210;
                            break;
                        case "TargetIsOutOfArc":
                        case 211:
                            message.result[i] = 211;
                            break;
                        case "CantFindTeleportLocation":
                        case 212:
                            message.result[i] = 212;
                            break;
                        case "InvalidItemClass":
                        case 213:
                            message.result[i] = 213;
                            break;
                        case "CantFindCancelOrder":
                        case 214:
                            message.result[i] = 214;
                            break;
                    }
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseAction
         * @static
         * @param {SC2APIProtocol.ResponseAction} message ResponseAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.result = [];
            if (message.result && message.result.length) {
                object.result = [];
                for (var j = 0; j < message.result.length; ++j)
                    object.result[j] = options.enums === String ? $root.SC2APIProtocol.ActionResult[message.result[j]] : message.result[j];
            }
            return object;
        };
        /**
         * Converts this ResponseAction to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseAction;
    })();
    SC2APIProtocol.RequestStep = (function () {
        /**
         * Properties of a RequestStep.
         * @memberof SC2APIProtocol
         * @interface IRequestStep
         * @property {number} [count] RequestStep count
         */
        /**
         * Constructs a new RequestStep.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestStep.
         * @constructor
         * @param {SC2APIProtocol.IRequestStep=} [properties] Properties to set
         */
        function RequestStep(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestStep count.
         * @member {number}count
         * @memberof SC2APIProtocol.RequestStep
         * @instance
         */
        RequestStep.prototype.count = 0;
        /**
         * Creates a new RequestStep instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {SC2APIProtocol.IRequestStep=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestStep} RequestStep instance
         */
        RequestStep.create = function create(properties) {
            return new RequestStep(properties);
        };
        /**
         * Encodes the specified RequestStep message. Does not implicitly {@link SC2APIProtocol.RequestStep.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {SC2APIProtocol.IRequestStep} message RequestStep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestStep.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.count);
            return writer;
        };
        /**
         * Encodes the specified RequestStep message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestStep.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {SC2APIProtocol.IRequestStep} message RequestStep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestStep.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestStep message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestStep} RequestStep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestStep.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestStep();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.count = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestStep message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestStep} RequestStep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestStep.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestStep message.
         * @function verify
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestStep.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };
        /**
         * Creates a RequestStep message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestStep} RequestStep
         */
        RequestStep.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestStep)
                return object;
            var message = new $root.SC2APIProtocol.RequestStep();
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a RequestStep message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestStep
         * @static
         * @param {SC2APIProtocol.RequestStep} message RequestStep
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestStep.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };
        /**
         * Converts this RequestStep to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestStep
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestStep.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestStep;
    })();
    SC2APIProtocol.ResponseStep = (function () {
        /**
         * Properties of a ResponseStep.
         * @memberof SC2APIProtocol
         * @interface IResponseStep
         */
        /**
         * Constructs a new ResponseStep.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseStep.
         * @constructor
         * @param {SC2APIProtocol.IResponseStep=} [properties] Properties to set
         */
        function ResponseStep(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseStep instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {SC2APIProtocol.IResponseStep=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseStep} ResponseStep instance
         */
        ResponseStep.create = function create(properties) {
            return new ResponseStep(properties);
        };
        /**
         * Encodes the specified ResponseStep message. Does not implicitly {@link SC2APIProtocol.ResponseStep.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {SC2APIProtocol.IResponseStep} message ResponseStep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseStep.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseStep message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseStep.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {SC2APIProtocol.IResponseStep} message ResponseStep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseStep.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseStep message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseStep} ResponseStep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseStep.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseStep();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseStep message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseStep} ResponseStep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseStep.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseStep message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseStep.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseStep message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseStep} ResponseStep
         */
        ResponseStep.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseStep)
                return object;
            return new $root.SC2APIProtocol.ResponseStep();
        };
        /**
         * Creates a plain object from a ResponseStep message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseStep
         * @static
         * @param {SC2APIProtocol.ResponseStep} message ResponseStep
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseStep.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseStep to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseStep
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseStep.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseStep;
    })();
    SC2APIProtocol.RequestData = (function () {
        /**
         * Properties of a RequestData.
         * @memberof SC2APIProtocol
         * @interface IRequestData
         * @property {boolean} [abilityId] RequestData abilityId
         * @property {boolean} [unitTypeId] RequestData unitTypeId
         * @property {boolean} [upgradeId] RequestData upgradeId
         * @property {boolean} [buffId] RequestData buffId
         */
        /**
         * Constructs a new RequestData.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestData.
         * @constructor
         * @param {SC2APIProtocol.IRequestData=} [properties] Properties to set
         */
        function RequestData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestData abilityId.
         * @member {boolean}abilityId
         * @memberof SC2APIProtocol.RequestData
         * @instance
         */
        RequestData.prototype.abilityId = false;
        /**
         * RequestData unitTypeId.
         * @member {boolean}unitTypeId
         * @memberof SC2APIProtocol.RequestData
         * @instance
         */
        RequestData.prototype.unitTypeId = false;
        /**
         * RequestData upgradeId.
         * @member {boolean}upgradeId
         * @memberof SC2APIProtocol.RequestData
         * @instance
         */
        RequestData.prototype.upgradeId = false;
        /**
         * RequestData buffId.
         * @member {boolean}buffId
         * @memberof SC2APIProtocol.RequestData
         * @instance
         */
        RequestData.prototype.buffId = false;
        /**
         * Creates a new RequestData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {SC2APIProtocol.IRequestData=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestData} RequestData instance
         */
        RequestData.create = function create(properties) {
            return new RequestData(properties);
        };
        /**
         * Encodes the specified RequestData message. Does not implicitly {@link SC2APIProtocol.RequestData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {SC2APIProtocol.IRequestData} message RequestData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.abilityId);
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.unitTypeId);
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.upgradeId);
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.buffId);
            return writer;
        };
        /**
         * Encodes the specified RequestData message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {SC2APIProtocol.IRequestData} message RequestData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestData} RequestData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.bool();
                        break;
                    case 2:
                        message.unitTypeId = reader.bool();
                        break;
                    case 3:
                        message.upgradeId = reader.bool();
                        break;
                    case 4:
                        message.buffId = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestData} RequestData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestData message.
         * @function verify
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (typeof message.abilityId !== "boolean")
                    return "abilityId: boolean expected";
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                if (typeof message.unitTypeId !== "boolean")
                    return "unitTypeId: boolean expected";
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                if (typeof message.upgradeId !== "boolean")
                    return "upgradeId: boolean expected";
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                if (typeof message.buffId !== "boolean")
                    return "buffId: boolean expected";
            return null;
        };
        /**
         * Creates a RequestData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestData} RequestData
         */
        RequestData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestData)
                return object;
            var message = new $root.SC2APIProtocol.RequestData();
            if (object.abilityId != null)
                message.abilityId = Boolean(object.abilityId);
            if (object.unitTypeId != null)
                message.unitTypeId = Boolean(object.unitTypeId);
            if (object.upgradeId != null)
                message.upgradeId = Boolean(object.upgradeId);
            if (object.buffId != null)
                message.buffId = Boolean(object.buffId);
            return message;
        };
        /**
         * Creates a plain object from a RequestData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestData
         * @static
         * @param {SC2APIProtocol.RequestData} message RequestData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = false;
                object.unitTypeId = false;
                object.upgradeId = false;
                object.buffId = false;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.unitTypeId != null && message.hasOwnProperty("unitTypeId"))
                object.unitTypeId = message.unitTypeId;
            if (message.upgradeId != null && message.hasOwnProperty("upgradeId"))
                object.upgradeId = message.upgradeId;
            if (message.buffId != null && message.hasOwnProperty("buffId"))
                object.buffId = message.buffId;
            return object;
        };
        /**
         * Converts this RequestData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestData;
    })();
    SC2APIProtocol.ResponseData = (function () {
        /**
         * Properties of a ResponseData.
         * @memberof SC2APIProtocol
         * @interface IResponseData
         * @property {Array.<SC2APIProtocol.IAbilityData>} [abilities] ResponseData abilities
         * @property {Array.<SC2APIProtocol.IUnitTypeData>} [units] ResponseData units
         * @property {Array.<SC2APIProtocol.IUpgradeData>} [upgrades] ResponseData upgrades
         * @property {Array.<SC2APIProtocol.IBuffData>} [buffs] ResponseData buffs
         */
        /**
         * Constructs a new ResponseData.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseData.
         * @constructor
         * @param {SC2APIProtocol.IResponseData=} [properties] Properties to set
         */
        function ResponseData(properties) {
            this.abilities = [];
            this.units = [];
            this.upgrades = [];
            this.buffs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseData abilities.
         * @member {Array.<SC2APIProtocol.IAbilityData>}abilities
         * @memberof SC2APIProtocol.ResponseData
         * @instance
         */
        ResponseData.prototype.abilities = $util.emptyArray;
        /**
         * ResponseData units.
         * @member {Array.<SC2APIProtocol.IUnitTypeData>}units
         * @memberof SC2APIProtocol.ResponseData
         * @instance
         */
        ResponseData.prototype.units = $util.emptyArray;
        /**
         * ResponseData upgrades.
         * @member {Array.<SC2APIProtocol.IUpgradeData>}upgrades
         * @memberof SC2APIProtocol.ResponseData
         * @instance
         */
        ResponseData.prototype.upgrades = $util.emptyArray;
        /**
         * ResponseData buffs.
         * @member {Array.<SC2APIProtocol.IBuffData>}buffs
         * @memberof SC2APIProtocol.ResponseData
         * @instance
         */
        ResponseData.prototype.buffs = $util.emptyArray;
        /**
         * Creates a new ResponseData instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {SC2APIProtocol.IResponseData=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseData} ResponseData instance
         */
        ResponseData.create = function create(properties) {
            return new ResponseData(properties);
        };
        /**
         * Encodes the specified ResponseData message. Does not implicitly {@link SC2APIProtocol.ResponseData.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {SC2APIProtocol.IResponseData} message ResponseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilities != null && message.abilities.length)
                for (var i = 0; i < message.abilities.length; ++i)
                    $root.SC2APIProtocol.AbilityData.encode(message.abilities[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    $root.SC2APIProtocol.UnitTypeData.encode(message.units[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.upgrades != null && message.upgrades.length)
                for (var i = 0; i < message.upgrades.length; ++i)
                    $root.SC2APIProtocol.UpgradeData.encode(message.upgrades[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.buffs != null && message.buffs.length)
                for (var i = 0; i < message.buffs.length; ++i)
                    $root.SC2APIProtocol.BuffData.encode(message.buffs[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ResponseData message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {SC2APIProtocol.IResponseData} message ResponseData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseData message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseData} ResponseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.SC2APIProtocol.AbilityData.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.units && message.units.length))
                            message.units = [];
                        message.units.push($root.SC2APIProtocol.UnitTypeData.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.upgrades && message.upgrades.length))
                            message.upgrades = [];
                        message.upgrades.push($root.SC2APIProtocol.UpgradeData.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.buffs && message.buffs.length))
                            message.buffs = [];
                        message.buffs.push($root.SC2APIProtocol.BuffData.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseData} ResponseData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseData message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilities != null && message.hasOwnProperty("abilities")) {
                if (!Array.isArray(message.abilities))
                    return "abilities: array expected";
                for (var i = 0; i < message.abilities.length; ++i) {
                    var error = $root.SC2APIProtocol.AbilityData.verify(message.abilities[i]);
                    if (error)
                        return "abilities." + error;
                }
            }
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i) {
                    error = $root.SC2APIProtocol.UnitTypeData.verify(message.units[i]);
                    if (error)
                        return "units." + error;
                }
            }
            if (message.upgrades != null && message.hasOwnProperty("upgrades")) {
                if (!Array.isArray(message.upgrades))
                    return "upgrades: array expected";
                for (var i = 0; i < message.upgrades.length; ++i) {
                    error = $root.SC2APIProtocol.UpgradeData.verify(message.upgrades[i]);
                    if (error)
                        return "upgrades." + error;
                }
            }
            if (message.buffs != null && message.hasOwnProperty("buffs")) {
                if (!Array.isArray(message.buffs))
                    return "buffs: array expected";
                for (var i = 0; i < message.buffs.length; ++i) {
                    error = $root.SC2APIProtocol.BuffData.verify(message.buffs[i]);
                    if (error)
                        return "buffs." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ResponseData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseData} ResponseData
         */
        ResponseData.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseData)
                return object;
            var message = new $root.SC2APIProtocol.ResponseData();
            if (object.abilities) {
                if (!Array.isArray(object.abilities))
                    throw TypeError(".SC2APIProtocol.ResponseData.abilities: array expected");
                message.abilities = [];
                for (var i = 0; i < object.abilities.length; ++i) {
                    if (typeof object.abilities[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseData.abilities: object expected");
                    message.abilities[i] = $root.SC2APIProtocol.AbilityData.fromObject(object.abilities[i]);
                }
            }
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".SC2APIProtocol.ResponseData.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i) {
                    if (typeof object.units[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseData.units: object expected");
                    message.units[i] = $root.SC2APIProtocol.UnitTypeData.fromObject(object.units[i]);
                }
            }
            if (object.upgrades) {
                if (!Array.isArray(object.upgrades))
                    throw TypeError(".SC2APIProtocol.ResponseData.upgrades: array expected");
                message.upgrades = [];
                for (var i = 0; i < object.upgrades.length; ++i) {
                    if (typeof object.upgrades[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseData.upgrades: object expected");
                    message.upgrades[i] = $root.SC2APIProtocol.UpgradeData.fromObject(object.upgrades[i]);
                }
            }
            if (object.buffs) {
                if (!Array.isArray(object.buffs))
                    throw TypeError(".SC2APIProtocol.ResponseData.buffs: array expected");
                message.buffs = [];
                for (var i = 0; i < object.buffs.length; ++i) {
                    if (typeof object.buffs[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseData.buffs: object expected");
                    message.buffs[i] = $root.SC2APIProtocol.BuffData.fromObject(object.buffs[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseData
         * @static
         * @param {SC2APIProtocol.ResponseData} message ResponseData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.abilities = [];
                object.units = [];
                object.upgrades = [];
                object.buffs = [];
            }
            if (message.abilities && message.abilities.length) {
                object.abilities = [];
                for (var j = 0; j < message.abilities.length; ++j)
                    object.abilities[j] = $root.SC2APIProtocol.AbilityData.toObject(message.abilities[j], options);
            }
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = $root.SC2APIProtocol.UnitTypeData.toObject(message.units[j], options);
            }
            if (message.upgrades && message.upgrades.length) {
                object.upgrades = [];
                for (var j = 0; j < message.upgrades.length; ++j)
                    object.upgrades[j] = $root.SC2APIProtocol.UpgradeData.toObject(message.upgrades[j], options);
            }
            if (message.buffs && message.buffs.length) {
                object.buffs = [];
                for (var j = 0; j < message.buffs.length; ++j)
                    object.buffs[j] = $root.SC2APIProtocol.BuffData.toObject(message.buffs[j], options);
            }
            return object;
        };
        /**
         * Converts this ResponseData to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseData;
    })();
    SC2APIProtocol.RequestSaveReplay = (function () {
        /**
         * Properties of a RequestSaveReplay.
         * @memberof SC2APIProtocol
         * @interface IRequestSaveReplay
         */
        /**
         * Constructs a new RequestSaveReplay.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestSaveReplay.
         * @constructor
         * @param {SC2APIProtocol.IRequestSaveReplay=} [properties] Properties to set
         */
        function RequestSaveReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestSaveReplay instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {SC2APIProtocol.IRequestSaveReplay=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestSaveReplay} RequestSaveReplay instance
         */
        RequestSaveReplay.create = function create(properties) {
            return new RequestSaveReplay(properties);
        };
        /**
         * Encodes the specified RequestSaveReplay message. Does not implicitly {@link SC2APIProtocol.RequestSaveReplay.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {SC2APIProtocol.IRequestSaveReplay} message RequestSaveReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSaveReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestSaveReplay message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestSaveReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {SC2APIProtocol.IRequestSaveReplay} message RequestSaveReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSaveReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestSaveReplay message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestSaveReplay} RequestSaveReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSaveReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestSaveReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestSaveReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestSaveReplay} RequestSaveReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSaveReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestSaveReplay message.
         * @function verify
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestSaveReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestSaveReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestSaveReplay} RequestSaveReplay
         */
        RequestSaveReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestSaveReplay)
                return object;
            return new $root.SC2APIProtocol.RequestSaveReplay();
        };
        /**
         * Creates a plain object from a RequestSaveReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @static
         * @param {SC2APIProtocol.RequestSaveReplay} message RequestSaveReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestSaveReplay.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestSaveReplay to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestSaveReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestSaveReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestSaveReplay;
    })();
    SC2APIProtocol.ResponseSaveReplay = (function () {
        /**
         * Properties of a ResponseSaveReplay.
         * @memberof SC2APIProtocol
         * @interface IResponseSaveReplay
         * @property {Uint8Array} [data] ResponseSaveReplay data
         */
        /**
         * Constructs a new ResponseSaveReplay.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseSaveReplay.
         * @constructor
         * @param {SC2APIProtocol.IResponseSaveReplay=} [properties] Properties to set
         */
        function ResponseSaveReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseSaveReplay data.
         * @member {Uint8Array}data
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @instance
         */
        ResponseSaveReplay.prototype.data = $util.newBuffer([]);
        /**
         * Creates a new ResponseSaveReplay instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {SC2APIProtocol.IResponseSaveReplay=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseSaveReplay} ResponseSaveReplay instance
         */
        ResponseSaveReplay.create = function create(properties) {
            return new ResponseSaveReplay(properties);
        };
        /**
         * Encodes the specified ResponseSaveReplay message. Does not implicitly {@link SC2APIProtocol.ResponseSaveReplay.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {SC2APIProtocol.IResponseSaveReplay} message ResponseSaveReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSaveReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.data);
            return writer;
        };
        /**
         * Encodes the specified ResponseSaveReplay message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseSaveReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {SC2APIProtocol.IResponseSaveReplay} message ResponseSaveReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSaveReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseSaveReplay message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseSaveReplay} ResponseSaveReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSaveReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseSaveReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseSaveReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseSaveReplay} ResponseSaveReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSaveReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseSaveReplay message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseSaveReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
        /**
         * Creates a ResponseSaveReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseSaveReplay} ResponseSaveReplay
         */
        ResponseSaveReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseSaveReplay)
                return object;
            var message = new $root.SC2APIProtocol.ResponseSaveReplay();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
        /**
         * Creates a plain object from a ResponseSaveReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @static
         * @param {SC2APIProtocol.ResponseSaveReplay} message ResponseSaveReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseSaveReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.data = options.bytes === String ? "" : [];
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
        /**
         * Converts this ResponseSaveReplay to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseSaveReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseSaveReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseSaveReplay;
    })();
    SC2APIProtocol.RequestReplayInfo = (function () {
        /**
         * Properties of a RequestReplayInfo.
         * @memberof SC2APIProtocol
         * @interface IRequestReplayInfo
         * @property {string} [replayPath] RequestReplayInfo replayPath
         * @property {Uint8Array} [replayData] RequestReplayInfo replayData
         * @property {boolean} [downloadData] RequestReplayInfo downloadData
         */
        /**
         * Constructs a new RequestReplayInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestReplayInfo.
         * @constructor
         * @param {SC2APIProtocol.IRequestReplayInfo=} [properties] Properties to set
         */
        function RequestReplayInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestReplayInfo replayPath.
         * @member {string}replayPath
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @instance
         */
        RequestReplayInfo.prototype.replayPath = "";
        /**
         * RequestReplayInfo replayData.
         * @member {Uint8Array}replayData
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @instance
         */
        RequestReplayInfo.prototype.replayData = $util.newBuffer([]);
        /**
         * RequestReplayInfo downloadData.
         * @member {boolean}downloadData
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @instance
         */
        RequestReplayInfo.prototype.downloadData = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * RequestReplayInfo replay.
         * @member {string|undefined} replay
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @instance
         */
        Object.defineProperty(RequestReplayInfo.prototype, "replay", {
            get: $util.oneOfGetter($oneOfFields = ["replayPath", "replayData"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new RequestReplayInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {SC2APIProtocol.IRequestReplayInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestReplayInfo} RequestReplayInfo instance
         */
        RequestReplayInfo.create = function create(properties) {
            return new RequestReplayInfo(properties);
        };
        /**
         * Encodes the specified RequestReplayInfo message. Does not implicitly {@link SC2APIProtocol.RequestReplayInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {SC2APIProtocol.IRequestReplayInfo} message RequestReplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestReplayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.replayPath != null && message.hasOwnProperty("replayPath"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.replayPath);
            if (message.replayData != null && message.hasOwnProperty("replayData"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.replayData);
            if (message.downloadData != null && message.hasOwnProperty("downloadData"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.downloadData);
            return writer;
        };
        /**
         * Encodes the specified RequestReplayInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestReplayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {SC2APIProtocol.IRequestReplayInfo} message RequestReplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestReplayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestReplayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestReplayInfo} RequestReplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestReplayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestReplayInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.replayPath = reader.string();
                        break;
                    case 2:
                        message.replayData = reader.bytes();
                        break;
                    case 3:
                        message.downloadData = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestReplayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestReplayInfo} RequestReplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestReplayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestReplayInfo message.
         * @function verify
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestReplayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.replayPath != null && message.hasOwnProperty("replayPath")) {
                properties.replay = 1;
                if (!$util.isString(message.replayPath))
                    return "replayPath: string expected";
            }
            if (message.replayData != null && message.hasOwnProperty("replayData")) {
                if (properties.replay === 1)
                    return "replay: multiple values";
                properties.replay = 1;
                if (!(message.replayData && typeof message.replayData.length === "number" || $util.isString(message.replayData)))
                    return "replayData: buffer expected";
            }
            if (message.downloadData != null && message.hasOwnProperty("downloadData"))
                if (typeof message.downloadData !== "boolean")
                    return "downloadData: boolean expected";
            return null;
        };
        /**
         * Creates a RequestReplayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestReplayInfo} RequestReplayInfo
         */
        RequestReplayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestReplayInfo)
                return object;
            var message = new $root.SC2APIProtocol.RequestReplayInfo();
            if (object.replayPath != null)
                message.replayPath = String(object.replayPath);
            if (object.replayData != null)
                if (typeof object.replayData === "string")
                    $util.base64.decode(object.replayData, message.replayData = $util.newBuffer($util.base64.length(object.replayData)), 0);
                else if (object.replayData.length)
                    message.replayData = object.replayData;
            if (object.downloadData != null)
                message.downloadData = Boolean(object.downloadData);
            return message;
        };
        /**
         * Creates a plain object from a RequestReplayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @static
         * @param {SC2APIProtocol.RequestReplayInfo} message RequestReplayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestReplayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.downloadData = false;
            if (message.replayPath != null && message.hasOwnProperty("replayPath")) {
                object.replayPath = message.replayPath;
                if (options.oneofs)
                    object.replay = "replayPath";
            }
            if (message.replayData != null && message.hasOwnProperty("replayData")) {
                object.replayData = options.bytes === String ? $util.base64.encode(message.replayData, 0, message.replayData.length) : options.bytes === Array ? Array.prototype.slice.call(message.replayData) : message.replayData;
                if (options.oneofs)
                    object.replay = "replayData";
            }
            if (message.downloadData != null && message.hasOwnProperty("downloadData"))
                object.downloadData = message.downloadData;
            return object;
        };
        /**
         * Converts this RequestReplayInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestReplayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestReplayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestReplayInfo;
    })();
    SC2APIProtocol.PlayerInfoExtra = (function () {
        /**
         * Properties of a PlayerInfoExtra.
         * @memberof SC2APIProtocol
         * @interface IPlayerInfoExtra
         * @property {SC2APIProtocol.IPlayerInfo} [playerInfo] PlayerInfoExtra playerInfo
         * @property {SC2APIProtocol.IPlayerResult} [playerResult] PlayerInfoExtra playerResult
         * @property {number} [playerMmr] PlayerInfoExtra playerMmr
         * @property {number} [playerApm] PlayerInfoExtra playerApm
         */
        /**
         * Constructs a new PlayerInfoExtra.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerInfoExtra.
         * @constructor
         * @param {SC2APIProtocol.IPlayerInfoExtra=} [properties] Properties to set
         */
        function PlayerInfoExtra(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerInfoExtra playerInfo.
         * @member {(SC2APIProtocol.IPlayerInfo|null|undefined)}playerInfo
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @instance
         */
        PlayerInfoExtra.prototype.playerInfo = null;
        /**
         * PlayerInfoExtra playerResult.
         * @member {(SC2APIProtocol.IPlayerResult|null|undefined)}playerResult
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @instance
         */
        PlayerInfoExtra.prototype.playerResult = null;
        /**
         * PlayerInfoExtra playerMmr.
         * @member {number}playerMmr
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @instance
         */
        PlayerInfoExtra.prototype.playerMmr = 0;
        /**
         * PlayerInfoExtra playerApm.
         * @member {number}playerApm
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @instance
         */
        PlayerInfoExtra.prototype.playerApm = 0;
        /**
         * Creates a new PlayerInfoExtra instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {SC2APIProtocol.IPlayerInfoExtra=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerInfoExtra} PlayerInfoExtra instance
         */
        PlayerInfoExtra.create = function create(properties) {
            return new PlayerInfoExtra(properties);
        };
        /**
         * Encodes the specified PlayerInfoExtra message. Does not implicitly {@link SC2APIProtocol.PlayerInfoExtra.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {SC2APIProtocol.IPlayerInfoExtra} message PlayerInfoExtra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfoExtra.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerInfo != null && message.hasOwnProperty("playerInfo"))
                $root.SC2APIProtocol.PlayerInfo.encode(message.playerInfo, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.playerResult != null && message.hasOwnProperty("playerResult"))
                $root.SC2APIProtocol.PlayerResult.encode(message.playerResult, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.playerMmr != null && message.hasOwnProperty("playerMmr"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.playerMmr);
            if (message.playerApm != null && message.hasOwnProperty("playerApm"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.playerApm);
            return writer;
        };
        /**
         * Encodes the specified PlayerInfoExtra message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerInfoExtra.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {SC2APIProtocol.IPlayerInfoExtra} message PlayerInfoExtra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfoExtra.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerInfoExtra message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerInfoExtra} PlayerInfoExtra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfoExtra.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerInfoExtra();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerInfo = $root.SC2APIProtocol.PlayerInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.playerResult = $root.SC2APIProtocol.PlayerResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.playerMmr = reader.int32();
                        break;
                    case 4:
                        message.playerApm = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerInfoExtra message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerInfoExtra} PlayerInfoExtra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfoExtra.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerInfoExtra message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerInfoExtra.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerInfo != null && message.hasOwnProperty("playerInfo")) {
                var error = $root.SC2APIProtocol.PlayerInfo.verify(message.playerInfo);
                if (error)
                    return "playerInfo." + error;
            }
            if (message.playerResult != null && message.hasOwnProperty("playerResult")) {
                error = $root.SC2APIProtocol.PlayerResult.verify(message.playerResult);
                if (error)
                    return "playerResult." + error;
            }
            if (message.playerMmr != null && message.hasOwnProperty("playerMmr"))
                if (!$util.isInteger(message.playerMmr))
                    return "playerMmr: integer expected";
            if (message.playerApm != null && message.hasOwnProperty("playerApm"))
                if (!$util.isInteger(message.playerApm))
                    return "playerApm: integer expected";
            return null;
        };
        /**
         * Creates a PlayerInfoExtra message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerInfoExtra} PlayerInfoExtra
         */
        PlayerInfoExtra.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerInfoExtra)
                return object;
            var message = new $root.SC2APIProtocol.PlayerInfoExtra();
            if (object.playerInfo != null) {
                if (typeof object.playerInfo !== "object")
                    throw TypeError(".SC2APIProtocol.PlayerInfoExtra.playerInfo: object expected");
                message.playerInfo = $root.SC2APIProtocol.PlayerInfo.fromObject(object.playerInfo);
            }
            if (object.playerResult != null) {
                if (typeof object.playerResult !== "object")
                    throw TypeError(".SC2APIProtocol.PlayerInfoExtra.playerResult: object expected");
                message.playerResult = $root.SC2APIProtocol.PlayerResult.fromObject(object.playerResult);
            }
            if (object.playerMmr != null)
                message.playerMmr = object.playerMmr | 0;
            if (object.playerApm != null)
                message.playerApm = object.playerApm | 0;
            return message;
        };
        /**
         * Creates a plain object from a PlayerInfoExtra message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @static
         * @param {SC2APIProtocol.PlayerInfoExtra} message PlayerInfoExtra
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerInfoExtra.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerInfo = null;
                object.playerResult = null;
                object.playerMmr = 0;
                object.playerApm = 0;
            }
            if (message.playerInfo != null && message.hasOwnProperty("playerInfo"))
                object.playerInfo = $root.SC2APIProtocol.PlayerInfo.toObject(message.playerInfo, options);
            if (message.playerResult != null && message.hasOwnProperty("playerResult"))
                object.playerResult = $root.SC2APIProtocol.PlayerResult.toObject(message.playerResult, options);
            if (message.playerMmr != null && message.hasOwnProperty("playerMmr"))
                object.playerMmr = message.playerMmr;
            if (message.playerApm != null && message.hasOwnProperty("playerApm"))
                object.playerApm = message.playerApm;
            return object;
        };
        /**
         * Converts this PlayerInfoExtra to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerInfoExtra
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerInfoExtra.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerInfoExtra;
    })();
    SC2APIProtocol.ResponseReplayInfo = (function () {
        /**
         * Properties of a ResponseReplayInfo.
         * @memberof SC2APIProtocol
         * @interface IResponseReplayInfo
         * @property {string} [mapName] ResponseReplayInfo mapName
         * @property {string} [localMapPath] ResponseReplayInfo localMapPath
         * @property {Array.<SC2APIProtocol.IPlayerInfoExtra>} [playerInfo] ResponseReplayInfo playerInfo
         * @property {number} [gameDurationLoops] ResponseReplayInfo gameDurationLoops
         * @property {number} [gameDurationSeconds] ResponseReplayInfo gameDurationSeconds
         * @property {string} [gameVersion] ResponseReplayInfo gameVersion
         * @property {string} [dataVersion] ResponseReplayInfo dataVersion
         * @property {number} [dataBuild] ResponseReplayInfo dataBuild
         * @property {number} [baseBuild] ResponseReplayInfo baseBuild
         * @property {SC2APIProtocol.ResponseReplayInfo.Error} [error] ResponseReplayInfo error
         * @property {string} [errorDetails] ResponseReplayInfo errorDetails
         */
        /**
         * Constructs a new ResponseReplayInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseReplayInfo.
         * @constructor
         * @param {SC2APIProtocol.IResponseReplayInfo=} [properties] Properties to set
         */
        function ResponseReplayInfo(properties) {
            this.playerInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseReplayInfo mapName.
         * @member {string}mapName
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.mapName = "";
        /**
         * ResponseReplayInfo localMapPath.
         * @member {string}localMapPath
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.localMapPath = "";
        /**
         * ResponseReplayInfo playerInfo.
         * @member {Array.<SC2APIProtocol.IPlayerInfoExtra>}playerInfo
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.playerInfo = $util.emptyArray;
        /**
         * ResponseReplayInfo gameDurationLoops.
         * @member {number}gameDurationLoops
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.gameDurationLoops = 0;
        /**
         * ResponseReplayInfo gameDurationSeconds.
         * @member {number}gameDurationSeconds
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.gameDurationSeconds = 0;
        /**
         * ResponseReplayInfo gameVersion.
         * @member {string}gameVersion
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.gameVersion = "";
        /**
         * ResponseReplayInfo dataVersion.
         * @member {string}dataVersion
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.dataVersion = "";
        /**
         * ResponseReplayInfo dataBuild.
         * @member {number}dataBuild
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.dataBuild = 0;
        /**
         * ResponseReplayInfo baseBuild.
         * @member {number}baseBuild
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.baseBuild = 0;
        /**
         * ResponseReplayInfo error.
         * @member {SC2APIProtocol.ResponseReplayInfo.Error}error
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.error = 1;
        /**
         * ResponseReplayInfo errorDetails.
         * @member {string}errorDetails
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         */
        ResponseReplayInfo.prototype.errorDetails = "";
        /**
         * Creates a new ResponseReplayInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {SC2APIProtocol.IResponseReplayInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseReplayInfo} ResponseReplayInfo instance
         */
        ResponseReplayInfo.create = function create(properties) {
            return new ResponseReplayInfo(properties);
        };
        /**
         * Encodes the specified ResponseReplayInfo message. Does not implicitly {@link SC2APIProtocol.ResponseReplayInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {SC2APIProtocol.IResponseReplayInfo} message ResponseReplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseReplayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mapName);
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.localMapPath);
            if (message.playerInfo != null && message.playerInfo.length)
                for (var i = 0; i < message.playerInfo.length; ++i)
                    $root.SC2APIProtocol.PlayerInfoExtra.encode(message.playerInfo[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.gameDurationLoops != null && message.hasOwnProperty("gameDurationLoops"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.gameDurationLoops);
            if (message.gameDurationSeconds != null && message.hasOwnProperty("gameDurationSeconds"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.gameDurationSeconds);
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.gameVersion);
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).uint32(message.dataBuild);
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.baseBuild);
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.error);
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.errorDetails);
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.dataVersion);
            return writer;
        };
        /**
         * Encodes the specified ResponseReplayInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseReplayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {SC2APIProtocol.IResponseReplayInfo} message ResponseReplayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseReplayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseReplayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseReplayInfo} ResponseReplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseReplayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseReplayInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapName = reader.string();
                        break;
                    case 2:
                        message.localMapPath = reader.string();
                        break;
                    case 3:
                        if (!(message.playerInfo && message.playerInfo.length))
                            message.playerInfo = [];
                        message.playerInfo.push($root.SC2APIProtocol.PlayerInfoExtra.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.gameDurationLoops = reader.uint32();
                        break;
                    case 5:
                        message.gameDurationSeconds = reader.float();
                        break;
                    case 6:
                        message.gameVersion = reader.string();
                        break;
                    case 11:
                        message.dataVersion = reader.string();
                        break;
                    case 7:
                        message.dataBuild = reader.uint32();
                        break;
                    case 8:
                        message.baseBuild = reader.uint32();
                        break;
                    case 9:
                        message.error = reader.int32();
                        break;
                    case 10:
                        message.errorDetails = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseReplayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseReplayInfo} ResponseReplayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseReplayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseReplayInfo message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseReplayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                if (!$util.isString(message.mapName))
                    return "mapName: string expected";
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                if (!$util.isString(message.localMapPath))
                    return "localMapPath: string expected";
            if (message.playerInfo != null && message.hasOwnProperty("playerInfo")) {
                if (!Array.isArray(message.playerInfo))
                    return "playerInfo: array expected";
                for (var i = 0; i < message.playerInfo.length; ++i) {
                    var error = $root.SC2APIProtocol.PlayerInfoExtra.verify(message.playerInfo[i]);
                    if (error)
                        return "playerInfo." + error;
                }
            }
            if (message.gameDurationLoops != null && message.hasOwnProperty("gameDurationLoops"))
                if (!$util.isInteger(message.gameDurationLoops))
                    return "gameDurationLoops: integer expected";
            if (message.gameDurationSeconds != null && message.hasOwnProperty("gameDurationSeconds"))
                if (typeof message.gameDurationSeconds !== "number")
                    return "gameDurationSeconds: number expected";
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                if (!$util.isString(message.gameVersion))
                    return "gameVersion: string expected";
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                if (!$util.isString(message.dataVersion))
                    return "dataVersion: string expected";
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                if (!$util.isInteger(message.dataBuild))
                    return "dataBuild: integer expected";
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                if (!$util.isInteger(message.baseBuild))
                    return "baseBuild: integer expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                }
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                if (!$util.isString(message.errorDetails))
                    return "errorDetails: string expected";
            return null;
        };
        /**
         * Creates a ResponseReplayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseReplayInfo} ResponseReplayInfo
         */
        ResponseReplayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseReplayInfo)
                return object;
            var message = new $root.SC2APIProtocol.ResponseReplayInfo();
            if (object.mapName != null)
                message.mapName = String(object.mapName);
            if (object.localMapPath != null)
                message.localMapPath = String(object.localMapPath);
            if (object.playerInfo) {
                if (!Array.isArray(object.playerInfo))
                    throw TypeError(".SC2APIProtocol.ResponseReplayInfo.playerInfo: array expected");
                message.playerInfo = [];
                for (var i = 0; i < object.playerInfo.length; ++i) {
                    if (typeof object.playerInfo[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ResponseReplayInfo.playerInfo: object expected");
                    message.playerInfo[i] = $root.SC2APIProtocol.PlayerInfoExtra.fromObject(object.playerInfo[i]);
                }
            }
            if (object.gameDurationLoops != null)
                message.gameDurationLoops = object.gameDurationLoops >>> 0;
            if (object.gameDurationSeconds != null)
                message.gameDurationSeconds = Number(object.gameDurationSeconds);
            if (object.gameVersion != null)
                message.gameVersion = String(object.gameVersion);
            if (object.dataVersion != null)
                message.dataVersion = String(object.dataVersion);
            if (object.dataBuild != null)
                message.dataBuild = object.dataBuild >>> 0;
            if (object.baseBuild != null)
                message.baseBuild = object.baseBuild >>> 0;
            switch (object.error) {
                case "MissingReplay":
                case 1:
                    message.error = 1;
                    break;
                case "InvalidReplayPath":
                case 2:
                    message.error = 2;
                    break;
                case "InvalidReplayData":
                case 3:
                    message.error = 3;
                    break;
                case "ParsingError":
                case 4:
                    message.error = 4;
                    break;
                case "DownloadError":
                case 5:
                    message.error = 5;
                    break;
            }
            if (object.errorDetails != null)
                message.errorDetails = String(object.errorDetails);
            return message;
        };
        /**
         * Creates a plain object from a ResponseReplayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @static
         * @param {SC2APIProtocol.ResponseReplayInfo} message ResponseReplayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseReplayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.playerInfo = [];
            if (options.defaults) {
                object.mapName = "";
                object.localMapPath = "";
                object.gameDurationLoops = 0;
                object.gameDurationSeconds = 0;
                object.gameVersion = "";
                object.dataBuild = 0;
                object.baseBuild = 0;
                object.error = options.enums === String ? "MissingReplay" : 1;
                object.errorDetails = "";
                object.dataVersion = "";
            }
            if (message.mapName != null && message.hasOwnProperty("mapName"))
                object.mapName = message.mapName;
            if (message.localMapPath != null && message.hasOwnProperty("localMapPath"))
                object.localMapPath = message.localMapPath;
            if (message.playerInfo && message.playerInfo.length) {
                object.playerInfo = [];
                for (var j = 0; j < message.playerInfo.length; ++j)
                    object.playerInfo[j] = $root.SC2APIProtocol.PlayerInfoExtra.toObject(message.playerInfo[j], options);
            }
            if (message.gameDurationLoops != null && message.hasOwnProperty("gameDurationLoops"))
                object.gameDurationLoops = message.gameDurationLoops;
            if (message.gameDurationSeconds != null && message.hasOwnProperty("gameDurationSeconds"))
                object.gameDurationSeconds = options.json && !isFinite(message.gameDurationSeconds) ? String(message.gameDurationSeconds) : message.gameDurationSeconds;
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                object.gameVersion = message.gameVersion;
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                object.dataBuild = message.dataBuild;
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                object.baseBuild = message.baseBuild;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseReplayInfo.Error[message.error] : message.error;
            if (message.errorDetails != null && message.hasOwnProperty("errorDetails"))
                object.errorDetails = message.errorDetails;
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                object.dataVersion = message.dataVersion;
            return object;
        };
        /**
         * Converts this ResponseReplayInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseReplayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseReplayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} MissingReplay=1 MissingReplay value
         * @property {number} InvalidReplayPath=2 InvalidReplayPath value
         * @property {number} InvalidReplayData=3 InvalidReplayData value
         * @property {number} ParsingError=4 ParsingError value
         * @property {number} DownloadError=5 DownloadError value
         */
        ResponseReplayInfo.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MissingReplay"] = 1;
            values[valuesById[2] = "InvalidReplayPath"] = 2;
            values[valuesById[3] = "InvalidReplayData"] = 3;
            values[valuesById[4] = "ParsingError"] = 4;
            values[valuesById[5] = "DownloadError"] = 5;
            return values;
        })();
        return ResponseReplayInfo;
    })();
    SC2APIProtocol.RequestAvailableMaps = (function () {
        /**
         * Properties of a RequestAvailableMaps.
         * @memberof SC2APIProtocol
         * @interface IRequestAvailableMaps
         */
        /**
         * Constructs a new RequestAvailableMaps.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestAvailableMaps.
         * @constructor
         * @param {SC2APIProtocol.IRequestAvailableMaps=} [properties] Properties to set
         */
        function RequestAvailableMaps(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestAvailableMaps instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {SC2APIProtocol.IRequestAvailableMaps=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestAvailableMaps} RequestAvailableMaps instance
         */
        RequestAvailableMaps.create = function create(properties) {
            return new RequestAvailableMaps(properties);
        };
        /**
         * Encodes the specified RequestAvailableMaps message. Does not implicitly {@link SC2APIProtocol.RequestAvailableMaps.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {SC2APIProtocol.IRequestAvailableMaps} message RequestAvailableMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestAvailableMaps.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestAvailableMaps message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestAvailableMaps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {SC2APIProtocol.IRequestAvailableMaps} message RequestAvailableMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestAvailableMaps.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestAvailableMaps message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestAvailableMaps} RequestAvailableMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestAvailableMaps.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestAvailableMaps();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestAvailableMaps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestAvailableMaps} RequestAvailableMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestAvailableMaps.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestAvailableMaps message.
         * @function verify
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestAvailableMaps.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestAvailableMaps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestAvailableMaps} RequestAvailableMaps
         */
        RequestAvailableMaps.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestAvailableMaps)
                return object;
            return new $root.SC2APIProtocol.RequestAvailableMaps();
        };
        /**
         * Creates a plain object from a RequestAvailableMaps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @static
         * @param {SC2APIProtocol.RequestAvailableMaps} message RequestAvailableMaps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestAvailableMaps.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestAvailableMaps to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestAvailableMaps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestAvailableMaps.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestAvailableMaps;
    })();
    SC2APIProtocol.ResponseAvailableMaps = (function () {
        /**
         * Properties of a ResponseAvailableMaps.
         * @memberof SC2APIProtocol
         * @interface IResponseAvailableMaps
         * @property {Array.<string>} [localMapPaths] ResponseAvailableMaps localMapPaths
         * @property {Array.<string>} [battlenetMapNames] ResponseAvailableMaps battlenetMapNames
         */
        /**
         * Constructs a new ResponseAvailableMaps.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseAvailableMaps.
         * @constructor
         * @param {SC2APIProtocol.IResponseAvailableMaps=} [properties] Properties to set
         */
        function ResponseAvailableMaps(properties) {
            this.localMapPaths = [];
            this.battlenetMapNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseAvailableMaps localMapPaths.
         * @member {Array.<string>}localMapPaths
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @instance
         */
        ResponseAvailableMaps.prototype.localMapPaths = $util.emptyArray;
        /**
         * ResponseAvailableMaps battlenetMapNames.
         * @member {Array.<string>}battlenetMapNames
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @instance
         */
        ResponseAvailableMaps.prototype.battlenetMapNames = $util.emptyArray;
        /**
         * Creates a new ResponseAvailableMaps instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {SC2APIProtocol.IResponseAvailableMaps=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseAvailableMaps} ResponseAvailableMaps instance
         */
        ResponseAvailableMaps.create = function create(properties) {
            return new ResponseAvailableMaps(properties);
        };
        /**
         * Encodes the specified ResponseAvailableMaps message. Does not implicitly {@link SC2APIProtocol.ResponseAvailableMaps.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {SC2APIProtocol.IResponseAvailableMaps} message ResponseAvailableMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseAvailableMaps.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.localMapPaths != null && message.localMapPaths.length)
                for (var i = 0; i < message.localMapPaths.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.localMapPaths[i]);
            if (message.battlenetMapNames != null && message.battlenetMapNames.length)
                for (var i = 0; i < message.battlenetMapNames.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.battlenetMapNames[i]);
            return writer;
        };
        /**
         * Encodes the specified ResponseAvailableMaps message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseAvailableMaps.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {SC2APIProtocol.IResponseAvailableMaps} message ResponseAvailableMaps message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseAvailableMaps.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseAvailableMaps message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseAvailableMaps} ResponseAvailableMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseAvailableMaps.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseAvailableMaps();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.localMapPaths && message.localMapPaths.length))
                            message.localMapPaths = [];
                        message.localMapPaths.push(reader.string());
                        break;
                    case 2:
                        if (!(message.battlenetMapNames && message.battlenetMapNames.length))
                            message.battlenetMapNames = [];
                        message.battlenetMapNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseAvailableMaps message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseAvailableMaps} ResponseAvailableMaps
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseAvailableMaps.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseAvailableMaps message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseAvailableMaps.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.localMapPaths != null && message.hasOwnProperty("localMapPaths")) {
                if (!Array.isArray(message.localMapPaths))
                    return "localMapPaths: array expected";
                for (var i = 0; i < message.localMapPaths.length; ++i)
                    if (!$util.isString(message.localMapPaths[i]))
                        return "localMapPaths: string[] expected";
            }
            if (message.battlenetMapNames != null && message.hasOwnProperty("battlenetMapNames")) {
                if (!Array.isArray(message.battlenetMapNames))
                    return "battlenetMapNames: array expected";
                for (var i = 0; i < message.battlenetMapNames.length; ++i)
                    if (!$util.isString(message.battlenetMapNames[i]))
                        return "battlenetMapNames: string[] expected";
            }
            return null;
        };
        /**
         * Creates a ResponseAvailableMaps message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseAvailableMaps} ResponseAvailableMaps
         */
        ResponseAvailableMaps.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseAvailableMaps)
                return object;
            var message = new $root.SC2APIProtocol.ResponseAvailableMaps();
            if (object.localMapPaths) {
                if (!Array.isArray(object.localMapPaths))
                    throw TypeError(".SC2APIProtocol.ResponseAvailableMaps.localMapPaths: array expected");
                message.localMapPaths = [];
                for (var i = 0; i < object.localMapPaths.length; ++i)
                    message.localMapPaths[i] = String(object.localMapPaths[i]);
            }
            if (object.battlenetMapNames) {
                if (!Array.isArray(object.battlenetMapNames))
                    throw TypeError(".SC2APIProtocol.ResponseAvailableMaps.battlenetMapNames: array expected");
                message.battlenetMapNames = [];
                for (var i = 0; i < object.battlenetMapNames.length; ++i)
                    message.battlenetMapNames[i] = String(object.battlenetMapNames[i]);
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseAvailableMaps message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @static
         * @param {SC2APIProtocol.ResponseAvailableMaps} message ResponseAvailableMaps
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseAvailableMaps.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.localMapPaths = [];
                object.battlenetMapNames = [];
            }
            if (message.localMapPaths && message.localMapPaths.length) {
                object.localMapPaths = [];
                for (var j = 0; j < message.localMapPaths.length; ++j)
                    object.localMapPaths[j] = message.localMapPaths[j];
            }
            if (message.battlenetMapNames && message.battlenetMapNames.length) {
                object.battlenetMapNames = [];
                for (var j = 0; j < message.battlenetMapNames.length; ++j)
                    object.battlenetMapNames[j] = message.battlenetMapNames[j];
            }
            return object;
        };
        /**
         * Converts this ResponseAvailableMaps to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseAvailableMaps
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseAvailableMaps.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseAvailableMaps;
    })();
    SC2APIProtocol.RequestSaveMap = (function () {
        /**
         * Properties of a RequestSaveMap.
         * @memberof SC2APIProtocol
         * @interface IRequestSaveMap
         * @property {string} [mapPath] RequestSaveMap mapPath
         * @property {Uint8Array} [mapData] RequestSaveMap mapData
         */
        /**
         * Constructs a new RequestSaveMap.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestSaveMap.
         * @constructor
         * @param {SC2APIProtocol.IRequestSaveMap=} [properties] Properties to set
         */
        function RequestSaveMap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestSaveMap mapPath.
         * @member {string}mapPath
         * @memberof SC2APIProtocol.RequestSaveMap
         * @instance
         */
        RequestSaveMap.prototype.mapPath = "";
        /**
         * RequestSaveMap mapData.
         * @member {Uint8Array}mapData
         * @memberof SC2APIProtocol.RequestSaveMap
         * @instance
         */
        RequestSaveMap.prototype.mapData = $util.newBuffer([]);
        /**
         * Creates a new RequestSaveMap instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {SC2APIProtocol.IRequestSaveMap=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestSaveMap} RequestSaveMap instance
         */
        RequestSaveMap.create = function create(properties) {
            return new RequestSaveMap(properties);
        };
        /**
         * Encodes the specified RequestSaveMap message. Does not implicitly {@link SC2APIProtocol.RequestSaveMap.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {SC2APIProtocol.IRequestSaveMap} message RequestSaveMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSaveMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mapPath);
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.mapData);
            return writer;
        };
        /**
         * Encodes the specified RequestSaveMap message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestSaveMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {SC2APIProtocol.IRequestSaveMap} message RequestSaveMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestSaveMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestSaveMap message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestSaveMap} RequestSaveMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSaveMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestSaveMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapPath = reader.string();
                        break;
                    case 2:
                        message.mapData = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestSaveMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestSaveMap} RequestSaveMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestSaveMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestSaveMap message.
         * @function verify
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestSaveMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                if (!$util.isString(message.mapPath))
                    return "mapPath: string expected";
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                if (!(message.mapData && typeof message.mapData.length === "number" || $util.isString(message.mapData)))
                    return "mapData: buffer expected";
            return null;
        };
        /**
         * Creates a RequestSaveMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestSaveMap} RequestSaveMap
         */
        RequestSaveMap.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestSaveMap)
                return object;
            var message = new $root.SC2APIProtocol.RequestSaveMap();
            if (object.mapPath != null)
                message.mapPath = String(object.mapPath);
            if (object.mapData != null)
                if (typeof object.mapData === "string")
                    $util.base64.decode(object.mapData, message.mapData = $util.newBuffer($util.base64.length(object.mapData)), 0);
                else if (object.mapData.length)
                    message.mapData = object.mapData;
            return message;
        };
        /**
         * Creates a plain object from a RequestSaveMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestSaveMap
         * @static
         * @param {SC2APIProtocol.RequestSaveMap} message RequestSaveMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestSaveMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mapPath = "";
                object.mapData = options.bytes === String ? "" : [];
            }
            if (message.mapPath != null && message.hasOwnProperty("mapPath"))
                object.mapPath = message.mapPath;
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                object.mapData = options.bytes === String ? $util.base64.encode(message.mapData, 0, message.mapData.length) : options.bytes === Array ? Array.prototype.slice.call(message.mapData) : message.mapData;
            return object;
        };
        /**
         * Converts this RequestSaveMap to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestSaveMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestSaveMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestSaveMap;
    })();
    SC2APIProtocol.ResponseSaveMap = (function () {
        /**
         * Properties of a ResponseSaveMap.
         * @memberof SC2APIProtocol
         * @interface IResponseSaveMap
         * @property {SC2APIProtocol.ResponseSaveMap.Error} [error] ResponseSaveMap error
         */
        /**
         * Constructs a new ResponseSaveMap.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseSaveMap.
         * @constructor
         * @param {SC2APIProtocol.IResponseSaveMap=} [properties] Properties to set
         */
        function ResponseSaveMap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseSaveMap error.
         * @member {SC2APIProtocol.ResponseSaveMap.Error}error
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @instance
         */
        ResponseSaveMap.prototype.error = 1;
        /**
         * Creates a new ResponseSaveMap instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {SC2APIProtocol.IResponseSaveMap=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseSaveMap} ResponseSaveMap instance
         */
        ResponseSaveMap.create = function create(properties) {
            return new ResponseSaveMap(properties);
        };
        /**
         * Encodes the specified ResponseSaveMap message. Does not implicitly {@link SC2APIProtocol.ResponseSaveMap.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {SC2APIProtocol.IResponseSaveMap} message ResponseSaveMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSaveMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && message.hasOwnProperty("error"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.error);
            return writer;
        };
        /**
         * Encodes the specified ResponseSaveMap message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseSaveMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {SC2APIProtocol.IResponseSaveMap} message ResponseSaveMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseSaveMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseSaveMap message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseSaveMap} ResponseSaveMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSaveMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseSaveMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.error = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseSaveMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseSaveMap} ResponseSaveMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseSaveMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseSaveMap message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseSaveMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error"))
                switch (message.error) {
                    default:
                        return "error: enum value expected";
                    case 1:
                        break;
                }
            return null;
        };
        /**
         * Creates a ResponseSaveMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseSaveMap} ResponseSaveMap
         */
        ResponseSaveMap.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseSaveMap)
                return object;
            var message = new $root.SC2APIProtocol.ResponseSaveMap();
            switch (object.error) {
                case "InvalidMapData":
                case 1:
                    message.error = 1;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a ResponseSaveMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @static
         * @param {SC2APIProtocol.ResponseSaveMap} message ResponseSaveMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseSaveMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.error = options.enums === String ? "InvalidMapData" : 1;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = options.enums === String ? $root.SC2APIProtocol.ResponseSaveMap.Error[message.error] : message.error;
            return object;
        };
        /**
         * Converts this ResponseSaveMap to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseSaveMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseSaveMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Error enum.
         * @enum {string}
         * @property {number} InvalidMapData=1 InvalidMapData value
         */
        ResponseSaveMap.Error = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "InvalidMapData"] = 1;
            return values;
        })();
        return ResponseSaveMap;
    })();
    SC2APIProtocol.RequestPing = (function () {
        /**
         * Properties of a RequestPing.
         * @memberof SC2APIProtocol
         * @interface IRequestPing
         */
        /**
         * Constructs a new RequestPing.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestPing.
         * @constructor
         * @param {SC2APIProtocol.IRequestPing=} [properties] Properties to set
         */
        function RequestPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new RequestPing instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {SC2APIProtocol.IRequestPing=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestPing} RequestPing instance
         */
        RequestPing.create = function create(properties) {
            return new RequestPing(properties);
        };
        /**
         * Encodes the specified RequestPing message. Does not implicitly {@link SC2APIProtocol.RequestPing.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {SC2APIProtocol.IRequestPing} message RequestPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified RequestPing message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {SC2APIProtocol.IRequestPing} message RequestPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestPing message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestPing} RequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestPing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestPing} RequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestPing message.
         * @function verify
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a RequestPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestPing} RequestPing
         */
        RequestPing.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestPing)
                return object;
            return new $root.SC2APIProtocol.RequestPing();
        };
        /**
         * Creates a plain object from a RequestPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestPing
         * @static
         * @param {SC2APIProtocol.RequestPing} message RequestPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestPing.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this RequestPing to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestPing;
    })();
    SC2APIProtocol.ResponsePing = (function () {
        /**
         * Properties of a ResponsePing.
         * @memberof SC2APIProtocol
         * @interface IResponsePing
         * @property {string} [gameVersion] ResponsePing gameVersion
         * @property {string} [dataVersion] ResponsePing dataVersion
         * @property {number} [dataBuild] ResponsePing dataBuild
         * @property {number} [baseBuild] ResponsePing baseBuild
         */
        /**
         * Constructs a new ResponsePing.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponsePing.
         * @constructor
         * @param {SC2APIProtocol.IResponsePing=} [properties] Properties to set
         */
        function ResponsePing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponsePing gameVersion.
         * @member {string}gameVersion
         * @memberof SC2APIProtocol.ResponsePing
         * @instance
         */
        ResponsePing.prototype.gameVersion = "";
        /**
         * ResponsePing dataVersion.
         * @member {string}dataVersion
         * @memberof SC2APIProtocol.ResponsePing
         * @instance
         */
        ResponsePing.prototype.dataVersion = "";
        /**
         * ResponsePing dataBuild.
         * @member {number}dataBuild
         * @memberof SC2APIProtocol.ResponsePing
         * @instance
         */
        ResponsePing.prototype.dataBuild = 0;
        /**
         * ResponsePing baseBuild.
         * @member {number}baseBuild
         * @memberof SC2APIProtocol.ResponsePing
         * @instance
         */
        ResponsePing.prototype.baseBuild = 0;
        /**
         * Creates a new ResponsePing instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {SC2APIProtocol.IResponsePing=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponsePing} ResponsePing instance
         */
        ResponsePing.create = function create(properties) {
            return new ResponsePing(properties);
        };
        /**
         * Encodes the specified ResponsePing message. Does not implicitly {@link SC2APIProtocol.ResponsePing.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {SC2APIProtocol.IResponsePing} message ResponsePing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponsePing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.gameVersion);
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.dataVersion);
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.dataBuild);
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.baseBuild);
            return writer;
        };
        /**
         * Encodes the specified ResponsePing message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponsePing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {SC2APIProtocol.IResponsePing} message ResponsePing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponsePing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponsePing message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponsePing} ResponsePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponsePing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponsePing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.gameVersion = reader.string();
                        break;
                    case 2:
                        message.dataVersion = reader.string();
                        break;
                    case 3:
                        message.dataBuild = reader.uint32();
                        break;
                    case 4:
                        message.baseBuild = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponsePing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponsePing} ResponsePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponsePing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponsePing message.
         * @function verify
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponsePing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                if (!$util.isString(message.gameVersion))
                    return "gameVersion: string expected";
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                if (!$util.isString(message.dataVersion))
                    return "dataVersion: string expected";
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                if (!$util.isInteger(message.dataBuild))
                    return "dataBuild: integer expected";
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                if (!$util.isInteger(message.baseBuild))
                    return "baseBuild: integer expected";
            return null;
        };
        /**
         * Creates a ResponsePing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponsePing} ResponsePing
         */
        ResponsePing.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponsePing)
                return object;
            var message = new $root.SC2APIProtocol.ResponsePing();
            if (object.gameVersion != null)
                message.gameVersion = String(object.gameVersion);
            if (object.dataVersion != null)
                message.dataVersion = String(object.dataVersion);
            if (object.dataBuild != null)
                message.dataBuild = object.dataBuild >>> 0;
            if (object.baseBuild != null)
                message.baseBuild = object.baseBuild >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a ResponsePing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponsePing
         * @static
         * @param {SC2APIProtocol.ResponsePing} message ResponsePing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponsePing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gameVersion = "";
                object.dataVersion = "";
                object.dataBuild = 0;
                object.baseBuild = 0;
            }
            if (message.gameVersion != null && message.hasOwnProperty("gameVersion"))
                object.gameVersion = message.gameVersion;
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                object.dataVersion = message.dataVersion;
            if (message.dataBuild != null && message.hasOwnProperty("dataBuild"))
                object.dataBuild = message.dataBuild;
            if (message.baseBuild != null && message.hasOwnProperty("baseBuild"))
                object.baseBuild = message.baseBuild;
            return object;
        };
        /**
         * Converts this ResponsePing to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponsePing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponsePing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponsePing;
    })();
    SC2APIProtocol.RequestDebug = (function () {
        /**
         * Properties of a RequestDebug.
         * @memberof SC2APIProtocol
         * @interface IRequestDebug
         * @property {Array.<SC2APIProtocol.IDebugCommand>} [debug] RequestDebug debug
         */
        /**
         * Constructs a new RequestDebug.
         * @memberof SC2APIProtocol
         * @classdesc Represents a RequestDebug.
         * @constructor
         * @param {SC2APIProtocol.IRequestDebug=} [properties] Properties to set
         */
        function RequestDebug(properties) {
            this.debug = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestDebug debug.
         * @member {Array.<SC2APIProtocol.IDebugCommand>}debug
         * @memberof SC2APIProtocol.RequestDebug
         * @instance
         */
        RequestDebug.prototype.debug = $util.emptyArray;
        /**
         * Creates a new RequestDebug instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {SC2APIProtocol.IRequestDebug=} [properties] Properties to set
         * @returns {SC2APIProtocol.RequestDebug} RequestDebug instance
         */
        RequestDebug.create = function create(properties) {
            return new RequestDebug(properties);
        };
        /**
         * Encodes the specified RequestDebug message. Does not implicitly {@link SC2APIProtocol.RequestDebug.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {SC2APIProtocol.IRequestDebug} message RequestDebug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestDebug.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.debug != null && message.debug.length)
                for (var i = 0; i < message.debug.length; ++i)
                    $root.SC2APIProtocol.DebugCommand.encode(message.debug[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified RequestDebug message, length delimited. Does not implicitly {@link SC2APIProtocol.RequestDebug.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {SC2APIProtocol.IRequestDebug} message RequestDebug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestDebug.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a RequestDebug message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.RequestDebug} RequestDebug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestDebug.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.RequestDebug();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.debug && message.debug.length))
                            message.debug = [];
                        message.debug.push($root.SC2APIProtocol.DebugCommand.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a RequestDebug message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.RequestDebug} RequestDebug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestDebug.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a RequestDebug message.
         * @function verify
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestDebug.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.debug != null && message.hasOwnProperty("debug")) {
                if (!Array.isArray(message.debug))
                    return "debug: array expected";
                for (var i = 0; i < message.debug.length; ++i) {
                    var error = $root.SC2APIProtocol.DebugCommand.verify(message.debug[i]);
                    if (error)
                        return "debug." + error;
                }
            }
            return null;
        };
        /**
         * Creates a RequestDebug message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.RequestDebug} RequestDebug
         */
        RequestDebug.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.RequestDebug)
                return object;
            var message = new $root.SC2APIProtocol.RequestDebug();
            if (object.debug) {
                if (!Array.isArray(object.debug))
                    throw TypeError(".SC2APIProtocol.RequestDebug.debug: array expected");
                message.debug = [];
                for (var i = 0; i < object.debug.length; ++i) {
                    if (typeof object.debug[i] !== "object")
                        throw TypeError(".SC2APIProtocol.RequestDebug.debug: object expected");
                    message.debug[i] = $root.SC2APIProtocol.DebugCommand.fromObject(object.debug[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a RequestDebug message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.RequestDebug
         * @static
         * @param {SC2APIProtocol.RequestDebug} message RequestDebug
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestDebug.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.debug = [];
            if (message.debug && message.debug.length) {
                object.debug = [];
                for (var j = 0; j < message.debug.length; ++j)
                    object.debug[j] = $root.SC2APIProtocol.DebugCommand.toObject(message.debug[j], options);
            }
            return object;
        };
        /**
         * Converts this RequestDebug to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.RequestDebug
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestDebug.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return RequestDebug;
    })();
    SC2APIProtocol.ResponseDebug = (function () {
        /**
         * Properties of a ResponseDebug.
         * @memberof SC2APIProtocol
         * @interface IResponseDebug
         */
        /**
         * Constructs a new ResponseDebug.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ResponseDebug.
         * @constructor
         * @param {SC2APIProtocol.IResponseDebug=} [properties] Properties to set
         */
        function ResponseDebug(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ResponseDebug instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {SC2APIProtocol.IResponseDebug=} [properties] Properties to set
         * @returns {SC2APIProtocol.ResponseDebug} ResponseDebug instance
         */
        ResponseDebug.create = function create(properties) {
            return new ResponseDebug(properties);
        };
        /**
         * Encodes the specified ResponseDebug message. Does not implicitly {@link SC2APIProtocol.ResponseDebug.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {SC2APIProtocol.IResponseDebug} message ResponseDebug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseDebug.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ResponseDebug message, length delimited. Does not implicitly {@link SC2APIProtocol.ResponseDebug.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {SC2APIProtocol.IResponseDebug} message ResponseDebug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseDebug.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ResponseDebug message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ResponseDebug} ResponseDebug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseDebug.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ResponseDebug();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ResponseDebug message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ResponseDebug} ResponseDebug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseDebug.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ResponseDebug message.
         * @function verify
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResponseDebug.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates a ResponseDebug message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ResponseDebug} ResponseDebug
         */
        ResponseDebug.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ResponseDebug)
                return object;
            return new $root.SC2APIProtocol.ResponseDebug();
        };
        /**
         * Creates a plain object from a ResponseDebug message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ResponseDebug
         * @static
         * @param {SC2APIProtocol.ResponseDebug} message ResponseDebug
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResponseDebug.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ResponseDebug to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ResponseDebug
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResponseDebug.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResponseDebug;
    })();
    /**
     * Difficulty enum.
     * @enum {string}
     * @property {number} VeryEasy=1 VeryEasy value
     * @property {number} Easy=2 Easy value
     * @property {number} Medium=3 Medium value
     * @property {number} MediumHard=4 MediumHard value
     * @property {number} Hard=5 Hard value
     * @property {number} Harder=6 Harder value
     * @property {number} VeryHard=7 VeryHard value
     * @property {number} CheatVision=8 CheatVision value
     * @property {number} CheatMoney=9 CheatMoney value
     * @property {number} CheatInsane=10 CheatInsane value
     */
    SC2APIProtocol.Difficulty = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "VeryEasy"] = 1;
        values[valuesById[2] = "Easy"] = 2;
        values[valuesById[3] = "Medium"] = 3;
        values[valuesById[4] = "MediumHard"] = 4;
        values[valuesById[5] = "Hard"] = 5;
        values[valuesById[6] = "Harder"] = 6;
        values[valuesById[7] = "VeryHard"] = 7;
        values[valuesById[8] = "CheatVision"] = 8;
        values[valuesById[9] = "CheatMoney"] = 9;
        values[valuesById[10] = "CheatInsane"] = 10;
        return values;
    })();
    /**
     * PlayerType enum.
     * @enum {string}
     * @property {number} Participant=1 Participant value
     * @property {number} Computer=2 Computer value
     * @property {number} Observer=3 Observer value
     */
    SC2APIProtocol.PlayerType = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Participant"] = 1;
        values[valuesById[2] = "Computer"] = 2;
        values[valuesById[3] = "Observer"] = 3;
        return values;
    })();
    SC2APIProtocol.PlayerSetup = (function () {
        /**
         * Properties of a PlayerSetup.
         * @memberof SC2APIProtocol
         * @interface IPlayerSetup
         * @property {SC2APIProtocol.PlayerType} [type] PlayerSetup type
         * @property {SC2APIProtocol.Race} [race] PlayerSetup race
         * @property {SC2APIProtocol.Difficulty} [difficulty] PlayerSetup difficulty
         */
        /**
         * Constructs a new PlayerSetup.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerSetup.
         * @constructor
         * @param {SC2APIProtocol.IPlayerSetup=} [properties] Properties to set
         */
        function PlayerSetup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerSetup type.
         * @member {SC2APIProtocol.PlayerType}type
         * @memberof SC2APIProtocol.PlayerSetup
         * @instance
         */
        PlayerSetup.prototype.type = 1;
        /**
         * PlayerSetup race.
         * @member {SC2APIProtocol.Race}race
         * @memberof SC2APIProtocol.PlayerSetup
         * @instance
         */
        PlayerSetup.prototype.race = 0;
        /**
         * PlayerSetup difficulty.
         * @member {SC2APIProtocol.Difficulty}difficulty
         * @memberof SC2APIProtocol.PlayerSetup
         * @instance
         */
        PlayerSetup.prototype.difficulty = 1;
        /**
         * Creates a new PlayerSetup instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {SC2APIProtocol.IPlayerSetup=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerSetup} PlayerSetup instance
         */
        PlayerSetup.create = function create(properties) {
            return new PlayerSetup(properties);
        };
        /**
         * Encodes the specified PlayerSetup message. Does not implicitly {@link SC2APIProtocol.PlayerSetup.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {SC2APIProtocol.IPlayerSetup} message PlayerSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerSetup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
            if (message.race != null && message.hasOwnProperty("race"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.race);
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.difficulty);
            return writer;
        };
        /**
         * Encodes the specified PlayerSetup message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerSetup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {SC2APIProtocol.IPlayerSetup} message PlayerSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerSetup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerSetup message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerSetup} PlayerSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerSetup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerSetup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.race = reader.int32();
                        break;
                    case 3:
                        message.difficulty = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerSetup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerSetup} PlayerSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerSetup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerSetup message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerSetup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.race != null && message.hasOwnProperty("race"))
                switch (message.race) {
                    default:
                        return "race: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                switch (message.difficulty) {
                    default:
                        return "difficulty: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                }
            return null;
        };
        /**
         * Creates a PlayerSetup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerSetup} PlayerSetup
         */
        PlayerSetup.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerSetup)
                return object;
            var message = new $root.SC2APIProtocol.PlayerSetup();
            switch (object.type) {
                case "Participant":
                case 1:
                    message.type = 1;
                    break;
                case "Computer":
                case 2:
                    message.type = 2;
                    break;
                case "Observer":
                case 3:
                    message.type = 3;
                    break;
            }
            switch (object.race) {
                case "NoRace":
                case 0:
                    message.race = 0;
                    break;
                case "Terran":
                case 1:
                    message.race = 1;
                    break;
                case "Zerg":
                case 2:
                    message.race = 2;
                    break;
                case "Protoss":
                case 3:
                    message.race = 3;
                    break;
                case "Random":
                case 4:
                    message.race = 4;
                    break;
            }
            switch (object.difficulty) {
                case "VeryEasy":
                case 1:
                    message.difficulty = 1;
                    break;
                case "Easy":
                case 2:
                    message.difficulty = 2;
                    break;
                case "Medium":
                case 3:
                    message.difficulty = 3;
                    break;
                case "MediumHard":
                case 4:
                    message.difficulty = 4;
                    break;
                case "Hard":
                case 5:
                    message.difficulty = 5;
                    break;
                case "Harder":
                case 6:
                    message.difficulty = 6;
                    break;
                case "VeryHard":
                case 7:
                    message.difficulty = 7;
                    break;
                case "CheatVision":
                case 8:
                    message.difficulty = 8;
                    break;
                case "CheatMoney":
                case 9:
                    message.difficulty = 9;
                    break;
                case "CheatInsane":
                case 10:
                    message.difficulty = 10;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a PlayerSetup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerSetup
         * @static
         * @param {SC2APIProtocol.PlayerSetup} message PlayerSetup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerSetup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "Participant" : 1;
                object.race = options.enums === String ? "NoRace" : 0;
                object.difficulty = options.enums === String ? "VeryEasy" : 1;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.PlayerType[message.type] : message.type;
            if (message.race != null && message.hasOwnProperty("race"))
                object.race = options.enums === String ? $root.SC2APIProtocol.Race[message.race] : message.race;
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                object.difficulty = options.enums === String ? $root.SC2APIProtocol.Difficulty[message.difficulty] : message.difficulty;
            return object;
        };
        /**
         * Converts this PlayerSetup to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerSetup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerSetup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerSetup;
    })();
    SC2APIProtocol.SpatialCameraSetup = (function () {
        /**
         * Properties of a SpatialCameraSetup.
         * @memberof SC2APIProtocol
         * @interface ISpatialCameraSetup
         * @property {number} [width] SpatialCameraSetup width
         * @property {SC2APIProtocol.ISize2DI} [resolution] SpatialCameraSetup resolution
         * @property {SC2APIProtocol.ISize2DI} [minimapResolution] SpatialCameraSetup minimapResolution
         */
        /**
         * Constructs a new SpatialCameraSetup.
         * @memberof SC2APIProtocol
         * @classdesc Represents a SpatialCameraSetup.
         * @constructor
         * @param {SC2APIProtocol.ISpatialCameraSetup=} [properties] Properties to set
         */
        function SpatialCameraSetup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SpatialCameraSetup width.
         * @member {number}width
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @instance
         */
        SpatialCameraSetup.prototype.width = 0;
        /**
         * SpatialCameraSetup resolution.
         * @member {(SC2APIProtocol.ISize2DI|null|undefined)}resolution
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @instance
         */
        SpatialCameraSetup.prototype.resolution = null;
        /**
         * SpatialCameraSetup minimapResolution.
         * @member {(SC2APIProtocol.ISize2DI|null|undefined)}minimapResolution
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @instance
         */
        SpatialCameraSetup.prototype.minimapResolution = null;
        /**
         * Creates a new SpatialCameraSetup instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {SC2APIProtocol.ISpatialCameraSetup=} [properties] Properties to set
         * @returns {SC2APIProtocol.SpatialCameraSetup} SpatialCameraSetup instance
         */
        SpatialCameraSetup.create = function create(properties) {
            return new SpatialCameraSetup(properties);
        };
        /**
         * Encodes the specified SpatialCameraSetup message. Does not implicitly {@link SC2APIProtocol.SpatialCameraSetup.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {SC2APIProtocol.ISpatialCameraSetup} message SpatialCameraSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatialCameraSetup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.width != null && message.hasOwnProperty("width"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.width);
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                $root.SC2APIProtocol.Size2DI.encode(message.resolution, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.minimapResolution != null && message.hasOwnProperty("minimapResolution"))
                $root.SC2APIProtocol.Size2DI.encode(message.minimapResolution, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified SpatialCameraSetup message, length delimited. Does not implicitly {@link SC2APIProtocol.SpatialCameraSetup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {SC2APIProtocol.ISpatialCameraSetup} message SpatialCameraSetup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatialCameraSetup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SpatialCameraSetup message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.SpatialCameraSetup} SpatialCameraSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatialCameraSetup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.SpatialCameraSetup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.width = reader.float();
                        break;
                    case 2:
                        message.resolution = $root.SC2APIProtocol.Size2DI.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.minimapResolution = $root.SC2APIProtocol.Size2DI.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SpatialCameraSetup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.SpatialCameraSetup} SpatialCameraSetup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatialCameraSetup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SpatialCameraSetup message.
         * @function verify
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpatialCameraSetup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (typeof message.width !== "number")
                    return "width: number expected";
            if (message.resolution != null && message.hasOwnProperty("resolution")) {
                var error = $root.SC2APIProtocol.Size2DI.verify(message.resolution);
                if (error)
                    return "resolution." + error;
            }
            if (message.minimapResolution != null && message.hasOwnProperty("minimapResolution")) {
                error = $root.SC2APIProtocol.Size2DI.verify(message.minimapResolution);
                if (error)
                    return "minimapResolution." + error;
            }
            return null;
        };
        /**
         * Creates a SpatialCameraSetup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.SpatialCameraSetup} SpatialCameraSetup
         */
        SpatialCameraSetup.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.SpatialCameraSetup)
                return object;
            var message = new $root.SC2APIProtocol.SpatialCameraSetup();
            if (object.width != null)
                message.width = Number(object.width);
            if (object.resolution != null) {
                if (typeof object.resolution !== "object")
                    throw TypeError(".SC2APIProtocol.SpatialCameraSetup.resolution: object expected");
                message.resolution = $root.SC2APIProtocol.Size2DI.fromObject(object.resolution);
            }
            if (object.minimapResolution != null) {
                if (typeof object.minimapResolution !== "object")
                    throw TypeError(".SC2APIProtocol.SpatialCameraSetup.minimapResolution: object expected");
                message.minimapResolution = $root.SC2APIProtocol.Size2DI.fromObject(object.minimapResolution);
            }
            return message;
        };
        /**
         * Creates a plain object from a SpatialCameraSetup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @static
         * @param {SC2APIProtocol.SpatialCameraSetup} message SpatialCameraSetup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpatialCameraSetup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.width = 0;
                object.resolution = null;
                object.minimapResolution = null;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                object.resolution = $root.SC2APIProtocol.Size2DI.toObject(message.resolution, options);
            if (message.minimapResolution != null && message.hasOwnProperty("minimapResolution"))
                object.minimapResolution = $root.SC2APIProtocol.Size2DI.toObject(message.minimapResolution, options);
            return object;
        };
        /**
         * Converts this SpatialCameraSetup to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.SpatialCameraSetup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpatialCameraSetup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SpatialCameraSetup;
    })();
    SC2APIProtocol.InterfaceOptions = (function () {
        /**
         * Properties of an InterfaceOptions.
         * @memberof SC2APIProtocol
         * @interface IInterfaceOptions
         * @property {boolean} [raw] InterfaceOptions raw
         * @property {boolean} [score] InterfaceOptions score
         * @property {SC2APIProtocol.ISpatialCameraSetup} [featureLayer] InterfaceOptions featureLayer
         * @property {SC2APIProtocol.ISpatialCameraSetup} [render] InterfaceOptions render
         */
        /**
         * Constructs a new InterfaceOptions.
         * @memberof SC2APIProtocol
         * @classdesc Represents an InterfaceOptions.
         * @constructor
         * @param {SC2APIProtocol.IInterfaceOptions=} [properties] Properties to set
         */
        function InterfaceOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * InterfaceOptions raw.
         * @member {boolean}raw
         * @memberof SC2APIProtocol.InterfaceOptions
         * @instance
         */
        InterfaceOptions.prototype.raw = false;
        /**
         * InterfaceOptions score.
         * @member {boolean}score
         * @memberof SC2APIProtocol.InterfaceOptions
         * @instance
         */
        InterfaceOptions.prototype.score = false;
        /**
         * InterfaceOptions featureLayer.
         * @member {(SC2APIProtocol.ISpatialCameraSetup|null|undefined)}featureLayer
         * @memberof SC2APIProtocol.InterfaceOptions
         * @instance
         */
        InterfaceOptions.prototype.featureLayer = null;
        /**
         * InterfaceOptions render.
         * @member {(SC2APIProtocol.ISpatialCameraSetup|null|undefined)}render
         * @memberof SC2APIProtocol.InterfaceOptions
         * @instance
         */
        InterfaceOptions.prototype.render = null;
        /**
         * Creates a new InterfaceOptions instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {SC2APIProtocol.IInterfaceOptions=} [properties] Properties to set
         * @returns {SC2APIProtocol.InterfaceOptions} InterfaceOptions instance
         */
        InterfaceOptions.create = function create(properties) {
            return new InterfaceOptions(properties);
        };
        /**
         * Encodes the specified InterfaceOptions message. Does not implicitly {@link SC2APIProtocol.InterfaceOptions.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {SC2APIProtocol.IInterfaceOptions} message InterfaceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InterfaceOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.raw != null && message.hasOwnProperty("raw"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.raw);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.score);
            if (message.featureLayer != null && message.hasOwnProperty("featureLayer"))
                $root.SC2APIProtocol.SpatialCameraSetup.encode(message.featureLayer, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.render != null && message.hasOwnProperty("render"))
                $root.SC2APIProtocol.SpatialCameraSetup.encode(message.render, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified InterfaceOptions message, length delimited. Does not implicitly {@link SC2APIProtocol.InterfaceOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {SC2APIProtocol.IInterfaceOptions} message InterfaceOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InterfaceOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an InterfaceOptions message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.InterfaceOptions} InterfaceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InterfaceOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.InterfaceOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.raw = reader.bool();
                        break;
                    case 2:
                        message.score = reader.bool();
                        break;
                    case 3:
                        message.featureLayer = $root.SC2APIProtocol.SpatialCameraSetup.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.render = $root.SC2APIProtocol.SpatialCameraSetup.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an InterfaceOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.InterfaceOptions} InterfaceOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InterfaceOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an InterfaceOptions message.
         * @function verify
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InterfaceOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.raw != null && message.hasOwnProperty("raw"))
                if (typeof message.raw !== "boolean")
                    return "raw: boolean expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "boolean")
                    return "score: boolean expected";
            if (message.featureLayer != null && message.hasOwnProperty("featureLayer")) {
                var error = $root.SC2APIProtocol.SpatialCameraSetup.verify(message.featureLayer);
                if (error)
                    return "featureLayer." + error;
            }
            if (message.render != null && message.hasOwnProperty("render")) {
                error = $root.SC2APIProtocol.SpatialCameraSetup.verify(message.render);
                if (error)
                    return "render." + error;
            }
            return null;
        };
        /**
         * Creates an InterfaceOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.InterfaceOptions} InterfaceOptions
         */
        InterfaceOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.InterfaceOptions)
                return object;
            var message = new $root.SC2APIProtocol.InterfaceOptions();
            if (object.raw != null)
                message.raw = Boolean(object.raw);
            if (object.score != null)
                message.score = Boolean(object.score);
            if (object.featureLayer != null) {
                if (typeof object.featureLayer !== "object")
                    throw TypeError(".SC2APIProtocol.InterfaceOptions.featureLayer: object expected");
                message.featureLayer = $root.SC2APIProtocol.SpatialCameraSetup.fromObject(object.featureLayer);
            }
            if (object.render != null) {
                if (typeof object.render !== "object")
                    throw TypeError(".SC2APIProtocol.InterfaceOptions.render: object expected");
                message.render = $root.SC2APIProtocol.SpatialCameraSetup.fromObject(object.render);
            }
            return message;
        };
        /**
         * Creates a plain object from an InterfaceOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.InterfaceOptions
         * @static
         * @param {SC2APIProtocol.InterfaceOptions} message InterfaceOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InterfaceOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.raw = false;
                object.score = false;
                object.featureLayer = null;
                object.render = null;
            }
            if (message.raw != null && message.hasOwnProperty("raw"))
                object.raw = message.raw;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.featureLayer != null && message.hasOwnProperty("featureLayer"))
                object.featureLayer = $root.SC2APIProtocol.SpatialCameraSetup.toObject(message.featureLayer, options);
            if (message.render != null && message.hasOwnProperty("render"))
                object.render = $root.SC2APIProtocol.SpatialCameraSetup.toObject(message.render, options);
            return object;
        };
        /**
         * Converts this InterfaceOptions to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.InterfaceOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InterfaceOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InterfaceOptions;
    })();
    SC2APIProtocol.PlayerInfo = (function () {
        /**
         * Properties of a PlayerInfo.
         * @memberof SC2APIProtocol
         * @interface IPlayerInfo
         * @property {number} [playerId] PlayerInfo playerId
         * @property {SC2APIProtocol.PlayerType} [type] PlayerInfo type
         * @property {SC2APIProtocol.Race} [raceRequested] PlayerInfo raceRequested
         * @property {SC2APIProtocol.Race} [raceActual] PlayerInfo raceActual
         * @property {SC2APIProtocol.Difficulty} [difficulty] PlayerInfo difficulty
         */
        /**
         * Constructs a new PlayerInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerInfo.
         * @constructor
         * @param {SC2APIProtocol.IPlayerInfo=} [properties] Properties to set
         */
        function PlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerInfo playerId.
         * @member {number}playerId
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.playerId = 0;
        /**
         * PlayerInfo type.
         * @member {SC2APIProtocol.PlayerType}type
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.type = 1;
        /**
         * PlayerInfo raceRequested.
         * @member {SC2APIProtocol.Race}raceRequested
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.raceRequested = 0;
        /**
         * PlayerInfo raceActual.
         * @member {SC2APIProtocol.Race}raceActual
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.raceActual = 0;
        /**
         * PlayerInfo difficulty.
         * @member {SC2APIProtocol.Difficulty}difficulty
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.difficulty = 1;
        /**
         * Creates a new PlayerInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {SC2APIProtocol.IPlayerInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerInfo} PlayerInfo instance
         */
        PlayerInfo.create = function create(properties) {
            return new PlayerInfo(properties);
        };
        /**
         * Encodes the specified PlayerInfo message. Does not implicitly {@link SC2APIProtocol.PlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {SC2APIProtocol.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.playerId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
            if (message.raceRequested != null && message.hasOwnProperty("raceRequested"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.raceRequested);
            if (message.raceActual != null && message.hasOwnProperty("raceActual"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.raceActual);
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.difficulty);
            return writer;
        };
        /**
         * Encodes the specified PlayerInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {SC2APIProtocol.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.raceRequested = reader.int32();
                        break;
                    case 4:
                        message.raceActual = reader.int32();
                        break;
                    case 5:
                        message.difficulty = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerInfo message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId))
                    return "playerId: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.raceRequested != null && message.hasOwnProperty("raceRequested"))
                switch (message.raceRequested) {
                    default:
                        return "raceRequested: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.raceActual != null && message.hasOwnProperty("raceActual"))
                switch (message.raceActual) {
                    default:
                        return "raceActual: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                switch (message.difficulty) {
                    default:
                        return "difficulty: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                }
            return null;
        };
        /**
         * Creates a PlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerInfo} PlayerInfo
         */
        PlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerInfo)
                return object;
            var message = new $root.SC2APIProtocol.PlayerInfo();
            if (object.playerId != null)
                message.playerId = object.playerId >>> 0;
            switch (object.type) {
                case "Participant":
                case 1:
                    message.type = 1;
                    break;
                case "Computer":
                case 2:
                    message.type = 2;
                    break;
                case "Observer":
                case 3:
                    message.type = 3;
                    break;
            }
            switch (object.raceRequested) {
                case "NoRace":
                case 0:
                    message.raceRequested = 0;
                    break;
                case "Terran":
                case 1:
                    message.raceRequested = 1;
                    break;
                case "Zerg":
                case 2:
                    message.raceRequested = 2;
                    break;
                case "Protoss":
                case 3:
                    message.raceRequested = 3;
                    break;
                case "Random":
                case 4:
                    message.raceRequested = 4;
                    break;
            }
            switch (object.raceActual) {
                case "NoRace":
                case 0:
                    message.raceActual = 0;
                    break;
                case "Terran":
                case 1:
                    message.raceActual = 1;
                    break;
                case "Zerg":
                case 2:
                    message.raceActual = 2;
                    break;
                case "Protoss":
                case 3:
                    message.raceActual = 3;
                    break;
                case "Random":
                case 4:
                    message.raceActual = 4;
                    break;
            }
            switch (object.difficulty) {
                case "VeryEasy":
                case 1:
                    message.difficulty = 1;
                    break;
                case "Easy":
                case 2:
                    message.difficulty = 2;
                    break;
                case "Medium":
                case 3:
                    message.difficulty = 3;
                    break;
                case "MediumHard":
                case 4:
                    message.difficulty = 4;
                    break;
                case "Hard":
                case 5:
                    message.difficulty = 5;
                    break;
                case "Harder":
                case 6:
                    message.difficulty = 6;
                    break;
                case "VeryHard":
                case 7:
                    message.difficulty = 7;
                    break;
                case "CheatVision":
                case 8:
                    message.difficulty = 8;
                    break;
                case "CheatMoney":
                case 9:
                    message.difficulty = 9;
                    break;
                case "CheatInsane":
                case 10:
                    message.difficulty = 10;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a PlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerInfo
         * @static
         * @param {SC2APIProtocol.PlayerInfo} message PlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerId = 0;
                object.type = options.enums === String ? "Participant" : 1;
                object.raceRequested = options.enums === String ? "NoRace" : 0;
                object.raceActual = options.enums === String ? "NoRace" : 0;
                object.difficulty = options.enums === String ? "VeryEasy" : 1;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.PlayerType[message.type] : message.type;
            if (message.raceRequested != null && message.hasOwnProperty("raceRequested"))
                object.raceRequested = options.enums === String ? $root.SC2APIProtocol.Race[message.raceRequested] : message.raceRequested;
            if (message.raceActual != null && message.hasOwnProperty("raceActual"))
                object.raceActual = options.enums === String ? $root.SC2APIProtocol.Race[message.raceActual] : message.raceActual;
            if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                object.difficulty = options.enums === String ? $root.SC2APIProtocol.Difficulty[message.difficulty] : message.difficulty;
            return object;
        };
        /**
         * Converts this PlayerInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerInfo;
    })();
    SC2APIProtocol.PlayerCommon = (function () {
        /**
         * Properties of a PlayerCommon.
         * @memberof SC2APIProtocol
         * @interface IPlayerCommon
         * @property {number} [playerId] PlayerCommon playerId
         * @property {number} [minerals] PlayerCommon minerals
         * @property {number} [vespene] PlayerCommon vespene
         * @property {number} [foodCap] PlayerCommon foodCap
         * @property {number} [foodUsed] PlayerCommon foodUsed
         * @property {number} [foodArmy] PlayerCommon foodArmy
         * @property {number} [foodWorkers] PlayerCommon foodWorkers
         * @property {number} [idleWorkerCount] PlayerCommon idleWorkerCount
         * @property {number} [armyCount] PlayerCommon armyCount
         * @property {number} [warpGateCount] PlayerCommon warpGateCount
         * @property {number} [larvaCount] PlayerCommon larvaCount
         */
        /**
         * Constructs a new PlayerCommon.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerCommon.
         * @constructor
         * @param {SC2APIProtocol.IPlayerCommon=} [properties] Properties to set
         */
        function PlayerCommon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerCommon playerId.
         * @member {number}playerId
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.playerId = 0;
        /**
         * PlayerCommon minerals.
         * @member {number}minerals
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.minerals = 0;
        /**
         * PlayerCommon vespene.
         * @member {number}vespene
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.vespene = 0;
        /**
         * PlayerCommon foodCap.
         * @member {number}foodCap
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.foodCap = 0;
        /**
         * PlayerCommon foodUsed.
         * @member {number}foodUsed
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.foodUsed = 0;
        /**
         * PlayerCommon foodArmy.
         * @member {number}foodArmy
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.foodArmy = 0;
        /**
         * PlayerCommon foodWorkers.
         * @member {number}foodWorkers
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.foodWorkers = 0;
        /**
         * PlayerCommon idleWorkerCount.
         * @member {number}idleWorkerCount
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.idleWorkerCount = 0;
        /**
         * PlayerCommon armyCount.
         * @member {number}armyCount
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.armyCount = 0;
        /**
         * PlayerCommon warpGateCount.
         * @member {number}warpGateCount
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.warpGateCount = 0;
        /**
         * PlayerCommon larvaCount.
         * @member {number}larvaCount
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         */
        PlayerCommon.prototype.larvaCount = 0;
        /**
         * Creates a new PlayerCommon instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {SC2APIProtocol.IPlayerCommon=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerCommon} PlayerCommon instance
         */
        PlayerCommon.create = function create(properties) {
            return new PlayerCommon(properties);
        };
        /**
         * Encodes the specified PlayerCommon message. Does not implicitly {@link SC2APIProtocol.PlayerCommon.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {SC2APIProtocol.IPlayerCommon} message PlayerCommon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerCommon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.playerId);
            if (message.minerals != null && message.hasOwnProperty("minerals"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.minerals);
            if (message.vespene != null && message.hasOwnProperty("vespene"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.vespene);
            if (message.foodCap != null && message.hasOwnProperty("foodCap"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.foodCap);
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.foodUsed);
            if (message.foodArmy != null && message.hasOwnProperty("foodArmy"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).uint32(message.foodArmy);
            if (message.foodWorkers != null && message.hasOwnProperty("foodWorkers"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).uint32(message.foodWorkers);
            if (message.idleWorkerCount != null && message.hasOwnProperty("idleWorkerCount"))
                writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.idleWorkerCount);
            if (message.armyCount != null && message.hasOwnProperty("armyCount"))
                writer.uint32(/* id 9, wireType 0 =*/ 72).uint32(message.armyCount);
            if (message.warpGateCount != null && message.hasOwnProperty("warpGateCount"))
                writer.uint32(/* id 10, wireType 0 =*/ 80).uint32(message.warpGateCount);
            if (message.larvaCount != null && message.hasOwnProperty("larvaCount"))
                writer.uint32(/* id 11, wireType 0 =*/ 88).uint32(message.larvaCount);
            return writer;
        };
        /**
         * Encodes the specified PlayerCommon message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerCommon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {SC2APIProtocol.IPlayerCommon} message PlayerCommon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerCommon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerCommon message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerCommon} PlayerCommon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerCommon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerCommon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.minerals = reader.uint32();
                        break;
                    case 3:
                        message.vespene = reader.uint32();
                        break;
                    case 4:
                        message.foodCap = reader.uint32();
                        break;
                    case 5:
                        message.foodUsed = reader.uint32();
                        break;
                    case 6:
                        message.foodArmy = reader.uint32();
                        break;
                    case 7:
                        message.foodWorkers = reader.uint32();
                        break;
                    case 8:
                        message.idleWorkerCount = reader.uint32();
                        break;
                    case 9:
                        message.armyCount = reader.uint32();
                        break;
                    case 10:
                        message.warpGateCount = reader.uint32();
                        break;
                    case 11:
                        message.larvaCount = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerCommon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerCommon} PlayerCommon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerCommon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerCommon message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerCommon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId))
                    return "playerId: integer expected";
            if (message.minerals != null && message.hasOwnProperty("minerals"))
                if (!$util.isInteger(message.minerals))
                    return "minerals: integer expected";
            if (message.vespene != null && message.hasOwnProperty("vespene"))
                if (!$util.isInteger(message.vespene))
                    return "vespene: integer expected";
            if (message.foodCap != null && message.hasOwnProperty("foodCap"))
                if (!$util.isInteger(message.foodCap))
                    return "foodCap: integer expected";
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed"))
                if (!$util.isInteger(message.foodUsed))
                    return "foodUsed: integer expected";
            if (message.foodArmy != null && message.hasOwnProperty("foodArmy"))
                if (!$util.isInteger(message.foodArmy))
                    return "foodArmy: integer expected";
            if (message.foodWorkers != null && message.hasOwnProperty("foodWorkers"))
                if (!$util.isInteger(message.foodWorkers))
                    return "foodWorkers: integer expected";
            if (message.idleWorkerCount != null && message.hasOwnProperty("idleWorkerCount"))
                if (!$util.isInteger(message.idleWorkerCount))
                    return "idleWorkerCount: integer expected";
            if (message.armyCount != null && message.hasOwnProperty("armyCount"))
                if (!$util.isInteger(message.armyCount))
                    return "armyCount: integer expected";
            if (message.warpGateCount != null && message.hasOwnProperty("warpGateCount"))
                if (!$util.isInteger(message.warpGateCount))
                    return "warpGateCount: integer expected";
            if (message.larvaCount != null && message.hasOwnProperty("larvaCount"))
                if (!$util.isInteger(message.larvaCount))
                    return "larvaCount: integer expected";
            return null;
        };
        /**
         * Creates a PlayerCommon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerCommon} PlayerCommon
         */
        PlayerCommon.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerCommon)
                return object;
            var message = new $root.SC2APIProtocol.PlayerCommon();
            if (object.playerId != null)
                message.playerId = object.playerId >>> 0;
            if (object.minerals != null)
                message.minerals = object.minerals >>> 0;
            if (object.vespene != null)
                message.vespene = object.vespene >>> 0;
            if (object.foodCap != null)
                message.foodCap = object.foodCap >>> 0;
            if (object.foodUsed != null)
                message.foodUsed = object.foodUsed >>> 0;
            if (object.foodArmy != null)
                message.foodArmy = object.foodArmy >>> 0;
            if (object.foodWorkers != null)
                message.foodWorkers = object.foodWorkers >>> 0;
            if (object.idleWorkerCount != null)
                message.idleWorkerCount = object.idleWorkerCount >>> 0;
            if (object.armyCount != null)
                message.armyCount = object.armyCount >>> 0;
            if (object.warpGateCount != null)
                message.warpGateCount = object.warpGateCount >>> 0;
            if (object.larvaCount != null)
                message.larvaCount = object.larvaCount >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a PlayerCommon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerCommon
         * @static
         * @param {SC2APIProtocol.PlayerCommon} message PlayerCommon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerCommon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerId = 0;
                object.minerals = 0;
                object.vespene = 0;
                object.foodCap = 0;
                object.foodUsed = 0;
                object.foodArmy = 0;
                object.foodWorkers = 0;
                object.idleWorkerCount = 0;
                object.armyCount = 0;
                object.warpGateCount = 0;
                object.larvaCount = 0;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.minerals != null && message.hasOwnProperty("minerals"))
                object.minerals = message.minerals;
            if (message.vespene != null && message.hasOwnProperty("vespene"))
                object.vespene = message.vespene;
            if (message.foodCap != null && message.hasOwnProperty("foodCap"))
                object.foodCap = message.foodCap;
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed"))
                object.foodUsed = message.foodUsed;
            if (message.foodArmy != null && message.hasOwnProperty("foodArmy"))
                object.foodArmy = message.foodArmy;
            if (message.foodWorkers != null && message.hasOwnProperty("foodWorkers"))
                object.foodWorkers = message.foodWorkers;
            if (message.idleWorkerCount != null && message.hasOwnProperty("idleWorkerCount"))
                object.idleWorkerCount = message.idleWorkerCount;
            if (message.armyCount != null && message.hasOwnProperty("armyCount"))
                object.armyCount = message.armyCount;
            if (message.warpGateCount != null && message.hasOwnProperty("warpGateCount"))
                object.warpGateCount = message.warpGateCount;
            if (message.larvaCount != null && message.hasOwnProperty("larvaCount"))
                object.larvaCount = message.larvaCount;
            return object;
        };
        /**
         * Converts this PlayerCommon to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerCommon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerCommon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerCommon;
    })();
    SC2APIProtocol.Observation = (function () {
        /**
         * Properties of an Observation.
         * @memberof SC2APIProtocol
         * @interface IObservation
         * @property {number} [gameLoop] Observation gameLoop
         * @property {SC2APIProtocol.IPlayerCommon} [playerCommon] Observation playerCommon
         * @property {Array.<SC2APIProtocol.Alert>} [alerts] Observation alerts
         * @property {Array.<SC2APIProtocol.IAvailableAbility>} [abilities] Observation abilities
         * @property {SC2APIProtocol.IScore} [score] Observation score
         * @property {SC2APIProtocol.IObservationRaw} [rawData] Observation rawData
         * @property {SC2APIProtocol.IObservationFeatureLayer} [featureLayerData] Observation featureLayerData
         * @property {SC2APIProtocol.IObservationRender} [renderData] Observation renderData
         * @property {SC2APIProtocol.IObservationUI} [uiData] Observation uiData
         */
        /**
         * Constructs a new Observation.
         * @memberof SC2APIProtocol
         * @classdesc Represents an Observation.
         * @constructor
         * @param {SC2APIProtocol.IObservation=} [properties] Properties to set
         */
        function Observation(properties) {
            this.alerts = [];
            this.abilities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Observation gameLoop.
         * @member {number}gameLoop
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.gameLoop = 0;
        /**
         * Observation playerCommon.
         * @member {(SC2APIProtocol.IPlayerCommon|null|undefined)}playerCommon
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.playerCommon = null;
        /**
         * Observation alerts.
         * @member {Array.<SC2APIProtocol.Alert>}alerts
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.alerts = $util.emptyArray;
        /**
         * Observation abilities.
         * @member {Array.<SC2APIProtocol.IAvailableAbility>}abilities
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.abilities = $util.emptyArray;
        /**
         * Observation score.
         * @member {(SC2APIProtocol.IScore|null|undefined)}score
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.score = null;
        /**
         * Observation rawData.
         * @member {(SC2APIProtocol.IObservationRaw|null|undefined)}rawData
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.rawData = null;
        /**
         * Observation featureLayerData.
         * @member {(SC2APIProtocol.IObservationFeatureLayer|null|undefined)}featureLayerData
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.featureLayerData = null;
        /**
         * Observation renderData.
         * @member {(SC2APIProtocol.IObservationRender|null|undefined)}renderData
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.renderData = null;
        /**
         * Observation uiData.
         * @member {(SC2APIProtocol.IObservationUI|null|undefined)}uiData
         * @memberof SC2APIProtocol.Observation
         * @instance
         */
        Observation.prototype.uiData = null;
        /**
         * Creates a new Observation instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {SC2APIProtocol.IObservation=} [properties] Properties to set
         * @returns {SC2APIProtocol.Observation} Observation instance
         */
        Observation.create = function create(properties) {
            return new Observation(properties);
        };
        /**
         * Encodes the specified Observation message. Does not implicitly {@link SC2APIProtocol.Observation.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {SC2APIProtocol.IObservation} message Observation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Observation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerCommon != null && message.hasOwnProperty("playerCommon"))
                $root.SC2APIProtocol.PlayerCommon.encode(message.playerCommon, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.abilities != null && message.abilities.length)
                for (var i = 0; i < message.abilities.length; ++i)
                    $root.SC2APIProtocol.AvailableAbility.encode(message.abilities[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.score != null && message.hasOwnProperty("score"))
                $root.SC2APIProtocol.Score.encode(message.score, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                $root.SC2APIProtocol.ObservationRaw.encode(message.rawData, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.featureLayerData != null && message.hasOwnProperty("featureLayerData"))
                $root.SC2APIProtocol.ObservationFeatureLayer.encode(message.featureLayerData, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.renderData != null && message.hasOwnProperty("renderData"))
                $root.SC2APIProtocol.ObservationRender.encode(message.renderData, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.uiData != null && message.hasOwnProperty("uiData"))
                $root.SC2APIProtocol.ObservationUI.encode(message.uiData, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.gameLoop != null && message.hasOwnProperty("gameLoop"))
                writer.uint32(/* id 9, wireType 0 =*/ 72).uint32(message.gameLoop);
            if (message.alerts != null && message.alerts.length)
                for (var i = 0; i < message.alerts.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.alerts[i]);
            return writer;
        };
        /**
         * Encodes the specified Observation message, length delimited. Does not implicitly {@link SC2APIProtocol.Observation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {SC2APIProtocol.IObservation} message Observation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Observation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Observation message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Observation} Observation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Observation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Observation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 9:
                        message.gameLoop = reader.uint32();
                        break;
                    case 1:
                        message.playerCommon = $root.SC2APIProtocol.PlayerCommon.decode(reader, reader.uint32());
                        break;
                    case 10:
                        if (!(message.alerts && message.alerts.length))
                            message.alerts = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.alerts.push(reader.int32());
                        }
                        else
                            message.alerts.push(reader.int32());
                        break;
                    case 3:
                        if (!(message.abilities && message.abilities.length))
                            message.abilities = [];
                        message.abilities.push($root.SC2APIProtocol.AvailableAbility.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.score = $root.SC2APIProtocol.Score.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.rawData = $root.SC2APIProtocol.ObservationRaw.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.featureLayerData = $root.SC2APIProtocol.ObservationFeatureLayer.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.renderData = $root.SC2APIProtocol.ObservationRender.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.uiData = $root.SC2APIProtocol.ObservationUI.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Observation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Observation} Observation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Observation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Observation message.
         * @function verify
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Observation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameLoop != null && message.hasOwnProperty("gameLoop"))
                if (!$util.isInteger(message.gameLoop))
                    return "gameLoop: integer expected";
            if (message.playerCommon != null && message.hasOwnProperty("playerCommon")) {
                var error = $root.SC2APIProtocol.PlayerCommon.verify(message.playerCommon);
                if (error)
                    return "playerCommon." + error;
            }
            if (message.alerts != null && message.hasOwnProperty("alerts")) {
                if (!Array.isArray(message.alerts))
                    return "alerts: array expected";
                for (var i = 0; i < message.alerts.length; ++i)
                    switch (message.alerts[i]) {
                        default:
                            return "alerts: enum value[] expected";
                        case 1:
                        case 2:
                            break;
                    }
            }
            if (message.abilities != null && message.hasOwnProperty("abilities")) {
                if (!Array.isArray(message.abilities))
                    return "abilities: array expected";
                for (var i = 0; i < message.abilities.length; ++i) {
                    error = $root.SC2APIProtocol.AvailableAbility.verify(message.abilities[i]);
                    if (error)
                        return "abilities." + error;
                }
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                error = $root.SC2APIProtocol.Score.verify(message.score);
                if (error)
                    return "score." + error;
            }
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                error = $root.SC2APIProtocol.ObservationRaw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.featureLayerData != null && message.hasOwnProperty("featureLayerData")) {
                error = $root.SC2APIProtocol.ObservationFeatureLayer.verify(message.featureLayerData);
                if (error)
                    return "featureLayerData." + error;
            }
            if (message.renderData != null && message.hasOwnProperty("renderData")) {
                error = $root.SC2APIProtocol.ObservationRender.verify(message.renderData);
                if (error)
                    return "renderData." + error;
            }
            if (message.uiData != null && message.hasOwnProperty("uiData")) {
                error = $root.SC2APIProtocol.ObservationUI.verify(message.uiData);
                if (error)
                    return "uiData." + error;
            }
            return null;
        };
        /**
         * Creates an Observation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Observation} Observation
         */
        Observation.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Observation)
                return object;
            var message = new $root.SC2APIProtocol.Observation();
            if (object.gameLoop != null)
                message.gameLoop = object.gameLoop >>> 0;
            if (object.playerCommon != null) {
                if (typeof object.playerCommon !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.playerCommon: object expected");
                message.playerCommon = $root.SC2APIProtocol.PlayerCommon.fromObject(object.playerCommon);
            }
            if (object.alerts) {
                if (!Array.isArray(object.alerts))
                    throw TypeError(".SC2APIProtocol.Observation.alerts: array expected");
                message.alerts = [];
                for (var i = 0; i < object.alerts.length; ++i)
                    switch (object.alerts[i]) {
                        default:
                        case "NuclearLaunchDetected":
                        case 1:
                            message.alerts[i] = 1;
                            break;
                        case "NydusWormDetected":
                        case 2:
                            message.alerts[i] = 2;
                            break;
                    }
            }
            if (object.abilities) {
                if (!Array.isArray(object.abilities))
                    throw TypeError(".SC2APIProtocol.Observation.abilities: array expected");
                message.abilities = [];
                for (var i = 0; i < object.abilities.length; ++i) {
                    if (typeof object.abilities[i] !== "object")
                        throw TypeError(".SC2APIProtocol.Observation.abilities: object expected");
                    message.abilities[i] = $root.SC2APIProtocol.AvailableAbility.fromObject(object.abilities[i]);
                }
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.score: object expected");
                message.score = $root.SC2APIProtocol.Score.fromObject(object.score);
            }
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.rawData: object expected");
                message.rawData = $root.SC2APIProtocol.ObservationRaw.fromObject(object.rawData);
            }
            if (object.featureLayerData != null) {
                if (typeof object.featureLayerData !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.featureLayerData: object expected");
                message.featureLayerData = $root.SC2APIProtocol.ObservationFeatureLayer.fromObject(object.featureLayerData);
            }
            if (object.renderData != null) {
                if (typeof object.renderData !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.renderData: object expected");
                message.renderData = $root.SC2APIProtocol.ObservationRender.fromObject(object.renderData);
            }
            if (object.uiData != null) {
                if (typeof object.uiData !== "object")
                    throw TypeError(".SC2APIProtocol.Observation.uiData: object expected");
                message.uiData = $root.SC2APIProtocol.ObservationUI.fromObject(object.uiData);
            }
            return message;
        };
        /**
         * Creates a plain object from an Observation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Observation
         * @static
         * @param {SC2APIProtocol.Observation} message Observation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Observation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.abilities = [];
                object.alerts = [];
            }
            if (options.defaults) {
                object.playerCommon = null;
                object.score = null;
                object.rawData = null;
                object.featureLayerData = null;
                object.renderData = null;
                object.uiData = null;
                object.gameLoop = 0;
            }
            if (message.playerCommon != null && message.hasOwnProperty("playerCommon"))
                object.playerCommon = $root.SC2APIProtocol.PlayerCommon.toObject(message.playerCommon, options);
            if (message.abilities && message.abilities.length) {
                object.abilities = [];
                for (var j = 0; j < message.abilities.length; ++j)
                    object.abilities[j] = $root.SC2APIProtocol.AvailableAbility.toObject(message.abilities[j], options);
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.SC2APIProtocol.Score.toObject(message.score, options);
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.SC2APIProtocol.ObservationRaw.toObject(message.rawData, options);
            if (message.featureLayerData != null && message.hasOwnProperty("featureLayerData"))
                object.featureLayerData = $root.SC2APIProtocol.ObservationFeatureLayer.toObject(message.featureLayerData, options);
            if (message.renderData != null && message.hasOwnProperty("renderData"))
                object.renderData = $root.SC2APIProtocol.ObservationRender.toObject(message.renderData, options);
            if (message.uiData != null && message.hasOwnProperty("uiData"))
                object.uiData = $root.SC2APIProtocol.ObservationUI.toObject(message.uiData, options);
            if (message.gameLoop != null && message.hasOwnProperty("gameLoop"))
                object.gameLoop = message.gameLoop;
            if (message.alerts && message.alerts.length) {
                object.alerts = [];
                for (var j = 0; j < message.alerts.length; ++j)
                    object.alerts[j] = options.enums === String ? $root.SC2APIProtocol.Alert[message.alerts[j]] : message.alerts[j];
            }
            return object;
        };
        /**
         * Converts this Observation to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Observation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Observation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Observation;
    })();
    SC2APIProtocol.Action = (function () {
        /**
         * Properties of an Action.
         * @memberof SC2APIProtocol
         * @interface IAction
         * @property {SC2APIProtocol.IActionRaw} [actionRaw] Action actionRaw
         * @property {SC2APIProtocol.IActionSpatial} [actionFeatureLayer] Action actionFeatureLayer
         * @property {SC2APIProtocol.IActionSpatial} [actionRender] Action actionRender
         * @property {SC2APIProtocol.IActionUI} [actionUi] Action actionUi
         * @property {Array.<SC2APIProtocol.IActionChat>} [chat] Action chat
         */
        /**
         * Constructs a new Action.
         * @memberof SC2APIProtocol
         * @classdesc Represents an Action.
         * @constructor
         * @param {SC2APIProtocol.IAction=} [properties] Properties to set
         */
        function Action(properties) {
            this.chat = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Action actionRaw.
         * @member {(SC2APIProtocol.IActionRaw|null|undefined)}actionRaw
         * @memberof SC2APIProtocol.Action
         * @instance
         */
        Action.prototype.actionRaw = null;
        /**
         * Action actionFeatureLayer.
         * @member {(SC2APIProtocol.IActionSpatial|null|undefined)}actionFeatureLayer
         * @memberof SC2APIProtocol.Action
         * @instance
         */
        Action.prototype.actionFeatureLayer = null;
        /**
         * Action actionRender.
         * @member {(SC2APIProtocol.IActionSpatial|null|undefined)}actionRender
         * @memberof SC2APIProtocol.Action
         * @instance
         */
        Action.prototype.actionRender = null;
        /**
         * Action actionUi.
         * @member {(SC2APIProtocol.IActionUI|null|undefined)}actionUi
         * @memberof SC2APIProtocol.Action
         * @instance
         */
        Action.prototype.actionUi = null;
        /**
         * Action chat.
         * @member {Array.<SC2APIProtocol.IActionChat>}chat
         * @memberof SC2APIProtocol.Action
         * @instance
         */
        Action.prototype.chat = $util.emptyArray;
        /**
         * Creates a new Action instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {SC2APIProtocol.IAction=} [properties] Properties to set
         * @returns {SC2APIProtocol.Action} Action instance
         */
        Action.create = function create(properties) {
            return new Action(properties);
        };
        /**
         * Encodes the specified Action message. Does not implicitly {@link SC2APIProtocol.Action.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {SC2APIProtocol.IAction} message Action message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionRaw != null && message.hasOwnProperty("actionRaw"))
                $root.SC2APIProtocol.ActionRaw.encode(message.actionRaw, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.actionFeatureLayer != null && message.hasOwnProperty("actionFeatureLayer"))
                $root.SC2APIProtocol.ActionSpatial.encode(message.actionFeatureLayer, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.actionRender != null && message.hasOwnProperty("actionRender"))
                $root.SC2APIProtocol.ActionSpatial.encode(message.actionRender, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.actionUi != null && message.hasOwnProperty("actionUi"))
                $root.SC2APIProtocol.ActionUI.encode(message.actionUi, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.chat != null && message.chat.length)
                for (var i = 0; i < message.chat.length; ++i)
                    $root.SC2APIProtocol.ActionChat.encode(message.chat[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Action message, length delimited. Does not implicitly {@link SC2APIProtocol.Action.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {SC2APIProtocol.IAction} message Action message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an Action message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Action} Action
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Action();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.actionRaw = $root.SC2APIProtocol.ActionRaw.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.actionFeatureLayer = $root.SC2APIProtocol.ActionSpatial.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.actionRender = $root.SC2APIProtocol.ActionSpatial.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.actionUi = $root.SC2APIProtocol.ActionUI.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.chat && message.chat.length))
                            message.chat = [];
                        message.chat.push($root.SC2APIProtocol.ActionChat.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an Action message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Action} Action
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an Action message.
         * @function verify
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Action.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionRaw != null && message.hasOwnProperty("actionRaw")) {
                var error = $root.SC2APIProtocol.ActionRaw.verify(message.actionRaw);
                if (error)
                    return "actionRaw." + error;
            }
            if (message.actionFeatureLayer != null && message.hasOwnProperty("actionFeatureLayer")) {
                error = $root.SC2APIProtocol.ActionSpatial.verify(message.actionFeatureLayer);
                if (error)
                    return "actionFeatureLayer." + error;
            }
            if (message.actionRender != null && message.hasOwnProperty("actionRender")) {
                error = $root.SC2APIProtocol.ActionSpatial.verify(message.actionRender);
                if (error)
                    return "actionRender." + error;
            }
            if (message.actionUi != null && message.hasOwnProperty("actionUi")) {
                error = $root.SC2APIProtocol.ActionUI.verify(message.actionUi);
                if (error)
                    return "actionUi." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                if (!Array.isArray(message.chat))
                    return "chat: array expected";
                for (var i = 0; i < message.chat.length; ++i) {
                    error = $root.SC2APIProtocol.ActionChat.verify(message.chat[i]);
                    if (error)
                        return "chat." + error;
                }
            }
            return null;
        };
        /**
         * Creates an Action message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Action} Action
         */
        Action.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Action)
                return object;
            var message = new $root.SC2APIProtocol.Action();
            if (object.actionRaw != null) {
                if (typeof object.actionRaw !== "object")
                    throw TypeError(".SC2APIProtocol.Action.actionRaw: object expected");
                message.actionRaw = $root.SC2APIProtocol.ActionRaw.fromObject(object.actionRaw);
            }
            if (object.actionFeatureLayer != null) {
                if (typeof object.actionFeatureLayer !== "object")
                    throw TypeError(".SC2APIProtocol.Action.actionFeatureLayer: object expected");
                message.actionFeatureLayer = $root.SC2APIProtocol.ActionSpatial.fromObject(object.actionFeatureLayer);
            }
            if (object.actionRender != null) {
                if (typeof object.actionRender !== "object")
                    throw TypeError(".SC2APIProtocol.Action.actionRender: object expected");
                message.actionRender = $root.SC2APIProtocol.ActionSpatial.fromObject(object.actionRender);
            }
            if (object.actionUi != null) {
                if (typeof object.actionUi !== "object")
                    throw TypeError(".SC2APIProtocol.Action.actionUi: object expected");
                message.actionUi = $root.SC2APIProtocol.ActionUI.fromObject(object.actionUi);
            }
            if (object.chat) {
                if (!Array.isArray(object.chat))
                    throw TypeError(".SC2APIProtocol.Action.chat: array expected");
                message.chat = [];
                for (var i = 0; i < object.chat.length; ++i) {
                    if (typeof object.chat[i] !== "object")
                        throw TypeError(".SC2APIProtocol.Action.chat: object expected");
                    message.chat[i] = $root.SC2APIProtocol.ActionChat.fromObject(object.chat[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from an Action message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Action
         * @static
         * @param {SC2APIProtocol.Action} message Action
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Action.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chat = [];
            if (options.defaults) {
                object.actionRaw = null;
                object.actionFeatureLayer = null;
                object.actionRender = null;
                object.actionUi = null;
            }
            if (message.actionRaw != null && message.hasOwnProperty("actionRaw"))
                object.actionRaw = $root.SC2APIProtocol.ActionRaw.toObject(message.actionRaw, options);
            if (message.actionFeatureLayer != null && message.hasOwnProperty("actionFeatureLayer"))
                object.actionFeatureLayer = $root.SC2APIProtocol.ActionSpatial.toObject(message.actionFeatureLayer, options);
            if (message.actionRender != null && message.hasOwnProperty("actionRender"))
                object.actionRender = $root.SC2APIProtocol.ActionSpatial.toObject(message.actionRender, options);
            if (message.actionUi != null && message.hasOwnProperty("actionUi"))
                object.actionUi = $root.SC2APIProtocol.ActionUI.toObject(message.actionUi, options);
            if (message.chat && message.chat.length) {
                object.chat = [];
                for (var j = 0; j < message.chat.length; ++j)
                    object.chat[j] = $root.SC2APIProtocol.ActionChat.toObject(message.chat[j], options);
            }
            return object;
        };
        /**
         * Converts this Action to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Action
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Action.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Action;
    })();
    SC2APIProtocol.ActionChat = (function () {
        /**
         * Properties of an ActionChat.
         * @memberof SC2APIProtocol
         * @interface IActionChat
         * @property {SC2APIProtocol.ActionChat.Channel} [channel] ActionChat channel
         * @property {string} [message] ActionChat message
         */
        /**
         * Constructs a new ActionChat.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionChat.
         * @constructor
         * @param {SC2APIProtocol.IActionChat=} [properties] Properties to set
         */
        function ActionChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionChat channel.
         * @member {SC2APIProtocol.ActionChat.Channel}channel
         * @memberof SC2APIProtocol.ActionChat
         * @instance
         */
        ActionChat.prototype.channel = 1;
        /**
         * ActionChat message.
         * @member {string}message
         * @memberof SC2APIProtocol.ActionChat
         * @instance
         */
        ActionChat.prototype.message = "";
        /**
         * Creates a new ActionChat instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {SC2APIProtocol.IActionChat=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionChat} ActionChat instance
         */
        ActionChat.create = function create(properties) {
            return new ActionChat(properties);
        };
        /**
         * Encodes the specified ActionChat message. Does not implicitly {@link SC2APIProtocol.ActionChat.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {SC2APIProtocol.IActionChat} message ActionChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && message.hasOwnProperty("channel"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.channel);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.message);
            return writer;
        };
        /**
         * Encodes the specified ActionChat message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {SC2APIProtocol.IActionChat} message ActionChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionChat message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionChat} ActionChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionChat} ActionChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionChat message.
         * @function verify
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                switch (message.channel) {
                    default:
                        return "channel: enum value expected";
                    case 1:
                    case 2:
                        break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
        /**
         * Creates an ActionChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionChat} ActionChat
         */
        ActionChat.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionChat)
                return object;
            var message = new $root.SC2APIProtocol.ActionChat();
            switch (object.channel) {
                case "Broadcast":
                case 1:
                    message.channel = 1;
                    break;
                case "Team":
                case 2:
                    message.channel = 2;
                    break;
            }
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
        /**
         * Creates a plain object from an ActionChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionChat
         * @static
         * @param {SC2APIProtocol.ActionChat} message ActionChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channel = options.enums === String ? "Broadcast" : 1;
                object.message = "";
            }
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = options.enums === String ? $root.SC2APIProtocol.ActionChat.Channel[message.channel] : message.channel;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
        /**
         * Converts this ActionChat to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Channel enum.
         * @enum {string}
         * @property {number} Broadcast=1 Broadcast value
         * @property {number} Team=2 Team value
         */
        ActionChat.Channel = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Broadcast"] = 1;
            values[valuesById[2] = "Team"] = 2;
            return values;
        })();
        return ActionChat;
    })();
    SC2APIProtocol.ActionError = (function () {
        /**
         * Properties of an ActionError.
         * @memberof SC2APIProtocol
         * @interface IActionError
         * @property {number|Long} [unitTag] ActionError unitTag
         * @property {number|Long} [abilityId] ActionError abilityId
         * @property {SC2APIProtocol.ActionResult} [result] ActionError result
         */
        /**
         * Constructs a new ActionError.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionError.
         * @constructor
         * @param {SC2APIProtocol.IActionError=} [properties] Properties to set
         */
        function ActionError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionError unitTag.
         * @member {number|Long}unitTag
         * @memberof SC2APIProtocol.ActionError
         * @instance
         */
        ActionError.prototype.unitTag = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * ActionError abilityId.
         * @member {number|Long}abilityId
         * @memberof SC2APIProtocol.ActionError
         * @instance
         */
        ActionError.prototype.abilityId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * ActionError result.
         * @member {SC2APIProtocol.ActionResult}result
         * @memberof SC2APIProtocol.ActionError
         * @instance
         */
        ActionError.prototype.result = 1;
        /**
         * Creates a new ActionError instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {SC2APIProtocol.IActionError=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionError} ActionError instance
         */
        ActionError.create = function create(properties) {
            return new ActionError(properties);
        };
        /**
         * Encodes the specified ActionError message. Does not implicitly {@link SC2APIProtocol.ActionError.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {SC2APIProtocol.IActionError} message ActionError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.unitTag);
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.abilityId);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.result);
            return writer;
        };
        /**
         * Encodes the specified ActionError message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {SC2APIProtocol.IActionError} message ActionError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionError message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionError} ActionError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitTag = reader.uint64();
                        break;
                    case 2:
                        message.abilityId = reader.uint64();
                        break;
                    case 3:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionError} ActionError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionError message.
         * @function verify
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (!$util.isInteger(message.unitTag) && !(message.unitTag && $util.isInteger(message.unitTag.low) && $util.isInteger(message.unitTag.high)))
                    return "unitTag: integer|Long expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId) && !(message.abilityId && $util.isInteger(message.abilityId.low) && $util.isInteger(message.abilityId.high)))
                    return "abilityId: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 86:
                    case 87:
                    case 88:
                    case 89:
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 122:
                    case 123:
                    case 124:
                    case 125:
                    case 126:
                    case 127:
                    case 128:
                    case 129:
                    case 130:
                    case 131:
                    case 132:
                    case 133:
                    case 134:
                    case 135:
                    case 136:
                    case 137:
                    case 138:
                    case 139:
                    case 140:
                    case 141:
                    case 142:
                    case 143:
                    case 144:
                    case 145:
                    case 146:
                    case 147:
                    case 148:
                    case 149:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                    case 164:
                    case 165:
                    case 166:
                    case 167:
                    case 168:
                    case 169:
                    case 170:
                    case 171:
                    case 172:
                    case 173:
                    case 174:
                    case 175:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 180:
                    case 181:
                    case 182:
                    case 183:
                    case 184:
                    case 185:
                    case 186:
                    case 187:
                    case 188:
                    case 189:
                    case 190:
                    case 191:
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 196:
                    case 197:
                    case 198:
                    case 199:
                    case 200:
                    case 201:
                    case 202:
                    case 203:
                    case 204:
                    case 205:
                    case 206:
                    case 207:
                    case 208:
                    case 209:
                    case 210:
                    case 211:
                    case 212:
                    case 213:
                    case 214:
                        break;
                }
            return null;
        };
        /**
         * Creates an ActionError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionError} ActionError
         */
        ActionError.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionError)
                return object;
            var message = new $root.SC2APIProtocol.ActionError();
            if (object.unitTag != null)
                if ($util.Long)
                    (message.unitTag = $util.Long.fromValue(object.unitTag)).unsigned = true;
                else if (typeof object.unitTag === "string")
                    message.unitTag = parseInt(object.unitTag, 10);
                else if (typeof object.unitTag === "number")
                    message.unitTag = object.unitTag;
                else if (typeof object.unitTag === "object")
                    message.unitTag = new $util.LongBits(object.unitTag.low >>> 0, object.unitTag.high >>> 0).toNumber(true);
            if (object.abilityId != null)
                if ($util.Long)
                    (message.abilityId = $util.Long.fromValue(object.abilityId)).unsigned = true;
                else if (typeof object.abilityId === "string")
                    message.abilityId = parseInt(object.abilityId, 10);
                else if (typeof object.abilityId === "number")
                    message.abilityId = object.abilityId;
                else if (typeof object.abilityId === "object")
                    message.abilityId = new $util.LongBits(object.abilityId.low >>> 0, object.abilityId.high >>> 0).toNumber(true);
            switch (object.result) {
                case "Success":
                case 1:
                    message.result = 1;
                    break;
                case "NotSupported":
                case 2:
                    message.result = 2;
                    break;
                case "Error":
                case 3:
                    message.result = 3;
                    break;
                case "CantQueueThatOrder":
                case 4:
                    message.result = 4;
                    break;
                case "Retry":
                case 5:
                    message.result = 5;
                    break;
                case "Cooldown":
                case 6:
                    message.result = 6;
                    break;
                case "QueueIsFull":
                case 7:
                    message.result = 7;
                    break;
                case "RallyQueueIsFull":
                case 8:
                    message.result = 8;
                    break;
                case "NotEnoughMinerals":
                case 9:
                    message.result = 9;
                    break;
                case "NotEnoughVespene":
                case 10:
                    message.result = 10;
                    break;
                case "NotEnoughTerrazine":
                case 11:
                    message.result = 11;
                    break;
                case "NotEnoughCustom":
                case 12:
                    message.result = 12;
                    break;
                case "NotEnoughFood":
                case 13:
                    message.result = 13;
                    break;
                case "FoodUsageImpossible":
                case 14:
                    message.result = 14;
                    break;
                case "NotEnoughLife":
                case 15:
                    message.result = 15;
                    break;
                case "NotEnoughShields":
                case 16:
                    message.result = 16;
                    break;
                case "NotEnoughEnergy":
                case 17:
                    message.result = 17;
                    break;
                case "LifeSuppressed":
                case 18:
                    message.result = 18;
                    break;
                case "ShieldsSuppressed":
                case 19:
                    message.result = 19;
                    break;
                case "EnergySuppressed":
                case 20:
                    message.result = 20;
                    break;
                case "NotEnoughCharges":
                case 21:
                    message.result = 21;
                    break;
                case "CantAddMoreCharges":
                case 22:
                    message.result = 22;
                    break;
                case "TooMuchMinerals":
                case 23:
                    message.result = 23;
                    break;
                case "TooMuchVespene":
                case 24:
                    message.result = 24;
                    break;
                case "TooMuchTerrazine":
                case 25:
                    message.result = 25;
                    break;
                case "TooMuchCustom":
                case 26:
                    message.result = 26;
                    break;
                case "TooMuchFood":
                case 27:
                    message.result = 27;
                    break;
                case "TooMuchLife":
                case 28:
                    message.result = 28;
                    break;
                case "TooMuchShields":
                case 29:
                    message.result = 29;
                    break;
                case "TooMuchEnergy":
                case 30:
                    message.result = 30;
                    break;
                case "MustTargetUnitWithLife":
                case 31:
                    message.result = 31;
                    break;
                case "MustTargetUnitWithShields":
                case 32:
                    message.result = 32;
                    break;
                case "MustTargetUnitWithEnergy":
                case 33:
                    message.result = 33;
                    break;
                case "CantTrade":
                case 34:
                    message.result = 34;
                    break;
                case "CantSpend":
                case 35:
                    message.result = 35;
                    break;
                case "CantTargetThatUnit":
                case 36:
                    message.result = 36;
                    break;
                case "CouldntAllocateUnit":
                case 37:
                    message.result = 37;
                    break;
                case "UnitCantMove":
                case 38:
                    message.result = 38;
                    break;
                case "TransportIsHoldingPosition":
                case 39:
                    message.result = 39;
                    break;
                case "BuildTechRequirementsNotMet":
                case 40:
                    message.result = 40;
                    break;
                case "CantFindPlacementLocation":
                case 41:
                    message.result = 41;
                    break;
                case "CantBuildOnThat":
                case 42:
                    message.result = 42;
                    break;
                case "CantBuildTooCloseToDropOff":
                case 43:
                    message.result = 43;
                    break;
                case "CantBuildLocationInvalid":
                case 44:
                    message.result = 44;
                    break;
                case "CantSeeBuildLocation":
                case 45:
                    message.result = 45;
                    break;
                case "CantBuildTooCloseToCreepSource":
                case 46:
                    message.result = 46;
                    break;
                case "CantBuildTooCloseToResources":
                case 47:
                    message.result = 47;
                    break;
                case "CantBuildTooFarFromWater":
                case 48:
                    message.result = 48;
                    break;
                case "CantBuildTooFarFromCreepSource":
                case 49:
                    message.result = 49;
                    break;
                case "CantBuildTooFarFromBuildPowerSource":
                case 50:
                    message.result = 50;
                    break;
                case "CantBuildOnDenseTerrain":
                case 51:
                    message.result = 51;
                    break;
                case "CantTrainTooFarFromTrainPowerSource":
                case 52:
                    message.result = 52;
                    break;
                case "CantLandLocationInvalid":
                case 53:
                    message.result = 53;
                    break;
                case "CantSeeLandLocation":
                case 54:
                    message.result = 54;
                    break;
                case "CantLandTooCloseToCreepSource":
                case 55:
                    message.result = 55;
                    break;
                case "CantLandTooCloseToResources":
                case 56:
                    message.result = 56;
                    break;
                case "CantLandTooFarFromWater":
                case 57:
                    message.result = 57;
                    break;
                case "CantLandTooFarFromCreepSource":
                case 58:
                    message.result = 58;
                    break;
                case "CantLandTooFarFromBuildPowerSource":
                case 59:
                    message.result = 59;
                    break;
                case "CantLandTooFarFromTrainPowerSource":
                case 60:
                    message.result = 60;
                    break;
                case "CantLandOnDenseTerrain":
                case 61:
                    message.result = 61;
                    break;
                case "AddOnTooFarFromBuilding":
                case 62:
                    message.result = 62;
                    break;
                case "MustBuildRefineryFirst":
                case 63:
                    message.result = 63;
                    break;
                case "BuildingIsUnderConstruction":
                case 64:
                    message.result = 64;
                    break;
                case "CantFindDropOff":
                case 65:
                    message.result = 65;
                    break;
                case "CantLoadOtherPlayersUnits":
                case 66:
                    message.result = 66;
                    break;
                case "NotEnoughRoomToLoadUnit":
                case 67:
                    message.result = 67;
                    break;
                case "CantUnloadUnitsThere":
                case 68:
                    message.result = 68;
                    break;
                case "CantWarpInUnitsThere":
                case 69:
                    message.result = 69;
                    break;
                case "CantLoadImmobileUnits":
                case 70:
                    message.result = 70;
                    break;
                case "CantRechargeImmobileUnits":
                case 71:
                    message.result = 71;
                    break;
                case "CantRechargeUnderConstructionUnits":
                case 72:
                    message.result = 72;
                    break;
                case "CantLoadThatUnit":
                case 73:
                    message.result = 73;
                    break;
                case "NoCargoToUnload":
                case 74:
                    message.result = 74;
                    break;
                case "LoadAllNoTargetsFound":
                case 75:
                    message.result = 75;
                    break;
                case "NotWhileOccupied":
                case 76:
                    message.result = 76;
                    break;
                case "CantAttackWithoutAmmo":
                case 77:
                    message.result = 77;
                    break;
                case "CantHoldAnyMoreAmmo":
                case 78:
                    message.result = 78;
                    break;
                case "TechRequirementsNotMet":
                case 79:
                    message.result = 79;
                    break;
                case "MustLockdownUnitFirst":
                case 80:
                    message.result = 80;
                    break;
                case "MustTargetUnit":
                case 81:
                    message.result = 81;
                    break;
                case "MustTargetInventory":
                case 82:
                    message.result = 82;
                    break;
                case "MustTargetVisibleUnit":
                case 83:
                    message.result = 83;
                    break;
                case "MustTargetVisibleLocation":
                case 84:
                    message.result = 84;
                    break;
                case "MustTargetWalkableLocation":
                case 85:
                    message.result = 85;
                    break;
                case "MustTargetPawnableUnit":
                case 86:
                    message.result = 86;
                    break;
                case "YouCantControlThatUnit":
                case 87:
                    message.result = 87;
                    break;
                case "YouCantIssueCommandsToThatUnit":
                case 88:
                    message.result = 88;
                    break;
                case "MustTargetResources":
                case 89:
                    message.result = 89;
                    break;
                case "RequiresHealTarget":
                case 90:
                    message.result = 90;
                    break;
                case "RequiresRepairTarget":
                case 91:
                    message.result = 91;
                    break;
                case "NoItemsToDrop":
                case 92:
                    message.result = 92;
                    break;
                case "CantHoldAnyMoreItems":
                case 93:
                    message.result = 93;
                    break;
                case "CantHoldThat":
                case 94:
                    message.result = 94;
                    break;
                case "TargetHasNoInventory":
                case 95:
                    message.result = 95;
                    break;
                case "CantDropThisItem":
                case 96:
                    message.result = 96;
                    break;
                case "CantMoveThisItem":
                case 97:
                    message.result = 97;
                    break;
                case "CantPawnThisUnit":
                case 98:
                    message.result = 98;
                    break;
                case "MustTargetCaster":
                case 99:
                    message.result = 99;
                    break;
                case "CantTargetCaster":
                case 100:
                    message.result = 100;
                    break;
                case "MustTargetOuter":
                case 101:
                    message.result = 101;
                    break;
                case "CantTargetOuter":
                case 102:
                    message.result = 102;
                    break;
                case "MustTargetYourOwnUnits":
                case 103:
                    message.result = 103;
                    break;
                case "CantTargetYourOwnUnits":
                case 104:
                    message.result = 104;
                    break;
                case "MustTargetFriendlyUnits":
                case 105:
                    message.result = 105;
                    break;
                case "CantTargetFriendlyUnits":
                case 106:
                    message.result = 106;
                    break;
                case "MustTargetNeutralUnits":
                case 107:
                    message.result = 107;
                    break;
                case "CantTargetNeutralUnits":
                case 108:
                    message.result = 108;
                    break;
                case "MustTargetEnemyUnits":
                case 109:
                    message.result = 109;
                    break;
                case "CantTargetEnemyUnits":
                case 110:
                    message.result = 110;
                    break;
                case "MustTargetAirUnits":
                case 111:
                    message.result = 111;
                    break;
                case "CantTargetAirUnits":
                case 112:
                    message.result = 112;
                    break;
                case "MustTargetGroundUnits":
                case 113:
                    message.result = 113;
                    break;
                case "CantTargetGroundUnits":
                case 114:
                    message.result = 114;
                    break;
                case "MustTargetStructures":
                case 115:
                    message.result = 115;
                    break;
                case "CantTargetStructures":
                case 116:
                    message.result = 116;
                    break;
                case "MustTargetLightUnits":
                case 117:
                    message.result = 117;
                    break;
                case "CantTargetLightUnits":
                case 118:
                    message.result = 118;
                    break;
                case "MustTargetArmoredUnits":
                case 119:
                    message.result = 119;
                    break;
                case "CantTargetArmoredUnits":
                case 120:
                    message.result = 120;
                    break;
                case "MustTargetBiologicalUnits":
                case 121:
                    message.result = 121;
                    break;
                case "CantTargetBiologicalUnits":
                case 122:
                    message.result = 122;
                    break;
                case "MustTargetHeroicUnits":
                case 123:
                    message.result = 123;
                    break;
                case "CantTargetHeroicUnits":
                case 124:
                    message.result = 124;
                    break;
                case "MustTargetRoboticUnits":
                case 125:
                    message.result = 125;
                    break;
                case "CantTargetRoboticUnits":
                case 126:
                    message.result = 126;
                    break;
                case "MustTargetMechanicalUnits":
                case 127:
                    message.result = 127;
                    break;
                case "CantTargetMechanicalUnits":
                case 128:
                    message.result = 128;
                    break;
                case "MustTargetPsionicUnits":
                case 129:
                    message.result = 129;
                    break;
                case "CantTargetPsionicUnits":
                case 130:
                    message.result = 130;
                    break;
                case "MustTargetMassiveUnits":
                case 131:
                    message.result = 131;
                    break;
                case "CantTargetMassiveUnits":
                case 132:
                    message.result = 132;
                    break;
                case "MustTargetMissile":
                case 133:
                    message.result = 133;
                    break;
                case "CantTargetMissile":
                case 134:
                    message.result = 134;
                    break;
                case "MustTargetWorkerUnits":
                case 135:
                    message.result = 135;
                    break;
                case "CantTargetWorkerUnits":
                case 136:
                    message.result = 136;
                    break;
                case "MustTargetEnergyCapableUnits":
                case 137:
                    message.result = 137;
                    break;
                case "CantTargetEnergyCapableUnits":
                case 138:
                    message.result = 138;
                    break;
                case "MustTargetShieldCapableUnits":
                case 139:
                    message.result = 139;
                    break;
                case "CantTargetShieldCapableUnits":
                case 140:
                    message.result = 140;
                    break;
                case "MustTargetFlyers":
                case 141:
                    message.result = 141;
                    break;
                case "CantTargetFlyers":
                case 142:
                    message.result = 142;
                    break;
                case "MustTargetBuriedUnits":
                case 143:
                    message.result = 143;
                    break;
                case "CantTargetBuriedUnits":
                case 144:
                    message.result = 144;
                    break;
                case "MustTargetCloakedUnits":
                case 145:
                    message.result = 145;
                    break;
                case "CantTargetCloakedUnits":
                case 146:
                    message.result = 146;
                    break;
                case "MustTargetUnitsInAStasisField":
                case 147:
                    message.result = 147;
                    break;
                case "CantTargetUnitsInAStasisField":
                case 148:
                    message.result = 148;
                    break;
                case "MustTargetUnderConstructionUnits":
                case 149:
                    message.result = 149;
                    break;
                case "CantTargetUnderConstructionUnits":
                case 150:
                    message.result = 150;
                    break;
                case "MustTargetDeadUnits":
                case 151:
                    message.result = 151;
                    break;
                case "CantTargetDeadUnits":
                case 152:
                    message.result = 152;
                    break;
                case "MustTargetRevivableUnits":
                case 153:
                    message.result = 153;
                    break;
                case "CantTargetRevivableUnits":
                case 154:
                    message.result = 154;
                    break;
                case "MustTargetHiddenUnits":
                case 155:
                    message.result = 155;
                    break;
                case "CantTargetHiddenUnits":
                case 156:
                    message.result = 156;
                    break;
                case "CantRechargeOtherPlayersUnits":
                case 157:
                    message.result = 157;
                    break;
                case "MustTargetHallucinations":
                case 158:
                    message.result = 158;
                    break;
                case "CantTargetHallucinations":
                case 159:
                    message.result = 159;
                    break;
                case "MustTargetInvulnerableUnits":
                case 160:
                    message.result = 160;
                    break;
                case "CantTargetInvulnerableUnits":
                case 161:
                    message.result = 161;
                    break;
                case "MustTargetDetectedUnits":
                case 162:
                    message.result = 162;
                    break;
                case "CantTargetDetectedUnits":
                case 163:
                    message.result = 163;
                    break;
                case "CantTargetUnitWithEnergy":
                case 164:
                    message.result = 164;
                    break;
                case "CantTargetUnitWithShields":
                case 165:
                    message.result = 165;
                    break;
                case "MustTargetUncommandableUnits":
                case 166:
                    message.result = 166;
                    break;
                case "CantTargetUncommandableUnits":
                case 167:
                    message.result = 167;
                    break;
                case "MustTargetPreventDefeatUnits":
                case 168:
                    message.result = 168;
                    break;
                case "CantTargetPreventDefeatUnits":
                case 169:
                    message.result = 169;
                    break;
                case "MustTargetPreventRevealUnits":
                case 170:
                    message.result = 170;
                    break;
                case "CantTargetPreventRevealUnits":
                case 171:
                    message.result = 171;
                    break;
                case "MustTargetPassiveUnits":
                case 172:
                    message.result = 172;
                    break;
                case "CantTargetPassiveUnits":
                case 173:
                    message.result = 173;
                    break;
                case "MustTargetStunnedUnits":
                case 174:
                    message.result = 174;
                    break;
                case "CantTargetStunnedUnits":
                case 175:
                    message.result = 175;
                    break;
                case "MustTargetSummonedUnits":
                case 176:
                    message.result = 176;
                    break;
                case "CantTargetSummonedUnits":
                case 177:
                    message.result = 177;
                    break;
                case "MustTargetUser1":
                case 178:
                    message.result = 178;
                    break;
                case "CantTargetUser1":
                case 179:
                    message.result = 179;
                    break;
                case "MustTargetUnstoppableUnits":
                case 180:
                    message.result = 180;
                    break;
                case "CantTargetUnstoppableUnits":
                case 181:
                    message.result = 181;
                    break;
                case "MustTargetResistantUnits":
                case 182:
                    message.result = 182;
                    break;
                case "CantTargetResistantUnits":
                case 183:
                    message.result = 183;
                    break;
                case "MustTargetDazedUnits":
                case 184:
                    message.result = 184;
                    break;
                case "CantTargetDazedUnits":
                case 185:
                    message.result = 185;
                    break;
                case "CantLockdown":
                case 186:
                    message.result = 186;
                    break;
                case "CantMindControl":
                case 187:
                    message.result = 187;
                    break;
                case "MustTargetDestructibles":
                case 188:
                    message.result = 188;
                    break;
                case "CantTargetDestructibles":
                case 189:
                    message.result = 189;
                    break;
                case "MustTargetItems":
                case 190:
                    message.result = 190;
                    break;
                case "CantTargetItems":
                case 191:
                    message.result = 191;
                    break;
                case "NoCalldownAvailable":
                case 192:
                    message.result = 192;
                    break;
                case "WaypointListFull":
                case 193:
                    message.result = 193;
                    break;
                case "MustTargetRace":
                case 194:
                    message.result = 194;
                    break;
                case "CantTargetRace":
                case 195:
                    message.result = 195;
                    break;
                case "MustTargetSimilarUnits":
                case 196:
                    message.result = 196;
                    break;
                case "CantTargetSimilarUnits":
                case 197:
                    message.result = 197;
                    break;
                case "CantFindEnoughTargets":
                case 198:
                    message.result = 198;
                    break;
                case "AlreadySpawningLarva":
                case 199:
                    message.result = 199;
                    break;
                case "CantTargetExhaustedResources":
                case 200:
                    message.result = 200;
                    break;
                case "CantUseMinimap":
                case 201:
                    message.result = 201;
                    break;
                case "CantUseInfoPanel":
                case 202:
                    message.result = 202;
                    break;
                case "OrderQueueIsFull":
                case 203:
                    message.result = 203;
                    break;
                case "CantHarvestThatResource":
                case 204:
                    message.result = 204;
                    break;
                case "HarvestersNotRequired":
                case 205:
                    message.result = 205;
                    break;
                case "AlreadyTargeted":
                case 206:
                    message.result = 206;
                    break;
                case "CantAttackWeaponsDisabled":
                case 207:
                    message.result = 207;
                    break;
                case "CouldntReachTarget":
                case 208:
                    message.result = 208;
                    break;
                case "TargetIsOutOfRange":
                case 209:
                    message.result = 209;
                    break;
                case "TargetIsTooClose":
                case 210:
                    message.result = 210;
                    break;
                case "TargetIsOutOfArc":
                case 211:
                    message.result = 211;
                    break;
                case "CantFindTeleportLocation":
                case 212:
                    message.result = 212;
                    break;
                case "InvalidItemClass":
                case 213:
                    message.result = 213;
                    break;
                case "CantFindCancelOrder":
                case 214:
                    message.result = 214;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionError
         * @static
         * @param {SC2APIProtocol.ActionError} message ActionError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.unitTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.unitTag = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.abilityId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.abilityId = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "Success" : 1;
            }
            if (message.unitTag != null && message.hasOwnProperty("unitTag"))
                if (typeof message.unitTag === "number")
                    object.unitTag = options.longs === String ? String(message.unitTag) : message.unitTag;
                else
                    object.unitTag = options.longs === String ? $util.Long.prototype.toString.call(message.unitTag) : options.longs === Number ? new $util.LongBits(message.unitTag.low >>> 0, message.unitTag.high >>> 0).toNumber(true) : message.unitTag;
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (typeof message.abilityId === "number")
                    object.abilityId = options.longs === String ? String(message.abilityId) : message.abilityId;
                else
                    object.abilityId = options.longs === String ? $util.Long.prototype.toString.call(message.abilityId) : options.longs === Number ? new $util.LongBits(message.abilityId.low >>> 0, message.abilityId.high >>> 0).toNumber(true) : message.abilityId;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.SC2APIProtocol.ActionResult[message.result] : message.result;
            return object;
        };
        /**
         * Converts this ActionError to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionError;
    })();
    /**
     * Alert enum.
     * @enum {string}
     * @property {number} NuclearLaunchDetected=1 NuclearLaunchDetected value
     * @property {number} NydusWormDetected=2 NydusWormDetected value
     */
    SC2APIProtocol.Alert = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "NuclearLaunchDetected"] = 1;
        values[valuesById[2] = "NydusWormDetected"] = 2;
        return values;
    })();
    /**
     * Result enum.
     * @enum {string}
     * @property {number} Victory=1 Victory value
     * @property {number} Defeat=2 Defeat value
     * @property {number} Tie=3 Tie value
     * @property {number} Undecided=4 Undecided value
     */
    SC2APIProtocol.Result = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Victory"] = 1;
        values[valuesById[2] = "Defeat"] = 2;
        values[valuesById[3] = "Tie"] = 3;
        values[valuesById[4] = "Undecided"] = 4;
        return values;
    })();
    SC2APIProtocol.PlayerResult = (function () {
        /**
         * Properties of a PlayerResult.
         * @memberof SC2APIProtocol
         * @interface IPlayerResult
         * @property {number} [playerId] PlayerResult playerId
         * @property {SC2APIProtocol.Result} [result] PlayerResult result
         */
        /**
         * Constructs a new PlayerResult.
         * @memberof SC2APIProtocol
         * @classdesc Represents a PlayerResult.
         * @constructor
         * @param {SC2APIProtocol.IPlayerResult=} [properties] Properties to set
         */
        function PlayerResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerResult playerId.
         * @member {number}playerId
         * @memberof SC2APIProtocol.PlayerResult
         * @instance
         */
        PlayerResult.prototype.playerId = 0;
        /**
         * PlayerResult result.
         * @member {SC2APIProtocol.Result}result
         * @memberof SC2APIProtocol.PlayerResult
         * @instance
         */
        PlayerResult.prototype.result = 1;
        /**
         * Creates a new PlayerResult instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {SC2APIProtocol.IPlayerResult=} [properties] Properties to set
         * @returns {SC2APIProtocol.PlayerResult} PlayerResult instance
         */
        PlayerResult.create = function create(properties) {
            return new PlayerResult(properties);
        };
        /**
         * Encodes the specified PlayerResult message. Does not implicitly {@link SC2APIProtocol.PlayerResult.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {SC2APIProtocol.IPlayerResult} message PlayerResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.playerId);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.result);
            return writer;
        };
        /**
         * Encodes the specified PlayerResult message, length delimited. Does not implicitly {@link SC2APIProtocol.PlayerResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {SC2APIProtocol.IPlayerResult} message PlayerResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a PlayerResult message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.PlayerResult} PlayerResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.PlayerResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a PlayerResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.PlayerResult} PlayerResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a PlayerResult message.
         * @function verify
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                if (!$util.isInteger(message.playerId))
                    return "playerId: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            return null;
        };
        /**
         * Creates a PlayerResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.PlayerResult} PlayerResult
         */
        PlayerResult.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.PlayerResult)
                return object;
            var message = new $root.SC2APIProtocol.PlayerResult();
            if (object.playerId != null)
                message.playerId = object.playerId >>> 0;
            switch (object.result) {
                case "Victory":
                case 1:
                    message.result = 1;
                    break;
                case "Defeat":
                case 2:
                    message.result = 2;
                    break;
                case "Tie":
                case 3:
                    message.result = 3;
                    break;
                case "Undecided":
                case 4:
                    message.result = 4;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from a PlayerResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.PlayerResult
         * @static
         * @param {SC2APIProtocol.PlayerResult} message PlayerResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerId = 0;
                object.result = options.enums === String ? "Victory" : 1;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = message.playerId;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.SC2APIProtocol.Result[message.result] : message.result;
            return object;
        };
        /**
         * Converts this PlayerResult to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.PlayerResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PlayerResult;
    })();
    SC2APIProtocol.Score = (function () {
        /**
         * Properties of a Score.
         * @memberof SC2APIProtocol
         * @interface IScore
         * @property {SC2APIProtocol.Score.ScoreType} [scoreType] Score scoreType
         * @property {number} [score] Score score
         * @property {SC2APIProtocol.IScoreDetails} [scoreDetails] Score scoreDetails
         */
        /**
         * Constructs a new Score.
         * @memberof SC2APIProtocol
         * @classdesc Represents a Score.
         * @constructor
         * @param {SC2APIProtocol.IScore=} [properties] Properties to set
         */
        function Score(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Score scoreType.
         * @member {SC2APIProtocol.Score.ScoreType}scoreType
         * @memberof SC2APIProtocol.Score
         * @instance
         */
        Score.prototype.scoreType = 1;
        /**
         * Score score.
         * @member {number}score
         * @memberof SC2APIProtocol.Score
         * @instance
         */
        Score.prototype.score = 0;
        /**
         * Score scoreDetails.
         * @member {(SC2APIProtocol.IScoreDetails|null|undefined)}scoreDetails
         * @memberof SC2APIProtocol.Score
         * @instance
         */
        Score.prototype.scoreDetails = null;
        /**
         * Creates a new Score instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {SC2APIProtocol.IScore=} [properties] Properties to set
         * @returns {SC2APIProtocol.Score} Score instance
         */
        Score.create = function create(properties) {
            return new Score(properties);
        };
        /**
         * Encodes the specified Score message. Does not implicitly {@link SC2APIProtocol.Score.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {SC2APIProtocol.IScore} message Score message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Score.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.scoreType != null && message.hasOwnProperty("scoreType"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.scoreType);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.score);
            if (message.scoreDetails != null && message.hasOwnProperty("scoreDetails"))
                $root.SC2APIProtocol.ScoreDetails.encode(message.scoreDetails, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified Score message, length delimited. Does not implicitly {@link SC2APIProtocol.Score.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {SC2APIProtocol.IScore} message Score message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Score.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a Score message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.Score} Score
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Score.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.Score();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 6:
                        message.scoreType = reader.int32();
                        break;
                    case 7:
                        message.score = reader.int32();
                        break;
                    case 8:
                        message.scoreDetails = $root.SC2APIProtocol.ScoreDetails.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a Score message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.Score} Score
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Score.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a Score message.
         * @function verify
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Score.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.scoreType != null && message.hasOwnProperty("scoreType"))
                switch (message.scoreType) {
                    default:
                        return "scoreType: enum value expected";
                    case 1:
                    case 2:
                        break;
                }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.scoreDetails != null && message.hasOwnProperty("scoreDetails")) {
                var error = $root.SC2APIProtocol.ScoreDetails.verify(message.scoreDetails);
                if (error)
                    return "scoreDetails." + error;
            }
            return null;
        };
        /**
         * Creates a Score message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.Score} Score
         */
        Score.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.Score)
                return object;
            var message = new $root.SC2APIProtocol.Score();
            switch (object.scoreType) {
                case "Curriculum":
                case 1:
                    message.scoreType = 1;
                    break;
                case "Melee":
                case 2:
                    message.scoreType = 2;
                    break;
            }
            if (object.score != null)
                message.score = object.score | 0;
            if (object.scoreDetails != null) {
                if (typeof object.scoreDetails !== "object")
                    throw TypeError(".SC2APIProtocol.Score.scoreDetails: object expected");
                message.scoreDetails = $root.SC2APIProtocol.ScoreDetails.fromObject(object.scoreDetails);
            }
            return message;
        };
        /**
         * Creates a plain object from a Score message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.Score
         * @static
         * @param {SC2APIProtocol.Score} message Score
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Score.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.scoreType = options.enums === String ? "Curriculum" : 1;
                object.score = 0;
                object.scoreDetails = null;
            }
            if (message.scoreType != null && message.hasOwnProperty("scoreType"))
                object.scoreType = options.enums === String ? $root.SC2APIProtocol.Score.ScoreType[message.scoreType] : message.scoreType;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.scoreDetails != null && message.hasOwnProperty("scoreDetails"))
                object.scoreDetails = $root.SC2APIProtocol.ScoreDetails.toObject(message.scoreDetails, options);
            return object;
        };
        /**
         * Converts this Score to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.Score
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Score.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * ScoreType enum.
         * @enum {string}
         * @property {number} Curriculum=1 Curriculum value
         * @property {number} Melee=2 Melee value
         */
        Score.ScoreType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Curriculum"] = 1;
            values[valuesById[2] = "Melee"] = 2;
            return values;
        })();
        return Score;
    })();
    SC2APIProtocol.CategoryScoreDetails = (function () {
        /**
         * Properties of a CategoryScoreDetails.
         * @memberof SC2APIProtocol
         * @interface ICategoryScoreDetails
         * @property {number} [none] CategoryScoreDetails none
         * @property {number} [army] CategoryScoreDetails army
         * @property {number} [economy] CategoryScoreDetails economy
         * @property {number} [technology] CategoryScoreDetails technology
         * @property {number} [upgrade] CategoryScoreDetails upgrade
         */
        /**
         * Constructs a new CategoryScoreDetails.
         * @memberof SC2APIProtocol
         * @classdesc Represents a CategoryScoreDetails.
         * @constructor
         * @param {SC2APIProtocol.ICategoryScoreDetails=} [properties] Properties to set
         */
        function CategoryScoreDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CategoryScoreDetails none.
         * @member {number}none
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         */
        CategoryScoreDetails.prototype.none = 0;
        /**
         * CategoryScoreDetails army.
         * @member {number}army
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         */
        CategoryScoreDetails.prototype.army = 0;
        /**
         * CategoryScoreDetails economy.
         * @member {number}economy
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         */
        CategoryScoreDetails.prototype.economy = 0;
        /**
         * CategoryScoreDetails technology.
         * @member {number}technology
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         */
        CategoryScoreDetails.prototype.technology = 0;
        /**
         * CategoryScoreDetails upgrade.
         * @member {number}upgrade
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         */
        CategoryScoreDetails.prototype.upgrade = 0;
        /**
         * Creates a new CategoryScoreDetails instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {SC2APIProtocol.ICategoryScoreDetails=} [properties] Properties to set
         * @returns {SC2APIProtocol.CategoryScoreDetails} CategoryScoreDetails instance
         */
        CategoryScoreDetails.create = function create(properties) {
            return new CategoryScoreDetails(properties);
        };
        /**
         * Encodes the specified CategoryScoreDetails message. Does not implicitly {@link SC2APIProtocol.CategoryScoreDetails.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {SC2APIProtocol.ICategoryScoreDetails} message CategoryScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CategoryScoreDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.none != null && message.hasOwnProperty("none"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.none);
            if (message.army != null && message.hasOwnProperty("army"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.army);
            if (message.economy != null && message.hasOwnProperty("economy"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.economy);
            if (message.technology != null && message.hasOwnProperty("technology"))
                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.technology);
            if (message.upgrade != null && message.hasOwnProperty("upgrade"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.upgrade);
            return writer;
        };
        /**
         * Encodes the specified CategoryScoreDetails message, length delimited. Does not implicitly {@link SC2APIProtocol.CategoryScoreDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {SC2APIProtocol.ICategoryScoreDetails} message CategoryScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CategoryScoreDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a CategoryScoreDetails message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.CategoryScoreDetails} CategoryScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CategoryScoreDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.CategoryScoreDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.none = reader.float();
                        break;
                    case 2:
                        message.army = reader.float();
                        break;
                    case 3:
                        message.economy = reader.float();
                        break;
                    case 4:
                        message.technology = reader.float();
                        break;
                    case 5:
                        message.upgrade = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a CategoryScoreDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.CategoryScoreDetails} CategoryScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CategoryScoreDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a CategoryScoreDetails message.
         * @function verify
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CategoryScoreDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.none != null && message.hasOwnProperty("none"))
                if (typeof message.none !== "number")
                    return "none: number expected";
            if (message.army != null && message.hasOwnProperty("army"))
                if (typeof message.army !== "number")
                    return "army: number expected";
            if (message.economy != null && message.hasOwnProperty("economy"))
                if (typeof message.economy !== "number")
                    return "economy: number expected";
            if (message.technology != null && message.hasOwnProperty("technology"))
                if (typeof message.technology !== "number")
                    return "technology: number expected";
            if (message.upgrade != null && message.hasOwnProperty("upgrade"))
                if (typeof message.upgrade !== "number")
                    return "upgrade: number expected";
            return null;
        };
        /**
         * Creates a CategoryScoreDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.CategoryScoreDetails} CategoryScoreDetails
         */
        CategoryScoreDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.CategoryScoreDetails)
                return object;
            var message = new $root.SC2APIProtocol.CategoryScoreDetails();
            if (object.none != null)
                message.none = Number(object.none);
            if (object.army != null)
                message.army = Number(object.army);
            if (object.economy != null)
                message.economy = Number(object.economy);
            if (object.technology != null)
                message.technology = Number(object.technology);
            if (object.upgrade != null)
                message.upgrade = Number(object.upgrade);
            return message;
        };
        /**
         * Creates a plain object from a CategoryScoreDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @static
         * @param {SC2APIProtocol.CategoryScoreDetails} message CategoryScoreDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CategoryScoreDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.none = 0;
                object.army = 0;
                object.economy = 0;
                object.technology = 0;
                object.upgrade = 0;
            }
            if (message.none != null && message.hasOwnProperty("none"))
                object.none = options.json && !isFinite(message.none) ? String(message.none) : message.none;
            if (message.army != null && message.hasOwnProperty("army"))
                object.army = options.json && !isFinite(message.army) ? String(message.army) : message.army;
            if (message.economy != null && message.hasOwnProperty("economy"))
                object.economy = options.json && !isFinite(message.economy) ? String(message.economy) : message.economy;
            if (message.technology != null && message.hasOwnProperty("technology"))
                object.technology = options.json && !isFinite(message.technology) ? String(message.technology) : message.technology;
            if (message.upgrade != null && message.hasOwnProperty("upgrade"))
                object.upgrade = options.json && !isFinite(message.upgrade) ? String(message.upgrade) : message.upgrade;
            return object;
        };
        /**
         * Converts this CategoryScoreDetails to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.CategoryScoreDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CategoryScoreDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CategoryScoreDetails;
    })();
    SC2APIProtocol.VitalScoreDetails = (function () {
        /**
         * Properties of a VitalScoreDetails.
         * @memberof SC2APIProtocol
         * @interface IVitalScoreDetails
         * @property {number} [life] VitalScoreDetails life
         * @property {number} [shields] VitalScoreDetails shields
         * @property {number} [energy] VitalScoreDetails energy
         */
        /**
         * Constructs a new VitalScoreDetails.
         * @memberof SC2APIProtocol
         * @classdesc Represents a VitalScoreDetails.
         * @constructor
         * @param {SC2APIProtocol.IVitalScoreDetails=} [properties] Properties to set
         */
        function VitalScoreDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * VitalScoreDetails life.
         * @member {number}life
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @instance
         */
        VitalScoreDetails.prototype.life = 0;
        /**
         * VitalScoreDetails shields.
         * @member {number}shields
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @instance
         */
        VitalScoreDetails.prototype.shields = 0;
        /**
         * VitalScoreDetails energy.
         * @member {number}energy
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @instance
         */
        VitalScoreDetails.prototype.energy = 0;
        /**
         * Creates a new VitalScoreDetails instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {SC2APIProtocol.IVitalScoreDetails=} [properties] Properties to set
         * @returns {SC2APIProtocol.VitalScoreDetails} VitalScoreDetails instance
         */
        VitalScoreDetails.create = function create(properties) {
            return new VitalScoreDetails(properties);
        };
        /**
         * Encodes the specified VitalScoreDetails message. Does not implicitly {@link SC2APIProtocol.VitalScoreDetails.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {SC2APIProtocol.IVitalScoreDetails} message VitalScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VitalScoreDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.life != null && message.hasOwnProperty("life"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.life);
            if (message.shields != null && message.hasOwnProperty("shields"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.shields);
            if (message.energy != null && message.hasOwnProperty("energy"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.energy);
            return writer;
        };
        /**
         * Encodes the specified VitalScoreDetails message, length delimited. Does not implicitly {@link SC2APIProtocol.VitalScoreDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {SC2APIProtocol.IVitalScoreDetails} message VitalScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VitalScoreDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a VitalScoreDetails message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.VitalScoreDetails} VitalScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VitalScoreDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.VitalScoreDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.life = reader.float();
                        break;
                    case 2:
                        message.shields = reader.float();
                        break;
                    case 3:
                        message.energy = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a VitalScoreDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.VitalScoreDetails} VitalScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VitalScoreDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a VitalScoreDetails message.
         * @function verify
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VitalScoreDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.life != null && message.hasOwnProperty("life"))
                if (typeof message.life !== "number")
                    return "life: number expected";
            if (message.shields != null && message.hasOwnProperty("shields"))
                if (typeof message.shields !== "number")
                    return "shields: number expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (typeof message.energy !== "number")
                    return "energy: number expected";
            return null;
        };
        /**
         * Creates a VitalScoreDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.VitalScoreDetails} VitalScoreDetails
         */
        VitalScoreDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.VitalScoreDetails)
                return object;
            var message = new $root.SC2APIProtocol.VitalScoreDetails();
            if (object.life != null)
                message.life = Number(object.life);
            if (object.shields != null)
                message.shields = Number(object.shields);
            if (object.energy != null)
                message.energy = Number(object.energy);
            return message;
        };
        /**
         * Creates a plain object from a VitalScoreDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @static
         * @param {SC2APIProtocol.VitalScoreDetails} message VitalScoreDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VitalScoreDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.life = 0;
                object.shields = 0;
                object.energy = 0;
            }
            if (message.life != null && message.hasOwnProperty("life"))
                object.life = options.json && !isFinite(message.life) ? String(message.life) : message.life;
            if (message.shields != null && message.hasOwnProperty("shields"))
                object.shields = options.json && !isFinite(message.shields) ? String(message.shields) : message.shields;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = options.json && !isFinite(message.energy) ? String(message.energy) : message.energy;
            return object;
        };
        /**
         * Converts this VitalScoreDetails to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.VitalScoreDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VitalScoreDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return VitalScoreDetails;
    })();
    SC2APIProtocol.ScoreDetails = (function () {
        /**
         * Properties of a ScoreDetails.
         * @memberof SC2APIProtocol
         * @interface IScoreDetails
         * @property {number} [idleProductionTime] ScoreDetails idleProductionTime
         * @property {number} [idleWorkerTime] ScoreDetails idleWorkerTime
         * @property {number} [totalValueUnits] ScoreDetails totalValueUnits
         * @property {number} [totalValueStructures] ScoreDetails totalValueStructures
         * @property {number} [killedValueUnits] ScoreDetails killedValueUnits
         * @property {number} [killedValueStructures] ScoreDetails killedValueStructures
         * @property {number} [collectedMinerals] ScoreDetails collectedMinerals
         * @property {number} [collectedVespene] ScoreDetails collectedVespene
         * @property {number} [collectionRateMinerals] ScoreDetails collectionRateMinerals
         * @property {number} [collectionRateVespene] ScoreDetails collectionRateVespene
         * @property {number} [spentMinerals] ScoreDetails spentMinerals
         * @property {number} [spentVespene] ScoreDetails spentVespene
         * @property {SC2APIProtocol.ICategoryScoreDetails} [foodUsed] ScoreDetails foodUsed
         * @property {SC2APIProtocol.ICategoryScoreDetails} [killedMinerals] ScoreDetails killedMinerals
         * @property {SC2APIProtocol.ICategoryScoreDetails} [killedVespene] ScoreDetails killedVespene
         * @property {SC2APIProtocol.ICategoryScoreDetails} [lostMinerals] ScoreDetails lostMinerals
         * @property {SC2APIProtocol.ICategoryScoreDetails} [lostVespene] ScoreDetails lostVespene
         * @property {SC2APIProtocol.ICategoryScoreDetails} [friendlyFireMinerals] ScoreDetails friendlyFireMinerals
         * @property {SC2APIProtocol.ICategoryScoreDetails} [friendlyFireVespene] ScoreDetails friendlyFireVespene
         * @property {SC2APIProtocol.ICategoryScoreDetails} [usedMinerals] ScoreDetails usedMinerals
         * @property {SC2APIProtocol.ICategoryScoreDetails} [usedVespene] ScoreDetails usedVespene
         * @property {SC2APIProtocol.ICategoryScoreDetails} [totalUsedMinerals] ScoreDetails totalUsedMinerals
         * @property {SC2APIProtocol.ICategoryScoreDetails} [totalUsedVespene] ScoreDetails totalUsedVespene
         * @property {SC2APIProtocol.IVitalScoreDetails} [totalDamageDealt] ScoreDetails totalDamageDealt
         * @property {SC2APIProtocol.IVitalScoreDetails} [totalDamageTaken] ScoreDetails totalDamageTaken
         * @property {SC2APIProtocol.IVitalScoreDetails} [totalHealed] ScoreDetails totalHealed
         */
        /**
         * Constructs a new ScoreDetails.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ScoreDetails.
         * @constructor
         * @param {SC2APIProtocol.IScoreDetails=} [properties] Properties to set
         */
        function ScoreDetails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ScoreDetails idleProductionTime.
         * @member {number}idleProductionTime
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.idleProductionTime = 0;
        /**
         * ScoreDetails idleWorkerTime.
         * @member {number}idleWorkerTime
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.idleWorkerTime = 0;
        /**
         * ScoreDetails totalValueUnits.
         * @member {number}totalValueUnits
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalValueUnits = 0;
        /**
         * ScoreDetails totalValueStructures.
         * @member {number}totalValueStructures
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalValueStructures = 0;
        /**
         * ScoreDetails killedValueUnits.
         * @member {number}killedValueUnits
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.killedValueUnits = 0;
        /**
         * ScoreDetails killedValueStructures.
         * @member {number}killedValueStructures
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.killedValueStructures = 0;
        /**
         * ScoreDetails collectedMinerals.
         * @member {number}collectedMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.collectedMinerals = 0;
        /**
         * ScoreDetails collectedVespene.
         * @member {number}collectedVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.collectedVespene = 0;
        /**
         * ScoreDetails collectionRateMinerals.
         * @member {number}collectionRateMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.collectionRateMinerals = 0;
        /**
         * ScoreDetails collectionRateVespene.
         * @member {number}collectionRateVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.collectionRateVespene = 0;
        /**
         * ScoreDetails spentMinerals.
         * @member {number}spentMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.spentMinerals = 0;
        /**
         * ScoreDetails spentVespene.
         * @member {number}spentVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.spentVespene = 0;
        /**
         * ScoreDetails foodUsed.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}foodUsed
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.foodUsed = null;
        /**
         * ScoreDetails killedMinerals.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}killedMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.killedMinerals = null;
        /**
         * ScoreDetails killedVespene.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}killedVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.killedVespene = null;
        /**
         * ScoreDetails lostMinerals.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}lostMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.lostMinerals = null;
        /**
         * ScoreDetails lostVespene.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}lostVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.lostVespene = null;
        /**
         * ScoreDetails friendlyFireMinerals.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}friendlyFireMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.friendlyFireMinerals = null;
        /**
         * ScoreDetails friendlyFireVespene.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}friendlyFireVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.friendlyFireVespene = null;
        /**
         * ScoreDetails usedMinerals.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}usedMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.usedMinerals = null;
        /**
         * ScoreDetails usedVespene.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}usedVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.usedVespene = null;
        /**
         * ScoreDetails totalUsedMinerals.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}totalUsedMinerals
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalUsedMinerals = null;
        /**
         * ScoreDetails totalUsedVespene.
         * @member {(SC2APIProtocol.ICategoryScoreDetails|null|undefined)}totalUsedVespene
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalUsedVespene = null;
        /**
         * ScoreDetails totalDamageDealt.
         * @member {(SC2APIProtocol.IVitalScoreDetails|null|undefined)}totalDamageDealt
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalDamageDealt = null;
        /**
         * ScoreDetails totalDamageTaken.
         * @member {(SC2APIProtocol.IVitalScoreDetails|null|undefined)}totalDamageTaken
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalDamageTaken = null;
        /**
         * ScoreDetails totalHealed.
         * @member {(SC2APIProtocol.IVitalScoreDetails|null|undefined)}totalHealed
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         */
        ScoreDetails.prototype.totalHealed = null;
        /**
         * Creates a new ScoreDetails instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {SC2APIProtocol.IScoreDetails=} [properties] Properties to set
         * @returns {SC2APIProtocol.ScoreDetails} ScoreDetails instance
         */
        ScoreDetails.create = function create(properties) {
            return new ScoreDetails(properties);
        };
        /**
         * Encodes the specified ScoreDetails message. Does not implicitly {@link SC2APIProtocol.ScoreDetails.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {SC2APIProtocol.IScoreDetails} message ScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScoreDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idleProductionTime != null && message.hasOwnProperty("idleProductionTime"))
                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.idleProductionTime);
            if (message.idleWorkerTime != null && message.hasOwnProperty("idleWorkerTime"))
                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.idleWorkerTime);
            if (message.totalValueUnits != null && message.hasOwnProperty("totalValueUnits"))
                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.totalValueUnits);
            if (message.totalValueStructures != null && message.hasOwnProperty("totalValueStructures"))
                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.totalValueStructures);
            if (message.killedValueUnits != null && message.hasOwnProperty("killedValueUnits"))
                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.killedValueUnits);
            if (message.killedValueStructures != null && message.hasOwnProperty("killedValueStructures"))
                writer.uint32(/* id 6, wireType 5 =*/ 53).float(message.killedValueStructures);
            if (message.collectedMinerals != null && message.hasOwnProperty("collectedMinerals"))
                writer.uint32(/* id 7, wireType 5 =*/ 61).float(message.collectedMinerals);
            if (message.collectedVespene != null && message.hasOwnProperty("collectedVespene"))
                writer.uint32(/* id 8, wireType 5 =*/ 69).float(message.collectedVespene);
            if (message.collectionRateMinerals != null && message.hasOwnProperty("collectionRateMinerals"))
                writer.uint32(/* id 9, wireType 5 =*/ 77).float(message.collectionRateMinerals);
            if (message.collectionRateVespene != null && message.hasOwnProperty("collectionRateVespene"))
                writer.uint32(/* id 10, wireType 5 =*/ 85).float(message.collectionRateVespene);
            if (message.spentMinerals != null && message.hasOwnProperty("spentMinerals"))
                writer.uint32(/* id 11, wireType 5 =*/ 93).float(message.spentMinerals);
            if (message.spentVespene != null && message.hasOwnProperty("spentVespene"))
                writer.uint32(/* id 12, wireType 5 =*/ 101).float(message.spentVespene);
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.foodUsed, writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
            if (message.killedMinerals != null && message.hasOwnProperty("killedMinerals"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.killedMinerals, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            if (message.killedVespene != null && message.hasOwnProperty("killedVespene"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.killedVespene, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
            if (message.lostMinerals != null && message.hasOwnProperty("lostMinerals"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.lostMinerals, writer.uint32(/* id 16, wireType 2 =*/ 130).fork()).ldelim();
            if (message.lostVespene != null && message.hasOwnProperty("lostVespene"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.lostVespene, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
            if (message.friendlyFireMinerals != null && message.hasOwnProperty("friendlyFireMinerals"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.friendlyFireMinerals, writer.uint32(/* id 18, wireType 2 =*/ 146).fork()).ldelim();
            if (message.friendlyFireVespene != null && message.hasOwnProperty("friendlyFireVespene"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.friendlyFireVespene, writer.uint32(/* id 19, wireType 2 =*/ 154).fork()).ldelim();
            if (message.usedMinerals != null && message.hasOwnProperty("usedMinerals"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.usedMinerals, writer.uint32(/* id 20, wireType 2 =*/ 162).fork()).ldelim();
            if (message.usedVespene != null && message.hasOwnProperty("usedVespene"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.usedVespene, writer.uint32(/* id 21, wireType 2 =*/ 170).fork()).ldelim();
            if (message.totalUsedMinerals != null && message.hasOwnProperty("totalUsedMinerals"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.totalUsedMinerals, writer.uint32(/* id 22, wireType 2 =*/ 178).fork()).ldelim();
            if (message.totalUsedVespene != null && message.hasOwnProperty("totalUsedVespene"))
                $root.SC2APIProtocol.CategoryScoreDetails.encode(message.totalUsedVespene, writer.uint32(/* id 23, wireType 2 =*/ 186).fork()).ldelim();
            if (message.totalDamageDealt != null && message.hasOwnProperty("totalDamageDealt"))
                $root.SC2APIProtocol.VitalScoreDetails.encode(message.totalDamageDealt, writer.uint32(/* id 24, wireType 2 =*/ 194).fork()).ldelim();
            if (message.totalDamageTaken != null && message.hasOwnProperty("totalDamageTaken"))
                $root.SC2APIProtocol.VitalScoreDetails.encode(message.totalDamageTaken, writer.uint32(/* id 25, wireType 2 =*/ 202).fork()).ldelim();
            if (message.totalHealed != null && message.hasOwnProperty("totalHealed"))
                $root.SC2APIProtocol.VitalScoreDetails.encode(message.totalHealed, writer.uint32(/* id 26, wireType 2 =*/ 210).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ScoreDetails message, length delimited. Does not implicitly {@link SC2APIProtocol.ScoreDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {SC2APIProtocol.IScoreDetails} message ScoreDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScoreDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ScoreDetails message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ScoreDetails} ScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScoreDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ScoreDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.idleProductionTime = reader.float();
                        break;
                    case 2:
                        message.idleWorkerTime = reader.float();
                        break;
                    case 3:
                        message.totalValueUnits = reader.float();
                        break;
                    case 4:
                        message.totalValueStructures = reader.float();
                        break;
                    case 5:
                        message.killedValueUnits = reader.float();
                        break;
                    case 6:
                        message.killedValueStructures = reader.float();
                        break;
                    case 7:
                        message.collectedMinerals = reader.float();
                        break;
                    case 8:
                        message.collectedVespene = reader.float();
                        break;
                    case 9:
                        message.collectionRateMinerals = reader.float();
                        break;
                    case 10:
                        message.collectionRateVespene = reader.float();
                        break;
                    case 11:
                        message.spentMinerals = reader.float();
                        break;
                    case 12:
                        message.spentVespene = reader.float();
                        break;
                    case 13:
                        message.foodUsed = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.killedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.killedVespene = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.lostMinerals = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.lostVespene = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.friendlyFireMinerals = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.friendlyFireVespene = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.usedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.usedVespene = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.totalUsedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 23:
                        message.totalUsedVespene = $root.SC2APIProtocol.CategoryScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 24:
                        message.totalDamageDealt = $root.SC2APIProtocol.VitalScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 25:
                        message.totalDamageTaken = $root.SC2APIProtocol.VitalScoreDetails.decode(reader, reader.uint32());
                        break;
                    case 26:
                        message.totalHealed = $root.SC2APIProtocol.VitalScoreDetails.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ScoreDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ScoreDetails} ScoreDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScoreDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ScoreDetails message.
         * @function verify
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScoreDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idleProductionTime != null && message.hasOwnProperty("idleProductionTime"))
                if (typeof message.idleProductionTime !== "number")
                    return "idleProductionTime: number expected";
            if (message.idleWorkerTime != null && message.hasOwnProperty("idleWorkerTime"))
                if (typeof message.idleWorkerTime !== "number")
                    return "idleWorkerTime: number expected";
            if (message.totalValueUnits != null && message.hasOwnProperty("totalValueUnits"))
                if (typeof message.totalValueUnits !== "number")
                    return "totalValueUnits: number expected";
            if (message.totalValueStructures != null && message.hasOwnProperty("totalValueStructures"))
                if (typeof message.totalValueStructures !== "number")
                    return "totalValueStructures: number expected";
            if (message.killedValueUnits != null && message.hasOwnProperty("killedValueUnits"))
                if (typeof message.killedValueUnits !== "number")
                    return "killedValueUnits: number expected";
            if (message.killedValueStructures != null && message.hasOwnProperty("killedValueStructures"))
                if (typeof message.killedValueStructures !== "number")
                    return "killedValueStructures: number expected";
            if (message.collectedMinerals != null && message.hasOwnProperty("collectedMinerals"))
                if (typeof message.collectedMinerals !== "number")
                    return "collectedMinerals: number expected";
            if (message.collectedVespene != null && message.hasOwnProperty("collectedVespene"))
                if (typeof message.collectedVespene !== "number")
                    return "collectedVespene: number expected";
            if (message.collectionRateMinerals != null && message.hasOwnProperty("collectionRateMinerals"))
                if (typeof message.collectionRateMinerals !== "number")
                    return "collectionRateMinerals: number expected";
            if (message.collectionRateVespene != null && message.hasOwnProperty("collectionRateVespene"))
                if (typeof message.collectionRateVespene !== "number")
                    return "collectionRateVespene: number expected";
            if (message.spentMinerals != null && message.hasOwnProperty("spentMinerals"))
                if (typeof message.spentMinerals !== "number")
                    return "spentMinerals: number expected";
            if (message.spentVespene != null && message.hasOwnProperty("spentVespene"))
                if (typeof message.spentVespene !== "number")
                    return "spentVespene: number expected";
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed")) {
                var error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.foodUsed);
                if (error)
                    return "foodUsed." + error;
            }
            if (message.killedMinerals != null && message.hasOwnProperty("killedMinerals")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.killedMinerals);
                if (error)
                    return "killedMinerals." + error;
            }
            if (message.killedVespene != null && message.hasOwnProperty("killedVespene")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.killedVespene);
                if (error)
                    return "killedVespene." + error;
            }
            if (message.lostMinerals != null && message.hasOwnProperty("lostMinerals")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.lostMinerals);
                if (error)
                    return "lostMinerals." + error;
            }
            if (message.lostVespene != null && message.hasOwnProperty("lostVespene")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.lostVespene);
                if (error)
                    return "lostVespene." + error;
            }
            if (message.friendlyFireMinerals != null && message.hasOwnProperty("friendlyFireMinerals")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.friendlyFireMinerals);
                if (error)
                    return "friendlyFireMinerals." + error;
            }
            if (message.friendlyFireVespene != null && message.hasOwnProperty("friendlyFireVespene")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.friendlyFireVespene);
                if (error)
                    return "friendlyFireVespene." + error;
            }
            if (message.usedMinerals != null && message.hasOwnProperty("usedMinerals")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.usedMinerals);
                if (error)
                    return "usedMinerals." + error;
            }
            if (message.usedVespene != null && message.hasOwnProperty("usedVespene")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.usedVespene);
                if (error)
                    return "usedVespene." + error;
            }
            if (message.totalUsedMinerals != null && message.hasOwnProperty("totalUsedMinerals")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.totalUsedMinerals);
                if (error)
                    return "totalUsedMinerals." + error;
            }
            if (message.totalUsedVespene != null && message.hasOwnProperty("totalUsedVespene")) {
                error = $root.SC2APIProtocol.CategoryScoreDetails.verify(message.totalUsedVespene);
                if (error)
                    return "totalUsedVespene." + error;
            }
            if (message.totalDamageDealt != null && message.hasOwnProperty("totalDamageDealt")) {
                error = $root.SC2APIProtocol.VitalScoreDetails.verify(message.totalDamageDealt);
                if (error)
                    return "totalDamageDealt." + error;
            }
            if (message.totalDamageTaken != null && message.hasOwnProperty("totalDamageTaken")) {
                error = $root.SC2APIProtocol.VitalScoreDetails.verify(message.totalDamageTaken);
                if (error)
                    return "totalDamageTaken." + error;
            }
            if (message.totalHealed != null && message.hasOwnProperty("totalHealed")) {
                error = $root.SC2APIProtocol.VitalScoreDetails.verify(message.totalHealed);
                if (error)
                    return "totalHealed." + error;
            }
            return null;
        };
        /**
         * Creates a ScoreDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ScoreDetails} ScoreDetails
         */
        ScoreDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ScoreDetails)
                return object;
            var message = new $root.SC2APIProtocol.ScoreDetails();
            if (object.idleProductionTime != null)
                message.idleProductionTime = Number(object.idleProductionTime);
            if (object.idleWorkerTime != null)
                message.idleWorkerTime = Number(object.idleWorkerTime);
            if (object.totalValueUnits != null)
                message.totalValueUnits = Number(object.totalValueUnits);
            if (object.totalValueStructures != null)
                message.totalValueStructures = Number(object.totalValueStructures);
            if (object.killedValueUnits != null)
                message.killedValueUnits = Number(object.killedValueUnits);
            if (object.killedValueStructures != null)
                message.killedValueStructures = Number(object.killedValueStructures);
            if (object.collectedMinerals != null)
                message.collectedMinerals = Number(object.collectedMinerals);
            if (object.collectedVespene != null)
                message.collectedVespene = Number(object.collectedVespene);
            if (object.collectionRateMinerals != null)
                message.collectionRateMinerals = Number(object.collectionRateMinerals);
            if (object.collectionRateVespene != null)
                message.collectionRateVespene = Number(object.collectionRateVespene);
            if (object.spentMinerals != null)
                message.spentMinerals = Number(object.spentMinerals);
            if (object.spentVespene != null)
                message.spentVespene = Number(object.spentVespene);
            if (object.foodUsed != null) {
                if (typeof object.foodUsed !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.foodUsed: object expected");
                message.foodUsed = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.foodUsed);
            }
            if (object.killedMinerals != null) {
                if (typeof object.killedMinerals !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.killedMinerals: object expected");
                message.killedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.killedMinerals);
            }
            if (object.killedVespene != null) {
                if (typeof object.killedVespene !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.killedVespene: object expected");
                message.killedVespene = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.killedVespene);
            }
            if (object.lostMinerals != null) {
                if (typeof object.lostMinerals !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.lostMinerals: object expected");
                message.lostMinerals = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.lostMinerals);
            }
            if (object.lostVespene != null) {
                if (typeof object.lostVespene !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.lostVespene: object expected");
                message.lostVespene = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.lostVespene);
            }
            if (object.friendlyFireMinerals != null) {
                if (typeof object.friendlyFireMinerals !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.friendlyFireMinerals: object expected");
                message.friendlyFireMinerals = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.friendlyFireMinerals);
            }
            if (object.friendlyFireVespene != null) {
                if (typeof object.friendlyFireVespene !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.friendlyFireVespene: object expected");
                message.friendlyFireVespene = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.friendlyFireVespene);
            }
            if (object.usedMinerals != null) {
                if (typeof object.usedMinerals !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.usedMinerals: object expected");
                message.usedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.usedMinerals);
            }
            if (object.usedVespene != null) {
                if (typeof object.usedVespene !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.usedVespene: object expected");
                message.usedVespene = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.usedVespene);
            }
            if (object.totalUsedMinerals != null) {
                if (typeof object.totalUsedMinerals !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.totalUsedMinerals: object expected");
                message.totalUsedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.totalUsedMinerals);
            }
            if (object.totalUsedVespene != null) {
                if (typeof object.totalUsedVespene !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.totalUsedVespene: object expected");
                message.totalUsedVespene = $root.SC2APIProtocol.CategoryScoreDetails.fromObject(object.totalUsedVespene);
            }
            if (object.totalDamageDealt != null) {
                if (typeof object.totalDamageDealt !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.totalDamageDealt: object expected");
                message.totalDamageDealt = $root.SC2APIProtocol.VitalScoreDetails.fromObject(object.totalDamageDealt);
            }
            if (object.totalDamageTaken != null) {
                if (typeof object.totalDamageTaken !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.totalDamageTaken: object expected");
                message.totalDamageTaken = $root.SC2APIProtocol.VitalScoreDetails.fromObject(object.totalDamageTaken);
            }
            if (object.totalHealed != null) {
                if (typeof object.totalHealed !== "object")
                    throw TypeError(".SC2APIProtocol.ScoreDetails.totalHealed: object expected");
                message.totalHealed = $root.SC2APIProtocol.VitalScoreDetails.fromObject(object.totalHealed);
            }
            return message;
        };
        /**
         * Creates a plain object from a ScoreDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ScoreDetails
         * @static
         * @param {SC2APIProtocol.ScoreDetails} message ScoreDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScoreDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.idleProductionTime = 0;
                object.idleWorkerTime = 0;
                object.totalValueUnits = 0;
                object.totalValueStructures = 0;
                object.killedValueUnits = 0;
                object.killedValueStructures = 0;
                object.collectedMinerals = 0;
                object.collectedVespene = 0;
                object.collectionRateMinerals = 0;
                object.collectionRateVespene = 0;
                object.spentMinerals = 0;
                object.spentVespene = 0;
                object.foodUsed = null;
                object.killedMinerals = null;
                object.killedVespene = null;
                object.lostMinerals = null;
                object.lostVespene = null;
                object.friendlyFireMinerals = null;
                object.friendlyFireVespene = null;
                object.usedMinerals = null;
                object.usedVespene = null;
                object.totalUsedMinerals = null;
                object.totalUsedVespene = null;
                object.totalDamageDealt = null;
                object.totalDamageTaken = null;
                object.totalHealed = null;
            }
            if (message.idleProductionTime != null && message.hasOwnProperty("idleProductionTime"))
                object.idleProductionTime = options.json && !isFinite(message.idleProductionTime) ? String(message.idleProductionTime) : message.idleProductionTime;
            if (message.idleWorkerTime != null && message.hasOwnProperty("idleWorkerTime"))
                object.idleWorkerTime = options.json && !isFinite(message.idleWorkerTime) ? String(message.idleWorkerTime) : message.idleWorkerTime;
            if (message.totalValueUnits != null && message.hasOwnProperty("totalValueUnits"))
                object.totalValueUnits = options.json && !isFinite(message.totalValueUnits) ? String(message.totalValueUnits) : message.totalValueUnits;
            if (message.totalValueStructures != null && message.hasOwnProperty("totalValueStructures"))
                object.totalValueStructures = options.json && !isFinite(message.totalValueStructures) ? String(message.totalValueStructures) : message.totalValueStructures;
            if (message.killedValueUnits != null && message.hasOwnProperty("killedValueUnits"))
                object.killedValueUnits = options.json && !isFinite(message.killedValueUnits) ? String(message.killedValueUnits) : message.killedValueUnits;
            if (message.killedValueStructures != null && message.hasOwnProperty("killedValueStructures"))
                object.killedValueStructures = options.json && !isFinite(message.killedValueStructures) ? String(message.killedValueStructures) : message.killedValueStructures;
            if (message.collectedMinerals != null && message.hasOwnProperty("collectedMinerals"))
                object.collectedMinerals = options.json && !isFinite(message.collectedMinerals) ? String(message.collectedMinerals) : message.collectedMinerals;
            if (message.collectedVespene != null && message.hasOwnProperty("collectedVespene"))
                object.collectedVespene = options.json && !isFinite(message.collectedVespene) ? String(message.collectedVespene) : message.collectedVespene;
            if (message.collectionRateMinerals != null && message.hasOwnProperty("collectionRateMinerals"))
                object.collectionRateMinerals = options.json && !isFinite(message.collectionRateMinerals) ? String(message.collectionRateMinerals) : message.collectionRateMinerals;
            if (message.collectionRateVespene != null && message.hasOwnProperty("collectionRateVespene"))
                object.collectionRateVespene = options.json && !isFinite(message.collectionRateVespene) ? String(message.collectionRateVespene) : message.collectionRateVespene;
            if (message.spentMinerals != null && message.hasOwnProperty("spentMinerals"))
                object.spentMinerals = options.json && !isFinite(message.spentMinerals) ? String(message.spentMinerals) : message.spentMinerals;
            if (message.spentVespene != null && message.hasOwnProperty("spentVespene"))
                object.spentVespene = options.json && !isFinite(message.spentVespene) ? String(message.spentVespene) : message.spentVespene;
            if (message.foodUsed != null && message.hasOwnProperty("foodUsed"))
                object.foodUsed = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.foodUsed, options);
            if (message.killedMinerals != null && message.hasOwnProperty("killedMinerals"))
                object.killedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.killedMinerals, options);
            if (message.killedVespene != null && message.hasOwnProperty("killedVespene"))
                object.killedVespene = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.killedVespene, options);
            if (message.lostMinerals != null && message.hasOwnProperty("lostMinerals"))
                object.lostMinerals = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.lostMinerals, options);
            if (message.lostVespene != null && message.hasOwnProperty("lostVespene"))
                object.lostVespene = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.lostVespene, options);
            if (message.friendlyFireMinerals != null && message.hasOwnProperty("friendlyFireMinerals"))
                object.friendlyFireMinerals = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.friendlyFireMinerals, options);
            if (message.friendlyFireVespene != null && message.hasOwnProperty("friendlyFireVespene"))
                object.friendlyFireVespene = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.friendlyFireVespene, options);
            if (message.usedMinerals != null && message.hasOwnProperty("usedMinerals"))
                object.usedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.usedMinerals, options);
            if (message.usedVespene != null && message.hasOwnProperty("usedVespene"))
                object.usedVespene = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.usedVespene, options);
            if (message.totalUsedMinerals != null && message.hasOwnProperty("totalUsedMinerals"))
                object.totalUsedMinerals = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.totalUsedMinerals, options);
            if (message.totalUsedVespene != null && message.hasOwnProperty("totalUsedVespene"))
                object.totalUsedVespene = $root.SC2APIProtocol.CategoryScoreDetails.toObject(message.totalUsedVespene, options);
            if (message.totalDamageDealt != null && message.hasOwnProperty("totalDamageDealt"))
                object.totalDamageDealt = $root.SC2APIProtocol.VitalScoreDetails.toObject(message.totalDamageDealt, options);
            if (message.totalDamageTaken != null && message.hasOwnProperty("totalDamageTaken"))
                object.totalDamageTaken = $root.SC2APIProtocol.VitalScoreDetails.toObject(message.totalDamageTaken, options);
            if (message.totalHealed != null && message.hasOwnProperty("totalHealed"))
                object.totalHealed = $root.SC2APIProtocol.VitalScoreDetails.toObject(message.totalHealed, options);
            return object;
        };
        /**
         * Converts this ScoreDetails to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ScoreDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScoreDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ScoreDetails;
    })();
    SC2APIProtocol.ObservationFeatureLayer = (function () {
        /**
         * Properties of an ObservationFeatureLayer.
         * @memberof SC2APIProtocol
         * @interface IObservationFeatureLayer
         * @property {SC2APIProtocol.IFeatureLayers} [renders] ObservationFeatureLayer renders
         * @property {SC2APIProtocol.IFeatureLayersMinimap} [minimapRenders] ObservationFeatureLayer minimapRenders
         */
        /**
         * Constructs a new ObservationFeatureLayer.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ObservationFeatureLayer.
         * @constructor
         * @param {SC2APIProtocol.IObservationFeatureLayer=} [properties] Properties to set
         */
        function ObservationFeatureLayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ObservationFeatureLayer renders.
         * @member {(SC2APIProtocol.IFeatureLayers|null|undefined)}renders
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @instance
         */
        ObservationFeatureLayer.prototype.renders = null;
        /**
         * ObservationFeatureLayer minimapRenders.
         * @member {(SC2APIProtocol.IFeatureLayersMinimap|null|undefined)}minimapRenders
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @instance
         */
        ObservationFeatureLayer.prototype.minimapRenders = null;
        /**
         * Creates a new ObservationFeatureLayer instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {SC2APIProtocol.IObservationFeatureLayer=} [properties] Properties to set
         * @returns {SC2APIProtocol.ObservationFeatureLayer} ObservationFeatureLayer instance
         */
        ObservationFeatureLayer.create = function create(properties) {
            return new ObservationFeatureLayer(properties);
        };
        /**
         * Encodes the specified ObservationFeatureLayer message. Does not implicitly {@link SC2APIProtocol.ObservationFeatureLayer.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {SC2APIProtocol.IObservationFeatureLayer} message ObservationFeatureLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationFeatureLayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.renders != null && message.hasOwnProperty("renders"))
                $root.SC2APIProtocol.FeatureLayers.encode(message.renders, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.minimapRenders != null && message.hasOwnProperty("minimapRenders"))
                $root.SC2APIProtocol.FeatureLayersMinimap.encode(message.minimapRenders, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ObservationFeatureLayer message, length delimited. Does not implicitly {@link SC2APIProtocol.ObservationFeatureLayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {SC2APIProtocol.IObservationFeatureLayer} message ObservationFeatureLayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationFeatureLayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ObservationFeatureLayer message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ObservationFeatureLayer} ObservationFeatureLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationFeatureLayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ObservationFeatureLayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.renders = $root.SC2APIProtocol.FeatureLayers.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.minimapRenders = $root.SC2APIProtocol.FeatureLayersMinimap.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ObservationFeatureLayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ObservationFeatureLayer} ObservationFeatureLayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationFeatureLayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ObservationFeatureLayer message.
         * @function verify
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ObservationFeatureLayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.renders != null && message.hasOwnProperty("renders")) {
                var error = $root.SC2APIProtocol.FeatureLayers.verify(message.renders);
                if (error)
                    return "renders." + error;
            }
            if (message.minimapRenders != null && message.hasOwnProperty("minimapRenders")) {
                error = $root.SC2APIProtocol.FeatureLayersMinimap.verify(message.minimapRenders);
                if (error)
                    return "minimapRenders." + error;
            }
            return null;
        };
        /**
         * Creates an ObservationFeatureLayer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ObservationFeatureLayer} ObservationFeatureLayer
         */
        ObservationFeatureLayer.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ObservationFeatureLayer)
                return object;
            var message = new $root.SC2APIProtocol.ObservationFeatureLayer();
            if (object.renders != null) {
                if (typeof object.renders !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationFeatureLayer.renders: object expected");
                message.renders = $root.SC2APIProtocol.FeatureLayers.fromObject(object.renders);
            }
            if (object.minimapRenders != null) {
                if (typeof object.minimapRenders !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationFeatureLayer.minimapRenders: object expected");
                message.minimapRenders = $root.SC2APIProtocol.FeatureLayersMinimap.fromObject(object.minimapRenders);
            }
            return message;
        };
        /**
         * Creates a plain object from an ObservationFeatureLayer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @static
         * @param {SC2APIProtocol.ObservationFeatureLayer} message ObservationFeatureLayer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ObservationFeatureLayer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.renders = null;
                object.minimapRenders = null;
            }
            if (message.renders != null && message.hasOwnProperty("renders"))
                object.renders = $root.SC2APIProtocol.FeatureLayers.toObject(message.renders, options);
            if (message.minimapRenders != null && message.hasOwnProperty("minimapRenders"))
                object.minimapRenders = $root.SC2APIProtocol.FeatureLayersMinimap.toObject(message.minimapRenders, options);
            return object;
        };
        /**
         * Converts this ObservationFeatureLayer to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ObservationFeatureLayer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ObservationFeatureLayer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ObservationFeatureLayer;
    })();
    SC2APIProtocol.FeatureLayers = (function () {
        /**
         * Properties of a FeatureLayers.
         * @memberof SC2APIProtocol
         * @interface IFeatureLayers
         * @property {SC2APIProtocol.IImageData} [heightMap] FeatureLayers heightMap
         * @property {SC2APIProtocol.IImageData} [visibilityMap] FeatureLayers visibilityMap
         * @property {SC2APIProtocol.IImageData} [creep] FeatureLayers creep
         * @property {SC2APIProtocol.IImageData} [power] FeatureLayers power
         * @property {SC2APIProtocol.IImageData} [playerId] FeatureLayers playerId
         * @property {SC2APIProtocol.IImageData} [unitType] FeatureLayers unitType
         * @property {SC2APIProtocol.IImageData} [selected] FeatureLayers selected
         * @property {SC2APIProtocol.IImageData} [unitHitPoints] FeatureLayers unitHitPoints
         * @property {SC2APIProtocol.IImageData} [unitHitPointsRatio] FeatureLayers unitHitPointsRatio
         * @property {SC2APIProtocol.IImageData} [unitEnergy] FeatureLayers unitEnergy
         * @property {SC2APIProtocol.IImageData} [unitShields] FeatureLayers unitShields
         * @property {SC2APIProtocol.IImageData} [playerRelative] FeatureLayers playerRelative
         * @property {SC2APIProtocol.IImageData} [unitDensityAa] FeatureLayers unitDensityAa
         * @property {SC2APIProtocol.IImageData} [unitDensity] FeatureLayers unitDensity
         */
        /**
         * Constructs a new FeatureLayers.
         * @memberof SC2APIProtocol
         * @classdesc Represents a FeatureLayers.
         * @constructor
         * @param {SC2APIProtocol.IFeatureLayers=} [properties] Properties to set
         */
        function FeatureLayers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FeatureLayers heightMap.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}heightMap
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.heightMap = null;
        /**
         * FeatureLayers visibilityMap.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}visibilityMap
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.visibilityMap = null;
        /**
         * FeatureLayers creep.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}creep
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.creep = null;
        /**
         * FeatureLayers power.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}power
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.power = null;
        /**
         * FeatureLayers playerId.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}playerId
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.playerId = null;
        /**
         * FeatureLayers unitType.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitType
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitType = null;
        /**
         * FeatureLayers selected.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}selected
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.selected = null;
        /**
         * FeatureLayers unitHitPoints.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitHitPoints
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitHitPoints = null;
        /**
         * FeatureLayers unitHitPointsRatio.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitHitPointsRatio
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitHitPointsRatio = null;
        /**
         * FeatureLayers unitEnergy.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitEnergy
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitEnergy = null;
        /**
         * FeatureLayers unitShields.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitShields
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitShields = null;
        /**
         * FeatureLayers playerRelative.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}playerRelative
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.playerRelative = null;
        /**
         * FeatureLayers unitDensityAa.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitDensityAa
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitDensityAa = null;
        /**
         * FeatureLayers unitDensity.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitDensity
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         */
        FeatureLayers.prototype.unitDensity = null;
        /**
         * Creates a new FeatureLayers instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {SC2APIProtocol.IFeatureLayers=} [properties] Properties to set
         * @returns {SC2APIProtocol.FeatureLayers} FeatureLayers instance
         */
        FeatureLayers.create = function create(properties) {
            return new FeatureLayers(properties);
        };
        /**
         * Encodes the specified FeatureLayers message. Does not implicitly {@link SC2APIProtocol.FeatureLayers.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {SC2APIProtocol.IFeatureLayers} message FeatureLayers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLayers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heightMap != null && message.hasOwnProperty("heightMap"))
                $root.SC2APIProtocol.ImageData.encode(message.heightMap, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap"))
                $root.SC2APIProtocol.ImageData.encode(message.visibilityMap, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.creep != null && message.hasOwnProperty("creep"))
                $root.SC2APIProtocol.ImageData.encode(message.creep, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.power != null && message.hasOwnProperty("power"))
                $root.SC2APIProtocol.ImageData.encode(message.power, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                $root.SC2APIProtocol.ImageData.encode(message.playerId, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                $root.SC2APIProtocol.ImageData.encode(message.unitType, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.selected != null && message.hasOwnProperty("selected"))
                $root.SC2APIProtocol.ImageData.encode(message.selected, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.unitHitPoints != null && message.hasOwnProperty("unitHitPoints"))
                $root.SC2APIProtocol.ImageData.encode(message.unitHitPoints, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.unitEnergy != null && message.hasOwnProperty("unitEnergy"))
                $root.SC2APIProtocol.ImageData.encode(message.unitEnergy, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            if (message.unitShields != null && message.hasOwnProperty("unitShields"))
                $root.SC2APIProtocol.ImageData.encode(message.unitShields, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                $root.SC2APIProtocol.ImageData.encode(message.playerRelative, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
            if (message.unitDensityAa != null && message.hasOwnProperty("unitDensityAa"))
                $root.SC2APIProtocol.ImageData.encode(message.unitDensityAa, writer.uint32(/* id 14, wireType 2 =*/ 114).fork()).ldelim();
            if (message.unitDensity != null && message.hasOwnProperty("unitDensity"))
                $root.SC2APIProtocol.ImageData.encode(message.unitDensity, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
            if (message.unitHitPointsRatio != null && message.hasOwnProperty("unitHitPointsRatio"))
                $root.SC2APIProtocol.ImageData.encode(message.unitHitPointsRatio, writer.uint32(/* id 17, wireType 2 =*/ 138).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified FeatureLayers message, length delimited. Does not implicitly {@link SC2APIProtocol.FeatureLayers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {SC2APIProtocol.IFeatureLayers} message FeatureLayers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLayers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a FeatureLayers message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.FeatureLayers} FeatureLayers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLayers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.FeatureLayers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.heightMap = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.visibilityMap = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.creep = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.power = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.playerId = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.unitType = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.selected = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.unitHitPoints = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.unitHitPointsRatio = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.unitEnergy = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.unitShields = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.playerRelative = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.unitDensityAa = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.unitDensity = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a FeatureLayers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.FeatureLayers} FeatureLayers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLayers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a FeatureLayers message.
         * @function verify
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureLayers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heightMap != null && message.hasOwnProperty("heightMap")) {
                var error = $root.SC2APIProtocol.ImageData.verify(message.heightMap);
                if (error)
                    return "heightMap." + error;
            }
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.visibilityMap);
                if (error)
                    return "visibilityMap." + error;
            }
            if (message.creep != null && message.hasOwnProperty("creep")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.creep);
                if (error)
                    return "creep." + error;
            }
            if (message.power != null && message.hasOwnProperty("power")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.power);
                if (error)
                    return "power." + error;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.playerId);
                if (error)
                    return "playerId." + error;
            }
            if (message.unitType != null && message.hasOwnProperty("unitType")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitType);
                if (error)
                    return "unitType." + error;
            }
            if (message.selected != null && message.hasOwnProperty("selected")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.selected);
                if (error)
                    return "selected." + error;
            }
            if (message.unitHitPoints != null && message.hasOwnProperty("unitHitPoints")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitHitPoints);
                if (error)
                    return "unitHitPoints." + error;
            }
            if (message.unitHitPointsRatio != null && message.hasOwnProperty("unitHitPointsRatio")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitHitPointsRatio);
                if (error)
                    return "unitHitPointsRatio." + error;
            }
            if (message.unitEnergy != null && message.hasOwnProperty("unitEnergy")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitEnergy);
                if (error)
                    return "unitEnergy." + error;
            }
            if (message.unitShields != null && message.hasOwnProperty("unitShields")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitShields);
                if (error)
                    return "unitShields." + error;
            }
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.playerRelative);
                if (error)
                    return "playerRelative." + error;
            }
            if (message.unitDensityAa != null && message.hasOwnProperty("unitDensityAa")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitDensityAa);
                if (error)
                    return "unitDensityAa." + error;
            }
            if (message.unitDensity != null && message.hasOwnProperty("unitDensity")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitDensity);
                if (error)
                    return "unitDensity." + error;
            }
            return null;
        };
        /**
         * Creates a FeatureLayers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.FeatureLayers} FeatureLayers
         */
        FeatureLayers.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.FeatureLayers)
                return object;
            var message = new $root.SC2APIProtocol.FeatureLayers();
            if (object.heightMap != null) {
                if (typeof object.heightMap !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.heightMap: object expected");
                message.heightMap = $root.SC2APIProtocol.ImageData.fromObject(object.heightMap);
            }
            if (object.visibilityMap != null) {
                if (typeof object.visibilityMap !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.visibilityMap: object expected");
                message.visibilityMap = $root.SC2APIProtocol.ImageData.fromObject(object.visibilityMap);
            }
            if (object.creep != null) {
                if (typeof object.creep !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.creep: object expected");
                message.creep = $root.SC2APIProtocol.ImageData.fromObject(object.creep);
            }
            if (object.power != null) {
                if (typeof object.power !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.power: object expected");
                message.power = $root.SC2APIProtocol.ImageData.fromObject(object.power);
            }
            if (object.playerId != null) {
                if (typeof object.playerId !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.playerId: object expected");
                message.playerId = $root.SC2APIProtocol.ImageData.fromObject(object.playerId);
            }
            if (object.unitType != null) {
                if (typeof object.unitType !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitType: object expected");
                message.unitType = $root.SC2APIProtocol.ImageData.fromObject(object.unitType);
            }
            if (object.selected != null) {
                if (typeof object.selected !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.selected: object expected");
                message.selected = $root.SC2APIProtocol.ImageData.fromObject(object.selected);
            }
            if (object.unitHitPoints != null) {
                if (typeof object.unitHitPoints !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitHitPoints: object expected");
                message.unitHitPoints = $root.SC2APIProtocol.ImageData.fromObject(object.unitHitPoints);
            }
            if (object.unitHitPointsRatio != null) {
                if (typeof object.unitHitPointsRatio !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitHitPointsRatio: object expected");
                message.unitHitPointsRatio = $root.SC2APIProtocol.ImageData.fromObject(object.unitHitPointsRatio);
            }
            if (object.unitEnergy != null) {
                if (typeof object.unitEnergy !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitEnergy: object expected");
                message.unitEnergy = $root.SC2APIProtocol.ImageData.fromObject(object.unitEnergy);
            }
            if (object.unitShields != null) {
                if (typeof object.unitShields !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitShields: object expected");
                message.unitShields = $root.SC2APIProtocol.ImageData.fromObject(object.unitShields);
            }
            if (object.playerRelative != null) {
                if (typeof object.playerRelative !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.playerRelative: object expected");
                message.playerRelative = $root.SC2APIProtocol.ImageData.fromObject(object.playerRelative);
            }
            if (object.unitDensityAa != null) {
                if (typeof object.unitDensityAa !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitDensityAa: object expected");
                message.unitDensityAa = $root.SC2APIProtocol.ImageData.fromObject(object.unitDensityAa);
            }
            if (object.unitDensity != null) {
                if (typeof object.unitDensity !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayers.unitDensity: object expected");
                message.unitDensity = $root.SC2APIProtocol.ImageData.fromObject(object.unitDensity);
            }
            return message;
        };
        /**
         * Creates a plain object from a FeatureLayers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.FeatureLayers
         * @static
         * @param {SC2APIProtocol.FeatureLayers} message FeatureLayers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureLayers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heightMap = null;
                object.visibilityMap = null;
                object.creep = null;
                object.power = null;
                object.playerId = null;
                object.unitType = null;
                object.selected = null;
                object.unitHitPoints = null;
                object.unitEnergy = null;
                object.unitShields = null;
                object.playerRelative = null;
                object.unitDensityAa = null;
                object.unitDensity = null;
                object.unitHitPointsRatio = null;
            }
            if (message.heightMap != null && message.hasOwnProperty("heightMap"))
                object.heightMap = $root.SC2APIProtocol.ImageData.toObject(message.heightMap, options);
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap"))
                object.visibilityMap = $root.SC2APIProtocol.ImageData.toObject(message.visibilityMap, options);
            if (message.creep != null && message.hasOwnProperty("creep"))
                object.creep = $root.SC2APIProtocol.ImageData.toObject(message.creep, options);
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = $root.SC2APIProtocol.ImageData.toObject(message.power, options);
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = $root.SC2APIProtocol.ImageData.toObject(message.playerId, options);
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = $root.SC2APIProtocol.ImageData.toObject(message.unitType, options);
            if (message.selected != null && message.hasOwnProperty("selected"))
                object.selected = $root.SC2APIProtocol.ImageData.toObject(message.selected, options);
            if (message.unitHitPoints != null && message.hasOwnProperty("unitHitPoints"))
                object.unitHitPoints = $root.SC2APIProtocol.ImageData.toObject(message.unitHitPoints, options);
            if (message.unitEnergy != null && message.hasOwnProperty("unitEnergy"))
                object.unitEnergy = $root.SC2APIProtocol.ImageData.toObject(message.unitEnergy, options);
            if (message.unitShields != null && message.hasOwnProperty("unitShields"))
                object.unitShields = $root.SC2APIProtocol.ImageData.toObject(message.unitShields, options);
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                object.playerRelative = $root.SC2APIProtocol.ImageData.toObject(message.playerRelative, options);
            if (message.unitDensityAa != null && message.hasOwnProperty("unitDensityAa"))
                object.unitDensityAa = $root.SC2APIProtocol.ImageData.toObject(message.unitDensityAa, options);
            if (message.unitDensity != null && message.hasOwnProperty("unitDensity"))
                object.unitDensity = $root.SC2APIProtocol.ImageData.toObject(message.unitDensity, options);
            if (message.unitHitPointsRatio != null && message.hasOwnProperty("unitHitPointsRatio"))
                object.unitHitPointsRatio = $root.SC2APIProtocol.ImageData.toObject(message.unitHitPointsRatio, options);
            return object;
        };
        /**
         * Converts this FeatureLayers to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.FeatureLayers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureLayers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FeatureLayers;
    })();
    SC2APIProtocol.FeatureLayersMinimap = (function () {
        /**
         * Properties of a FeatureLayersMinimap.
         * @memberof SC2APIProtocol
         * @interface IFeatureLayersMinimap
         * @property {SC2APIProtocol.IImageData} [heightMap] FeatureLayersMinimap heightMap
         * @property {SC2APIProtocol.IImageData} [visibilityMap] FeatureLayersMinimap visibilityMap
         * @property {SC2APIProtocol.IImageData} [creep] FeatureLayersMinimap creep
         * @property {SC2APIProtocol.IImageData} [camera] FeatureLayersMinimap camera
         * @property {SC2APIProtocol.IImageData} [playerId] FeatureLayersMinimap playerId
         * @property {SC2APIProtocol.IImageData} [playerRelative] FeatureLayersMinimap playerRelative
         * @property {SC2APIProtocol.IImageData} [selected] FeatureLayersMinimap selected
         * @property {SC2APIProtocol.IImageData} [unitType] FeatureLayersMinimap unitType
         */
        /**
         * Constructs a new FeatureLayersMinimap.
         * @memberof SC2APIProtocol
         * @classdesc Represents a FeatureLayersMinimap.
         * @constructor
         * @param {SC2APIProtocol.IFeatureLayersMinimap=} [properties] Properties to set
         */
        function FeatureLayersMinimap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FeatureLayersMinimap heightMap.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}heightMap
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.heightMap = null;
        /**
         * FeatureLayersMinimap visibilityMap.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}visibilityMap
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.visibilityMap = null;
        /**
         * FeatureLayersMinimap creep.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}creep
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.creep = null;
        /**
         * FeatureLayersMinimap camera.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}camera
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.camera = null;
        /**
         * FeatureLayersMinimap playerId.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}playerId
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.playerId = null;
        /**
         * FeatureLayersMinimap playerRelative.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}playerRelative
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.playerRelative = null;
        /**
         * FeatureLayersMinimap selected.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}selected
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.selected = null;
        /**
         * FeatureLayersMinimap unitType.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}unitType
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         */
        FeatureLayersMinimap.prototype.unitType = null;
        /**
         * Creates a new FeatureLayersMinimap instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {SC2APIProtocol.IFeatureLayersMinimap=} [properties] Properties to set
         * @returns {SC2APIProtocol.FeatureLayersMinimap} FeatureLayersMinimap instance
         */
        FeatureLayersMinimap.create = function create(properties) {
            return new FeatureLayersMinimap(properties);
        };
        /**
         * Encodes the specified FeatureLayersMinimap message. Does not implicitly {@link SC2APIProtocol.FeatureLayersMinimap.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {SC2APIProtocol.IFeatureLayersMinimap} message FeatureLayersMinimap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLayersMinimap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heightMap != null && message.hasOwnProperty("heightMap"))
                $root.SC2APIProtocol.ImageData.encode(message.heightMap, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap"))
                $root.SC2APIProtocol.ImageData.encode(message.visibilityMap, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.creep != null && message.hasOwnProperty("creep"))
                $root.SC2APIProtocol.ImageData.encode(message.creep, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.camera != null && message.hasOwnProperty("camera"))
                $root.SC2APIProtocol.ImageData.encode(message.camera, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                $root.SC2APIProtocol.ImageData.encode(message.playerId, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                $root.SC2APIProtocol.ImageData.encode(message.playerRelative, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.selected != null && message.hasOwnProperty("selected"))
                $root.SC2APIProtocol.ImageData.encode(message.selected, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                $root.SC2APIProtocol.ImageData.encode(message.unitType, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified FeatureLayersMinimap message, length delimited. Does not implicitly {@link SC2APIProtocol.FeatureLayersMinimap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {SC2APIProtocol.IFeatureLayersMinimap} message FeatureLayersMinimap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLayersMinimap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a FeatureLayersMinimap message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.FeatureLayersMinimap} FeatureLayersMinimap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLayersMinimap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.FeatureLayersMinimap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.heightMap = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.visibilityMap = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.creep = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.camera = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.playerId = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.playerRelative = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.selected = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.unitType = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a FeatureLayersMinimap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.FeatureLayersMinimap} FeatureLayersMinimap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLayersMinimap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a FeatureLayersMinimap message.
         * @function verify
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureLayersMinimap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heightMap != null && message.hasOwnProperty("heightMap")) {
                var error = $root.SC2APIProtocol.ImageData.verify(message.heightMap);
                if (error)
                    return "heightMap." + error;
            }
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.visibilityMap);
                if (error)
                    return "visibilityMap." + error;
            }
            if (message.creep != null && message.hasOwnProperty("creep")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.creep);
                if (error)
                    return "creep." + error;
            }
            if (message.camera != null && message.hasOwnProperty("camera")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.camera);
                if (error)
                    return "camera." + error;
            }
            if (message.playerId != null && message.hasOwnProperty("playerId")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.playerId);
                if (error)
                    return "playerId." + error;
            }
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.playerRelative);
                if (error)
                    return "playerRelative." + error;
            }
            if (message.selected != null && message.hasOwnProperty("selected")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.selected);
                if (error)
                    return "selected." + error;
            }
            if (message.unitType != null && message.hasOwnProperty("unitType")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.unitType);
                if (error)
                    return "unitType." + error;
            }
            return null;
        };
        /**
         * Creates a FeatureLayersMinimap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.FeatureLayersMinimap} FeatureLayersMinimap
         */
        FeatureLayersMinimap.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.FeatureLayersMinimap)
                return object;
            var message = new $root.SC2APIProtocol.FeatureLayersMinimap();
            if (object.heightMap != null) {
                if (typeof object.heightMap !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.heightMap: object expected");
                message.heightMap = $root.SC2APIProtocol.ImageData.fromObject(object.heightMap);
            }
            if (object.visibilityMap != null) {
                if (typeof object.visibilityMap !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.visibilityMap: object expected");
                message.visibilityMap = $root.SC2APIProtocol.ImageData.fromObject(object.visibilityMap);
            }
            if (object.creep != null) {
                if (typeof object.creep !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.creep: object expected");
                message.creep = $root.SC2APIProtocol.ImageData.fromObject(object.creep);
            }
            if (object.camera != null) {
                if (typeof object.camera !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.camera: object expected");
                message.camera = $root.SC2APIProtocol.ImageData.fromObject(object.camera);
            }
            if (object.playerId != null) {
                if (typeof object.playerId !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.playerId: object expected");
                message.playerId = $root.SC2APIProtocol.ImageData.fromObject(object.playerId);
            }
            if (object.playerRelative != null) {
                if (typeof object.playerRelative !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.playerRelative: object expected");
                message.playerRelative = $root.SC2APIProtocol.ImageData.fromObject(object.playerRelative);
            }
            if (object.selected != null) {
                if (typeof object.selected !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.selected: object expected");
                message.selected = $root.SC2APIProtocol.ImageData.fromObject(object.selected);
            }
            if (object.unitType != null) {
                if (typeof object.unitType !== "object")
                    throw TypeError(".SC2APIProtocol.FeatureLayersMinimap.unitType: object expected");
                message.unitType = $root.SC2APIProtocol.ImageData.fromObject(object.unitType);
            }
            return message;
        };
        /**
         * Creates a plain object from a FeatureLayersMinimap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @static
         * @param {SC2APIProtocol.FeatureLayersMinimap} message FeatureLayersMinimap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureLayersMinimap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heightMap = null;
                object.visibilityMap = null;
                object.creep = null;
                object.camera = null;
                object.playerId = null;
                object.playerRelative = null;
                object.selected = null;
                object.unitType = null;
            }
            if (message.heightMap != null && message.hasOwnProperty("heightMap"))
                object.heightMap = $root.SC2APIProtocol.ImageData.toObject(message.heightMap, options);
            if (message.visibilityMap != null && message.hasOwnProperty("visibilityMap"))
                object.visibilityMap = $root.SC2APIProtocol.ImageData.toObject(message.visibilityMap, options);
            if (message.creep != null && message.hasOwnProperty("creep"))
                object.creep = $root.SC2APIProtocol.ImageData.toObject(message.creep, options);
            if (message.camera != null && message.hasOwnProperty("camera"))
                object.camera = $root.SC2APIProtocol.ImageData.toObject(message.camera, options);
            if (message.playerId != null && message.hasOwnProperty("playerId"))
                object.playerId = $root.SC2APIProtocol.ImageData.toObject(message.playerId, options);
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                object.playerRelative = $root.SC2APIProtocol.ImageData.toObject(message.playerRelative, options);
            if (message.selected != null && message.hasOwnProperty("selected"))
                object.selected = $root.SC2APIProtocol.ImageData.toObject(message.selected, options);
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = $root.SC2APIProtocol.ImageData.toObject(message.unitType, options);
            return object;
        };
        /**
         * Converts this FeatureLayersMinimap to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.FeatureLayersMinimap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureLayersMinimap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FeatureLayersMinimap;
    })();
    SC2APIProtocol.ObservationRender = (function () {
        /**
         * Properties of an ObservationRender.
         * @memberof SC2APIProtocol
         * @interface IObservationRender
         * @property {SC2APIProtocol.IImageData} [map] ObservationRender map
         * @property {SC2APIProtocol.IImageData} [minimap] ObservationRender minimap
         */
        /**
         * Constructs a new ObservationRender.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ObservationRender.
         * @constructor
         * @param {SC2APIProtocol.IObservationRender=} [properties] Properties to set
         */
        function ObservationRender(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ObservationRender map.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}map
         * @memberof SC2APIProtocol.ObservationRender
         * @instance
         */
        ObservationRender.prototype.map = null;
        /**
         * ObservationRender minimap.
         * @member {(SC2APIProtocol.IImageData|null|undefined)}minimap
         * @memberof SC2APIProtocol.ObservationRender
         * @instance
         */
        ObservationRender.prototype.minimap = null;
        /**
         * Creates a new ObservationRender instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {SC2APIProtocol.IObservationRender=} [properties] Properties to set
         * @returns {SC2APIProtocol.ObservationRender} ObservationRender instance
         */
        ObservationRender.create = function create(properties) {
            return new ObservationRender(properties);
        };
        /**
         * Encodes the specified ObservationRender message. Does not implicitly {@link SC2APIProtocol.ObservationRender.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {SC2APIProtocol.IObservationRender} message ObservationRender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationRender.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.map != null && message.hasOwnProperty("map"))
                $root.SC2APIProtocol.ImageData.encode(message.map, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.minimap != null && message.hasOwnProperty("minimap"))
                $root.SC2APIProtocol.ImageData.encode(message.minimap, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ObservationRender message, length delimited. Does not implicitly {@link SC2APIProtocol.ObservationRender.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {SC2APIProtocol.IObservationRender} message ObservationRender message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationRender.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ObservationRender message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ObservationRender} ObservationRender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationRender.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ObservationRender();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.map = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.minimap = $root.SC2APIProtocol.ImageData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ObservationRender message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ObservationRender} ObservationRender
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationRender.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ObservationRender message.
         * @function verify
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ObservationRender.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.map != null && message.hasOwnProperty("map")) {
                var error = $root.SC2APIProtocol.ImageData.verify(message.map);
                if (error)
                    return "map." + error;
            }
            if (message.minimap != null && message.hasOwnProperty("minimap")) {
                error = $root.SC2APIProtocol.ImageData.verify(message.minimap);
                if (error)
                    return "minimap." + error;
            }
            return null;
        };
        /**
         * Creates an ObservationRender message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ObservationRender} ObservationRender
         */
        ObservationRender.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ObservationRender)
                return object;
            var message = new $root.SC2APIProtocol.ObservationRender();
            if (object.map != null) {
                if (typeof object.map !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationRender.map: object expected");
                message.map = $root.SC2APIProtocol.ImageData.fromObject(object.map);
            }
            if (object.minimap != null) {
                if (typeof object.minimap !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationRender.minimap: object expected");
                message.minimap = $root.SC2APIProtocol.ImageData.fromObject(object.minimap);
            }
            return message;
        };
        /**
         * Creates a plain object from an ObservationRender message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ObservationRender
         * @static
         * @param {SC2APIProtocol.ObservationRender} message ObservationRender
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ObservationRender.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.map = null;
                object.minimap = null;
            }
            if (message.map != null && message.hasOwnProperty("map"))
                object.map = $root.SC2APIProtocol.ImageData.toObject(message.map, options);
            if (message.minimap != null && message.hasOwnProperty("minimap"))
                object.minimap = $root.SC2APIProtocol.ImageData.toObject(message.minimap, options);
            return object;
        };
        /**
         * Converts this ObservationRender to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ObservationRender
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ObservationRender.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ObservationRender;
    })();
    SC2APIProtocol.ActionSpatial = (function () {
        /**
         * Properties of an ActionSpatial.
         * @memberof SC2APIProtocol
         * @interface IActionSpatial
         * @property {SC2APIProtocol.IActionSpatialUnitCommand} [unitCommand] ActionSpatial unitCommand
         * @property {SC2APIProtocol.IActionSpatialCameraMove} [cameraMove] ActionSpatial cameraMove
         * @property {SC2APIProtocol.IActionSpatialUnitSelectionPoint} [unitSelectionPoint] ActionSpatial unitSelectionPoint
         * @property {SC2APIProtocol.IActionSpatialUnitSelectionRect} [unitSelectionRect] ActionSpatial unitSelectionRect
         */
        /**
         * Constructs a new ActionSpatial.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSpatial.
         * @constructor
         * @param {SC2APIProtocol.IActionSpatial=} [properties] Properties to set
         */
        function ActionSpatial(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSpatial unitCommand.
         * @member {(SC2APIProtocol.IActionSpatialUnitCommand|null|undefined)}unitCommand
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         */
        ActionSpatial.prototype.unitCommand = null;
        /**
         * ActionSpatial cameraMove.
         * @member {(SC2APIProtocol.IActionSpatialCameraMove|null|undefined)}cameraMove
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         */
        ActionSpatial.prototype.cameraMove = null;
        /**
         * ActionSpatial unitSelectionPoint.
         * @member {(SC2APIProtocol.IActionSpatialUnitSelectionPoint|null|undefined)}unitSelectionPoint
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         */
        ActionSpatial.prototype.unitSelectionPoint = null;
        /**
         * ActionSpatial unitSelectionRect.
         * @member {(SC2APIProtocol.IActionSpatialUnitSelectionRect|null|undefined)}unitSelectionRect
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         */
        ActionSpatial.prototype.unitSelectionRect = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ActionSpatial action.
         * @member {string|undefined} action
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         */
        Object.defineProperty(ActionSpatial.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["unitCommand", "cameraMove", "unitSelectionPoint", "unitSelectionRect"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ActionSpatial instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {SC2APIProtocol.IActionSpatial=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSpatial} ActionSpatial instance
         */
        ActionSpatial.create = function create(properties) {
            return new ActionSpatial(properties);
        };
        /**
         * Encodes the specified ActionSpatial message. Does not implicitly {@link SC2APIProtocol.ActionSpatial.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {SC2APIProtocol.IActionSpatial} message ActionSpatial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatial.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand"))
                $root.SC2APIProtocol.ActionSpatialUnitCommand.encode(message.unitCommand, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove"))
                $root.SC2APIProtocol.ActionSpatialCameraMove.encode(message.cameraMove, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.unitSelectionPoint != null && message.hasOwnProperty("unitSelectionPoint"))
                $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.encode(message.unitSelectionPoint, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.unitSelectionRect != null && message.hasOwnProperty("unitSelectionRect"))
                $root.SC2APIProtocol.ActionSpatialUnitSelectionRect.encode(message.unitSelectionRect, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ActionSpatial message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSpatial.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {SC2APIProtocol.IActionSpatial} message ActionSpatial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatial.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSpatial message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSpatial} ActionSpatial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatial.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSpatial();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitCommand = $root.SC2APIProtocol.ActionSpatialUnitCommand.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.cameraMove = $root.SC2APIProtocol.ActionSpatialCameraMove.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.unitSelectionPoint = $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.unitSelectionRect = $root.SC2APIProtocol.ActionSpatialUnitSelectionRect.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSpatial message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSpatial} ActionSpatial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatial.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSpatial message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSpatial.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand")) {
                properties.action = 1;
                var error = $root.SC2APIProtocol.ActionSpatialUnitCommand.verify(message.unitCommand);
                if (error)
                    return "unitCommand." + error;
            }
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSpatialCameraMove.verify(message.cameraMove);
                if (error)
                    return "cameraMove." + error;
            }
            if (message.unitSelectionPoint != null && message.hasOwnProperty("unitSelectionPoint")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.verify(message.unitSelectionPoint);
                if (error)
                    return "unitSelectionPoint." + error;
            }
            if (message.unitSelectionRect != null && message.hasOwnProperty("unitSelectionRect")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSpatialUnitSelectionRect.verify(message.unitSelectionRect);
                if (error)
                    return "unitSelectionRect." + error;
            }
            return null;
        };
        /**
         * Creates an ActionSpatial message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSpatial} ActionSpatial
         */
        ActionSpatial.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSpatial)
                return object;
            var message = new $root.SC2APIProtocol.ActionSpatial();
            if (object.unitCommand != null) {
                if (typeof object.unitCommand !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatial.unitCommand: object expected");
                message.unitCommand = $root.SC2APIProtocol.ActionSpatialUnitCommand.fromObject(object.unitCommand);
            }
            if (object.cameraMove != null) {
                if (typeof object.cameraMove !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatial.cameraMove: object expected");
                message.cameraMove = $root.SC2APIProtocol.ActionSpatialCameraMove.fromObject(object.cameraMove);
            }
            if (object.unitSelectionPoint != null) {
                if (typeof object.unitSelectionPoint !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatial.unitSelectionPoint: object expected");
                message.unitSelectionPoint = $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.fromObject(object.unitSelectionPoint);
            }
            if (object.unitSelectionRect != null) {
                if (typeof object.unitSelectionRect !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatial.unitSelectionRect: object expected");
                message.unitSelectionRect = $root.SC2APIProtocol.ActionSpatialUnitSelectionRect.fromObject(object.unitSelectionRect);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionSpatial message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSpatial
         * @static
         * @param {SC2APIProtocol.ActionSpatial} message ActionSpatial
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSpatial.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.unitCommand != null && message.hasOwnProperty("unitCommand")) {
                object.unitCommand = $root.SC2APIProtocol.ActionSpatialUnitCommand.toObject(message.unitCommand, options);
                if (options.oneofs)
                    object.action = "unitCommand";
            }
            if (message.cameraMove != null && message.hasOwnProperty("cameraMove")) {
                object.cameraMove = $root.SC2APIProtocol.ActionSpatialCameraMove.toObject(message.cameraMove, options);
                if (options.oneofs)
                    object.action = "cameraMove";
            }
            if (message.unitSelectionPoint != null && message.hasOwnProperty("unitSelectionPoint")) {
                object.unitSelectionPoint = $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.toObject(message.unitSelectionPoint, options);
                if (options.oneofs)
                    object.action = "unitSelectionPoint";
            }
            if (message.unitSelectionRect != null && message.hasOwnProperty("unitSelectionRect")) {
                object.unitSelectionRect = $root.SC2APIProtocol.ActionSpatialUnitSelectionRect.toObject(message.unitSelectionRect, options);
                if (options.oneofs)
                    object.action = "unitSelectionRect";
            }
            return object;
        };
        /**
         * Converts this ActionSpatial to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSpatial
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSpatial.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSpatial;
    })();
    SC2APIProtocol.ActionSpatialUnitCommand = (function () {
        /**
         * Properties of an ActionSpatialUnitCommand.
         * @memberof SC2APIProtocol
         * @interface IActionSpatialUnitCommand
         * @property {number} [abilityId] ActionSpatialUnitCommand abilityId
         * @property {SC2APIProtocol.IPointI} [targetScreenCoord] ActionSpatialUnitCommand targetScreenCoord
         * @property {SC2APIProtocol.IPointI} [targetMinimapCoord] ActionSpatialUnitCommand targetMinimapCoord
         * @property {boolean} [queueCommand] ActionSpatialUnitCommand queueCommand
         */
        /**
         * Constructs a new ActionSpatialUnitCommand.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSpatialUnitCommand.
         * @constructor
         * @param {SC2APIProtocol.IActionSpatialUnitCommand=} [properties] Properties to set
         */
        function ActionSpatialUnitCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSpatialUnitCommand abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         */
        ActionSpatialUnitCommand.prototype.abilityId = 0;
        /**
         * ActionSpatialUnitCommand targetScreenCoord.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}targetScreenCoord
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         */
        ActionSpatialUnitCommand.prototype.targetScreenCoord = null;
        /**
         * ActionSpatialUnitCommand targetMinimapCoord.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}targetMinimapCoord
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         */
        ActionSpatialUnitCommand.prototype.targetMinimapCoord = null;
        /**
         * ActionSpatialUnitCommand queueCommand.
         * @member {boolean}queueCommand
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         */
        ActionSpatialUnitCommand.prototype.queueCommand = false;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ActionSpatialUnitCommand target.
         * @member {string|undefined} target
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         */
        Object.defineProperty(ActionSpatialUnitCommand.prototype, "target", {
            get: $util.oneOfGetter($oneOfFields = ["targetScreenCoord", "targetMinimapCoord"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ActionSpatialUnitCommand instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitCommand=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSpatialUnitCommand} ActionSpatialUnitCommand instance
         */
        ActionSpatialUnitCommand.create = function create(properties) {
            return new ActionSpatialUnitCommand(properties);
        };
        /**
         * Encodes the specified ActionSpatialUnitCommand message. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitCommand.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitCommand} message ActionSpatialUnitCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            if (message.targetScreenCoord != null && message.hasOwnProperty("targetScreenCoord"))
                $root.SC2APIProtocol.PointI.encode(message.targetScreenCoord, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.targetMinimapCoord != null && message.hasOwnProperty("targetMinimapCoord"))
                $root.SC2APIProtocol.PointI.encode(message.targetMinimapCoord, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.queueCommand);
            return writer;
        };
        /**
         * Encodes the specified ActionSpatialUnitCommand message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitCommand} message ActionSpatialUnitCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSpatialUnitCommand message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSpatialUnitCommand} ActionSpatialUnitCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSpatialUnitCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    case 2:
                        message.targetScreenCoord = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.targetMinimapCoord = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.queueCommand = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSpatialUnitCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSpatialUnitCommand} ActionSpatialUnitCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSpatialUnitCommand message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSpatialUnitCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            if (message.targetScreenCoord != null && message.hasOwnProperty("targetScreenCoord")) {
                properties.target = 1;
                var error = $root.SC2APIProtocol.PointI.verify(message.targetScreenCoord);
                if (error)
                    return "targetScreenCoord." + error;
            }
            if (message.targetMinimapCoord != null && message.hasOwnProperty("targetMinimapCoord")) {
                if (properties.target === 1)
                    return "target: multiple values";
                properties.target = 1;
                error = $root.SC2APIProtocol.PointI.verify(message.targetMinimapCoord);
                if (error)
                    return "targetMinimapCoord." + error;
            }
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                if (typeof message.queueCommand !== "boolean")
                    return "queueCommand: boolean expected";
            return null;
        };
        /**
         * Creates an ActionSpatialUnitCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSpatialUnitCommand} ActionSpatialUnitCommand
         */
        ActionSpatialUnitCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSpatialUnitCommand)
                return object;
            var message = new $root.SC2APIProtocol.ActionSpatialUnitCommand();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            if (object.targetScreenCoord != null) {
                if (typeof object.targetScreenCoord !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatialUnitCommand.targetScreenCoord: object expected");
                message.targetScreenCoord = $root.SC2APIProtocol.PointI.fromObject(object.targetScreenCoord);
            }
            if (object.targetMinimapCoord != null) {
                if (typeof object.targetMinimapCoord !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatialUnitCommand.targetMinimapCoord: object expected");
                message.targetMinimapCoord = $root.SC2APIProtocol.PointI.fromObject(object.targetMinimapCoord);
            }
            if (object.queueCommand != null)
                message.queueCommand = Boolean(object.queueCommand);
            return message;
        };
        /**
         * Creates a plain object from an ActionSpatialUnitCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @static
         * @param {SC2APIProtocol.ActionSpatialUnitCommand} message ActionSpatialUnitCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSpatialUnitCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.abilityId = 0;
                object.queueCommand = false;
            }
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            if (message.targetScreenCoord != null && message.hasOwnProperty("targetScreenCoord")) {
                object.targetScreenCoord = $root.SC2APIProtocol.PointI.toObject(message.targetScreenCoord, options);
                if (options.oneofs)
                    object.target = "targetScreenCoord";
            }
            if (message.targetMinimapCoord != null && message.hasOwnProperty("targetMinimapCoord")) {
                object.targetMinimapCoord = $root.SC2APIProtocol.PointI.toObject(message.targetMinimapCoord, options);
                if (options.oneofs)
                    object.target = "targetMinimapCoord";
            }
            if (message.queueCommand != null && message.hasOwnProperty("queueCommand"))
                object.queueCommand = message.queueCommand;
            return object;
        };
        /**
         * Converts this ActionSpatialUnitCommand to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSpatialUnitCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSpatialUnitCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSpatialUnitCommand;
    })();
    SC2APIProtocol.ActionSpatialCameraMove = (function () {
        /**
         * Properties of an ActionSpatialCameraMove.
         * @memberof SC2APIProtocol
         * @interface IActionSpatialCameraMove
         * @property {SC2APIProtocol.IPointI} [centerMinimap] ActionSpatialCameraMove centerMinimap
         */
        /**
         * Constructs a new ActionSpatialCameraMove.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSpatialCameraMove.
         * @constructor
         * @param {SC2APIProtocol.IActionSpatialCameraMove=} [properties] Properties to set
         */
        function ActionSpatialCameraMove(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSpatialCameraMove centerMinimap.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}centerMinimap
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @instance
         */
        ActionSpatialCameraMove.prototype.centerMinimap = null;
        /**
         * Creates a new ActionSpatialCameraMove instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {SC2APIProtocol.IActionSpatialCameraMove=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSpatialCameraMove} ActionSpatialCameraMove instance
         */
        ActionSpatialCameraMove.create = function create(properties) {
            return new ActionSpatialCameraMove(properties);
        };
        /**
         * Encodes the specified ActionSpatialCameraMove message. Does not implicitly {@link SC2APIProtocol.ActionSpatialCameraMove.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {SC2APIProtocol.IActionSpatialCameraMove} message ActionSpatialCameraMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialCameraMove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.centerMinimap != null && message.hasOwnProperty("centerMinimap"))
                $root.SC2APIProtocol.PointI.encode(message.centerMinimap, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ActionSpatialCameraMove message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSpatialCameraMove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {SC2APIProtocol.IActionSpatialCameraMove} message ActionSpatialCameraMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialCameraMove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSpatialCameraMove message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSpatialCameraMove} ActionSpatialCameraMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialCameraMove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSpatialCameraMove();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.centerMinimap = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSpatialCameraMove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSpatialCameraMove} ActionSpatialCameraMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialCameraMove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSpatialCameraMove message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSpatialCameraMove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.centerMinimap != null && message.hasOwnProperty("centerMinimap")) {
                var error = $root.SC2APIProtocol.PointI.verify(message.centerMinimap);
                if (error)
                    return "centerMinimap." + error;
            }
            return null;
        };
        /**
         * Creates an ActionSpatialCameraMove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSpatialCameraMove} ActionSpatialCameraMove
         */
        ActionSpatialCameraMove.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSpatialCameraMove)
                return object;
            var message = new $root.SC2APIProtocol.ActionSpatialCameraMove();
            if (object.centerMinimap != null) {
                if (typeof object.centerMinimap !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatialCameraMove.centerMinimap: object expected");
                message.centerMinimap = $root.SC2APIProtocol.PointI.fromObject(object.centerMinimap);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionSpatialCameraMove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @static
         * @param {SC2APIProtocol.ActionSpatialCameraMove} message ActionSpatialCameraMove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSpatialCameraMove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.centerMinimap = null;
            if (message.centerMinimap != null && message.hasOwnProperty("centerMinimap"))
                object.centerMinimap = $root.SC2APIProtocol.PointI.toObject(message.centerMinimap, options);
            return object;
        };
        /**
         * Converts this ActionSpatialCameraMove to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSpatialCameraMove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSpatialCameraMove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSpatialCameraMove;
    })();
    SC2APIProtocol.ActionSpatialUnitSelectionPoint = (function () {
        /**
         * Properties of an ActionSpatialUnitSelectionPoint.
         * @memberof SC2APIProtocol
         * @interface IActionSpatialUnitSelectionPoint
         * @property {SC2APIProtocol.IPointI} [selectionScreenCoord] ActionSpatialUnitSelectionPoint selectionScreenCoord
         * @property {SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type} [type] ActionSpatialUnitSelectionPoint type
         */
        /**
         * Constructs a new ActionSpatialUnitSelectionPoint.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSpatialUnitSelectionPoint.
         * @constructor
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionPoint=} [properties] Properties to set
         */
        function ActionSpatialUnitSelectionPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSpatialUnitSelectionPoint selectionScreenCoord.
         * @member {(SC2APIProtocol.IPointI|null|undefined)}selectionScreenCoord
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @instance
         */
        ActionSpatialUnitSelectionPoint.prototype.selectionScreenCoord = null;
        /**
         * ActionSpatialUnitSelectionPoint type.
         * @member {SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type}type
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @instance
         */
        ActionSpatialUnitSelectionPoint.prototype.type = 1;
        /**
         * Creates a new ActionSpatialUnitSelectionPoint instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionPoint=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionPoint} ActionSpatialUnitSelectionPoint instance
         */
        ActionSpatialUnitSelectionPoint.create = function create(properties) {
            return new ActionSpatialUnitSelectionPoint(properties);
        };
        /**
         * Encodes the specified ActionSpatialUnitSelectionPoint message. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitSelectionPoint.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionPoint} message ActionSpatialUnitSelectionPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitSelectionPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectionScreenCoord != null && message.hasOwnProperty("selectionScreenCoord"))
                $root.SC2APIProtocol.PointI.encode(message.selectionScreenCoord, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.type);
            return writer;
        };
        /**
         * Encodes the specified ActionSpatialUnitSelectionPoint message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitSelectionPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionPoint} message ActionSpatialUnitSelectionPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitSelectionPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSpatialUnitSelectionPoint message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionPoint} ActionSpatialUnitSelectionPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitSelectionPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.selectionScreenCoord = $root.SC2APIProtocol.PointI.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSpatialUnitSelectionPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionPoint} ActionSpatialUnitSelectionPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitSelectionPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSpatialUnitSelectionPoint message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSpatialUnitSelectionPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectionScreenCoord != null && message.hasOwnProperty("selectionScreenCoord")) {
                var error = $root.SC2APIProtocol.PointI.verify(message.selectionScreenCoord);
                if (error)
                    return "selectionScreenCoord." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            return null;
        };
        /**
         * Creates an ActionSpatialUnitSelectionPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionPoint} ActionSpatialUnitSelectionPoint
         */
        ActionSpatialUnitSelectionPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint)
                return object;
            var message = new $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint();
            if (object.selectionScreenCoord != null) {
                if (typeof object.selectionScreenCoord !== "object")
                    throw TypeError(".SC2APIProtocol.ActionSpatialUnitSelectionPoint.selectionScreenCoord: object expected");
                message.selectionScreenCoord = $root.SC2APIProtocol.PointI.fromObject(object.selectionScreenCoord);
            }
            switch (object.type) {
                case "Select":
                case 1:
                    message.type = 1;
                    break;
                case "Toggle":
                case 2:
                    message.type = 2;
                    break;
                case "AllType":
                case 3:
                    message.type = 3;
                    break;
                case "AddAllType":
                case 4:
                    message.type = 4;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionSpatialUnitSelectionPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @static
         * @param {SC2APIProtocol.ActionSpatialUnitSelectionPoint} message ActionSpatialUnitSelectionPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSpatialUnitSelectionPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.selectionScreenCoord = null;
                object.type = options.enums === String ? "Select" : 1;
            }
            if (message.selectionScreenCoord != null && message.hasOwnProperty("selectionScreenCoord"))
                object.selectionScreenCoord = $root.SC2APIProtocol.PointI.toObject(message.selectionScreenCoord, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type[message.type] : message.type;
            return object;
        };
        /**
         * Converts this ActionSpatialUnitSelectionPoint to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSpatialUnitSelectionPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Type enum.
         * @enum {string}
         * @property {number} Select=1 Select value
         * @property {number} Toggle=2 Toggle value
         * @property {number} AllType=3 AllType value
         * @property {number} AddAllType=4 AddAllType value
         */
        ActionSpatialUnitSelectionPoint.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Select"] = 1;
            values[valuesById[2] = "Toggle"] = 2;
            values[valuesById[3] = "AllType"] = 3;
            values[valuesById[4] = "AddAllType"] = 4;
            return values;
        })();
        return ActionSpatialUnitSelectionPoint;
    })();
    SC2APIProtocol.ActionSpatialUnitSelectionRect = (function () {
        /**
         * Properties of an ActionSpatialUnitSelectionRect.
         * @memberof SC2APIProtocol
         * @interface IActionSpatialUnitSelectionRect
         * @property {Array.<SC2APIProtocol.IRectangleI>} [selectionScreenCoord] ActionSpatialUnitSelectionRect selectionScreenCoord
         * @property {boolean} [selectionAdd] ActionSpatialUnitSelectionRect selectionAdd
         */
        /**
         * Constructs a new ActionSpatialUnitSelectionRect.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSpatialUnitSelectionRect.
         * @constructor
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionRect=} [properties] Properties to set
         */
        function ActionSpatialUnitSelectionRect(properties) {
            this.selectionScreenCoord = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSpatialUnitSelectionRect selectionScreenCoord.
         * @member {Array.<SC2APIProtocol.IRectangleI>}selectionScreenCoord
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @instance
         */
        ActionSpatialUnitSelectionRect.prototype.selectionScreenCoord = $util.emptyArray;
        /**
         * ActionSpatialUnitSelectionRect selectionAdd.
         * @member {boolean}selectionAdd
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @instance
         */
        ActionSpatialUnitSelectionRect.prototype.selectionAdd = false;
        /**
         * Creates a new ActionSpatialUnitSelectionRect instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionRect=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionRect} ActionSpatialUnitSelectionRect instance
         */
        ActionSpatialUnitSelectionRect.create = function create(properties) {
            return new ActionSpatialUnitSelectionRect(properties);
        };
        /**
         * Encodes the specified ActionSpatialUnitSelectionRect message. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitSelectionRect.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionRect} message ActionSpatialUnitSelectionRect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitSelectionRect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectionScreenCoord != null && message.selectionScreenCoord.length)
                for (var i = 0; i < message.selectionScreenCoord.length; ++i)
                    $root.SC2APIProtocol.RectangleI.encode(message.selectionScreenCoord[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.selectionAdd);
            return writer;
        };
        /**
         * Encodes the specified ActionSpatialUnitSelectionRect message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSpatialUnitSelectionRect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {SC2APIProtocol.IActionSpatialUnitSelectionRect} message ActionSpatialUnitSelectionRect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSpatialUnitSelectionRect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSpatialUnitSelectionRect message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionRect} ActionSpatialUnitSelectionRect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitSelectionRect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSpatialUnitSelectionRect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.selectionScreenCoord && message.selectionScreenCoord.length))
                            message.selectionScreenCoord = [];
                        message.selectionScreenCoord.push($root.SC2APIProtocol.RectangleI.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.selectionAdd = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSpatialUnitSelectionRect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionRect} ActionSpatialUnitSelectionRect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSpatialUnitSelectionRect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSpatialUnitSelectionRect message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSpatialUnitSelectionRect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectionScreenCoord != null && message.hasOwnProperty("selectionScreenCoord")) {
                if (!Array.isArray(message.selectionScreenCoord))
                    return "selectionScreenCoord: array expected";
                for (var i = 0; i < message.selectionScreenCoord.length; ++i) {
                    var error = $root.SC2APIProtocol.RectangleI.verify(message.selectionScreenCoord[i]);
                    if (error)
                        return "selectionScreenCoord." + error;
                }
            }
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                if (typeof message.selectionAdd !== "boolean")
                    return "selectionAdd: boolean expected";
            return null;
        };
        /**
         * Creates an ActionSpatialUnitSelectionRect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSpatialUnitSelectionRect} ActionSpatialUnitSelectionRect
         */
        ActionSpatialUnitSelectionRect.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSpatialUnitSelectionRect)
                return object;
            var message = new $root.SC2APIProtocol.ActionSpatialUnitSelectionRect();
            if (object.selectionScreenCoord) {
                if (!Array.isArray(object.selectionScreenCoord))
                    throw TypeError(".SC2APIProtocol.ActionSpatialUnitSelectionRect.selectionScreenCoord: array expected");
                message.selectionScreenCoord = [];
                for (var i = 0; i < object.selectionScreenCoord.length; ++i) {
                    if (typeof object.selectionScreenCoord[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ActionSpatialUnitSelectionRect.selectionScreenCoord: object expected");
                    message.selectionScreenCoord[i] = $root.SC2APIProtocol.RectangleI.fromObject(object.selectionScreenCoord[i]);
                }
            }
            if (object.selectionAdd != null)
                message.selectionAdd = Boolean(object.selectionAdd);
            return message;
        };
        /**
         * Creates a plain object from an ActionSpatialUnitSelectionRect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @static
         * @param {SC2APIProtocol.ActionSpatialUnitSelectionRect} message ActionSpatialUnitSelectionRect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSpatialUnitSelectionRect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.selectionScreenCoord = [];
            if (options.defaults)
                object.selectionAdd = false;
            if (message.selectionScreenCoord && message.selectionScreenCoord.length) {
                object.selectionScreenCoord = [];
                for (var j = 0; j < message.selectionScreenCoord.length; ++j)
                    object.selectionScreenCoord[j] = $root.SC2APIProtocol.RectangleI.toObject(message.selectionScreenCoord[j], options);
            }
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                object.selectionAdd = message.selectionAdd;
            return object;
        };
        /**
         * Converts this ActionSpatialUnitSelectionRect to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSpatialUnitSelectionRect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSpatialUnitSelectionRect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSpatialUnitSelectionRect;
    })();
    SC2APIProtocol.ObservationUI = (function () {
        /**
         * Properties of an ObservationUI.
         * @memberof SC2APIProtocol
         * @interface IObservationUI
         * @property {Array.<SC2APIProtocol.IControlGroup>} [groups] ObservationUI groups
         * @property {SC2APIProtocol.ISinglePanel} [single] ObservationUI single
         * @property {SC2APIProtocol.IMultiPanel} [multi] ObservationUI multi
         * @property {SC2APIProtocol.ICargoPanel} [cargo] ObservationUI cargo
         * @property {SC2APIProtocol.IProductionPanel} [production] ObservationUI production
         */
        /**
         * Constructs a new ObservationUI.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ObservationUI.
         * @constructor
         * @param {SC2APIProtocol.IObservationUI=} [properties] Properties to set
         */
        function ObservationUI(properties) {
            this.groups = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ObservationUI groups.
         * @member {Array.<SC2APIProtocol.IControlGroup>}groups
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        ObservationUI.prototype.groups = $util.emptyArray;
        /**
         * ObservationUI single.
         * @member {(SC2APIProtocol.ISinglePanel|null|undefined)}single
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        ObservationUI.prototype.single = null;
        /**
         * ObservationUI multi.
         * @member {(SC2APIProtocol.IMultiPanel|null|undefined)}multi
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        ObservationUI.prototype.multi = null;
        /**
         * ObservationUI cargo.
         * @member {(SC2APIProtocol.ICargoPanel|null|undefined)}cargo
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        ObservationUI.prototype.cargo = null;
        /**
         * ObservationUI production.
         * @member {(SC2APIProtocol.IProductionPanel|null|undefined)}production
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        ObservationUI.prototype.production = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ObservationUI panel.
         * @member {string|undefined} panel
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         */
        Object.defineProperty(ObservationUI.prototype, "panel", {
            get: $util.oneOfGetter($oneOfFields = ["single", "multi", "cargo", "production"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ObservationUI instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {SC2APIProtocol.IObservationUI=} [properties] Properties to set
         * @returns {SC2APIProtocol.ObservationUI} ObservationUI instance
         */
        ObservationUI.create = function create(properties) {
            return new ObservationUI(properties);
        };
        /**
         * Encodes the specified ObservationUI message. Does not implicitly {@link SC2APIProtocol.ObservationUI.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {SC2APIProtocol.IObservationUI} message ObservationUI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationUI.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groups != null && message.groups.length)
                for (var i = 0; i < message.groups.length; ++i)
                    $root.SC2APIProtocol.ControlGroup.encode(message.groups[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.single != null && message.hasOwnProperty("single"))
                $root.SC2APIProtocol.SinglePanel.encode(message.single, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.multi != null && message.hasOwnProperty("multi"))
                $root.SC2APIProtocol.MultiPanel.encode(message.multi, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.cargo != null && message.hasOwnProperty("cargo"))
                $root.SC2APIProtocol.CargoPanel.encode(message.cargo, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.production != null && message.hasOwnProperty("production"))
                $root.SC2APIProtocol.ProductionPanel.encode(message.production, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ObservationUI message, length delimited. Does not implicitly {@link SC2APIProtocol.ObservationUI.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {SC2APIProtocol.IObservationUI} message ObservationUI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ObservationUI.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ObservationUI message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ObservationUI} ObservationUI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationUI.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ObservationUI();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push($root.SC2APIProtocol.ControlGroup.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.single = $root.SC2APIProtocol.SinglePanel.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.multi = $root.SC2APIProtocol.MultiPanel.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.cargo = $root.SC2APIProtocol.CargoPanel.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.production = $root.SC2APIProtocol.ProductionPanel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ObservationUI message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ObservationUI} ObservationUI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ObservationUI.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ObservationUI message.
         * @function verify
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ObservationUI.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.groups != null && message.hasOwnProperty("groups")) {
                if (!Array.isArray(message.groups))
                    return "groups: array expected";
                for (var i = 0; i < message.groups.length; ++i) {
                    var error = $root.SC2APIProtocol.ControlGroup.verify(message.groups[i]);
                    if (error)
                        return "groups." + error;
                }
            }
            if (message.single != null && message.hasOwnProperty("single")) {
                properties.panel = 1;
                error = $root.SC2APIProtocol.SinglePanel.verify(message.single);
                if (error)
                    return "single." + error;
            }
            if (message.multi != null && message.hasOwnProperty("multi")) {
                if (properties.panel === 1)
                    return "panel: multiple values";
                properties.panel = 1;
                error = $root.SC2APIProtocol.MultiPanel.verify(message.multi);
                if (error)
                    return "multi." + error;
            }
            if (message.cargo != null && message.hasOwnProperty("cargo")) {
                if (properties.panel === 1)
                    return "panel: multiple values";
                properties.panel = 1;
                error = $root.SC2APIProtocol.CargoPanel.verify(message.cargo);
                if (error)
                    return "cargo." + error;
            }
            if (message.production != null && message.hasOwnProperty("production")) {
                if (properties.panel === 1)
                    return "panel: multiple values";
                properties.panel = 1;
                error = $root.SC2APIProtocol.ProductionPanel.verify(message.production);
                if (error)
                    return "production." + error;
            }
            return null;
        };
        /**
         * Creates an ObservationUI message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ObservationUI} ObservationUI
         */
        ObservationUI.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ObservationUI)
                return object;
            var message = new $root.SC2APIProtocol.ObservationUI();
            if (object.groups) {
                if (!Array.isArray(object.groups))
                    throw TypeError(".SC2APIProtocol.ObservationUI.groups: array expected");
                message.groups = [];
                for (var i = 0; i < object.groups.length; ++i) {
                    if (typeof object.groups[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ObservationUI.groups: object expected");
                    message.groups[i] = $root.SC2APIProtocol.ControlGroup.fromObject(object.groups[i]);
                }
            }
            if (object.single != null) {
                if (typeof object.single !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationUI.single: object expected");
                message.single = $root.SC2APIProtocol.SinglePanel.fromObject(object.single);
            }
            if (object.multi != null) {
                if (typeof object.multi !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationUI.multi: object expected");
                message.multi = $root.SC2APIProtocol.MultiPanel.fromObject(object.multi);
            }
            if (object.cargo != null) {
                if (typeof object.cargo !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationUI.cargo: object expected");
                message.cargo = $root.SC2APIProtocol.CargoPanel.fromObject(object.cargo);
            }
            if (object.production != null) {
                if (typeof object.production !== "object")
                    throw TypeError(".SC2APIProtocol.ObservationUI.production: object expected");
                message.production = $root.SC2APIProtocol.ProductionPanel.fromObject(object.production);
            }
            return message;
        };
        /**
         * Creates a plain object from an ObservationUI message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ObservationUI
         * @static
         * @param {SC2APIProtocol.ObservationUI} message ObservationUI
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ObservationUI.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groups = [];
            if (message.groups && message.groups.length) {
                object.groups = [];
                for (var j = 0; j < message.groups.length; ++j)
                    object.groups[j] = $root.SC2APIProtocol.ControlGroup.toObject(message.groups[j], options);
            }
            if (message.single != null && message.hasOwnProperty("single")) {
                object.single = $root.SC2APIProtocol.SinglePanel.toObject(message.single, options);
                if (options.oneofs)
                    object.panel = "single";
            }
            if (message.multi != null && message.hasOwnProperty("multi")) {
                object.multi = $root.SC2APIProtocol.MultiPanel.toObject(message.multi, options);
                if (options.oneofs)
                    object.panel = "multi";
            }
            if (message.cargo != null && message.hasOwnProperty("cargo")) {
                object.cargo = $root.SC2APIProtocol.CargoPanel.toObject(message.cargo, options);
                if (options.oneofs)
                    object.panel = "cargo";
            }
            if (message.production != null && message.hasOwnProperty("production")) {
                object.production = $root.SC2APIProtocol.ProductionPanel.toObject(message.production, options);
                if (options.oneofs)
                    object.panel = "production";
            }
            return object;
        };
        /**
         * Converts this ObservationUI to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ObservationUI
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ObservationUI.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ObservationUI;
    })();
    SC2APIProtocol.ControlGroup = (function () {
        /**
         * Properties of a ControlGroup.
         * @memberof SC2APIProtocol
         * @interface IControlGroup
         * @property {number} [controlGroupIndex] ControlGroup controlGroupIndex
         * @property {number} [leaderUnitType] ControlGroup leaderUnitType
         * @property {number} [count] ControlGroup count
         */
        /**
         * Constructs a new ControlGroup.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ControlGroup.
         * @constructor
         * @param {SC2APIProtocol.IControlGroup=} [properties] Properties to set
         */
        function ControlGroup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ControlGroup controlGroupIndex.
         * @member {number}controlGroupIndex
         * @memberof SC2APIProtocol.ControlGroup
         * @instance
         */
        ControlGroup.prototype.controlGroupIndex = 0;
        /**
         * ControlGroup leaderUnitType.
         * @member {number}leaderUnitType
         * @memberof SC2APIProtocol.ControlGroup
         * @instance
         */
        ControlGroup.prototype.leaderUnitType = 0;
        /**
         * ControlGroup count.
         * @member {number}count
         * @memberof SC2APIProtocol.ControlGroup
         * @instance
         */
        ControlGroup.prototype.count = 0;
        /**
         * Creates a new ControlGroup instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {SC2APIProtocol.IControlGroup=} [properties] Properties to set
         * @returns {SC2APIProtocol.ControlGroup} ControlGroup instance
         */
        ControlGroup.create = function create(properties) {
            return new ControlGroup(properties);
        };
        /**
         * Encodes the specified ControlGroup message. Does not implicitly {@link SC2APIProtocol.ControlGroup.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {SC2APIProtocol.IControlGroup} message ControlGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ControlGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.controlGroupIndex);
            if (message.leaderUnitType != null && message.hasOwnProperty("leaderUnitType"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.leaderUnitType);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.count);
            return writer;
        };
        /**
         * Encodes the specified ControlGroup message, length delimited. Does not implicitly {@link SC2APIProtocol.ControlGroup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {SC2APIProtocol.IControlGroup} message ControlGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ControlGroup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ControlGroup message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ControlGroup} ControlGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ControlGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ControlGroup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.controlGroupIndex = reader.uint32();
                        break;
                    case 2:
                        message.leaderUnitType = reader.uint32();
                        break;
                    case 3:
                        message.count = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ControlGroup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ControlGroup} ControlGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ControlGroup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ControlGroup message.
         * @function verify
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ControlGroup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                if (!$util.isInteger(message.controlGroupIndex))
                    return "controlGroupIndex: integer expected";
            if (message.leaderUnitType != null && message.hasOwnProperty("leaderUnitType"))
                if (!$util.isInteger(message.leaderUnitType))
                    return "leaderUnitType: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };
        /**
         * Creates a ControlGroup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ControlGroup} ControlGroup
         */
        ControlGroup.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ControlGroup)
                return object;
            var message = new $root.SC2APIProtocol.ControlGroup();
            if (object.controlGroupIndex != null)
                message.controlGroupIndex = object.controlGroupIndex >>> 0;
            if (object.leaderUnitType != null)
                message.leaderUnitType = object.leaderUnitType >>> 0;
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };
        /**
         * Creates a plain object from a ControlGroup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ControlGroup
         * @static
         * @param {SC2APIProtocol.ControlGroup} message ControlGroup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ControlGroup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.controlGroupIndex = 0;
                object.leaderUnitType = 0;
                object.count = 0;
            }
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                object.controlGroupIndex = message.controlGroupIndex;
            if (message.leaderUnitType != null && message.hasOwnProperty("leaderUnitType"))
                object.leaderUnitType = message.leaderUnitType;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };
        /**
         * Converts this ControlGroup to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ControlGroup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ControlGroup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ControlGroup;
    })();
    SC2APIProtocol.UnitInfo = (function () {
        /**
         * Properties of an UnitInfo.
         * @memberof SC2APIProtocol
         * @interface IUnitInfo
         * @property {number} [unitType] UnitInfo unitType
         * @property {number} [playerRelative] UnitInfo playerRelative
         * @property {number} [health] UnitInfo health
         * @property {number} [shields] UnitInfo shields
         * @property {number} [energy] UnitInfo energy
         * @property {number} [transportSlotsTaken] UnitInfo transportSlotsTaken
         * @property {number} [buildProgress] UnitInfo buildProgress
         * @property {SC2APIProtocol.IUnitInfo} [addOn] UnitInfo addOn
         */
        /**
         * Constructs a new UnitInfo.
         * @memberof SC2APIProtocol
         * @classdesc Represents an UnitInfo.
         * @constructor
         * @param {SC2APIProtocol.IUnitInfo=} [properties] Properties to set
         */
        function UnitInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * UnitInfo unitType.
         * @member {number}unitType
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.unitType = 0;
        /**
         * UnitInfo playerRelative.
         * @member {number}playerRelative
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.playerRelative = 0;
        /**
         * UnitInfo health.
         * @member {number}health
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.health = 0;
        /**
         * UnitInfo shields.
         * @member {number}shields
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.shields = 0;
        /**
         * UnitInfo energy.
         * @member {number}energy
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.energy = 0;
        /**
         * UnitInfo transportSlotsTaken.
         * @member {number}transportSlotsTaken
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.transportSlotsTaken = 0;
        /**
         * UnitInfo buildProgress.
         * @member {number}buildProgress
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.buildProgress = 0;
        /**
         * UnitInfo addOn.
         * @member {(SC2APIProtocol.IUnitInfo|null|undefined)}addOn
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         */
        UnitInfo.prototype.addOn = null;
        /**
         * Creates a new UnitInfo instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {SC2APIProtocol.IUnitInfo=} [properties] Properties to set
         * @returns {SC2APIProtocol.UnitInfo} UnitInfo instance
         */
        UnitInfo.create = function create(properties) {
            return new UnitInfo(properties);
        };
        /**
         * Encodes the specified UnitInfo message. Does not implicitly {@link SC2APIProtocol.UnitInfo.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {SC2APIProtocol.IUnitInfo} message UnitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.unitType);
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.playerRelative);
            if (message.health != null && message.hasOwnProperty("health"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.health);
            if (message.shields != null && message.hasOwnProperty("shields"))
                writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.shields);
            if (message.energy != null && message.hasOwnProperty("energy"))
                writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.energy);
            if (message.transportSlotsTaken != null && message.hasOwnProperty("transportSlotsTaken"))
                writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.transportSlotsTaken);
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                writer.uint32(/* id 7, wireType 5 =*/ 61).float(message.buildProgress);
            if (message.addOn != null && message.hasOwnProperty("addOn"))
                $root.SC2APIProtocol.UnitInfo.encode(message.addOn, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified UnitInfo message, length delimited. Does not implicitly {@link SC2APIProtocol.UnitInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {SC2APIProtocol.IUnitInfo} message UnitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnitInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an UnitInfo message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.UnitInfo} UnitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.UnitInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitType = reader.uint32();
                        break;
                    case 2:
                        message.playerRelative = reader.uint32();
                        break;
                    case 3:
                        message.health = reader.int32();
                        break;
                    case 4:
                        message.shields = reader.int32();
                        break;
                    case 5:
                        message.energy = reader.int32();
                        break;
                    case 6:
                        message.transportSlotsTaken = reader.int32();
                        break;
                    case 7:
                        message.buildProgress = reader.float();
                        break;
                    case 8:
                        message.addOn = $root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an UnitInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.UnitInfo} UnitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnitInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an UnitInfo message.
         * @function verify
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnitInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                if (!$util.isInteger(message.unitType))
                    return "unitType: integer expected";
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                if (!$util.isInteger(message.playerRelative))
                    return "playerRelative: integer expected";
            if (message.health != null && message.hasOwnProperty("health"))
                if (!$util.isInteger(message.health))
                    return "health: integer expected";
            if (message.shields != null && message.hasOwnProperty("shields"))
                if (!$util.isInteger(message.shields))
                    return "shields: integer expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (!$util.isInteger(message.energy))
                    return "energy: integer expected";
            if (message.transportSlotsTaken != null && message.hasOwnProperty("transportSlotsTaken"))
                if (!$util.isInteger(message.transportSlotsTaken))
                    return "transportSlotsTaken: integer expected";
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                if (typeof message.buildProgress !== "number")
                    return "buildProgress: number expected";
            if (message.addOn != null && message.hasOwnProperty("addOn")) {
                var error = $root.SC2APIProtocol.UnitInfo.verify(message.addOn);
                if (error)
                    return "addOn." + error;
            }
            return null;
        };
        /**
         * Creates an UnitInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.UnitInfo} UnitInfo
         */
        UnitInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.UnitInfo)
                return object;
            var message = new $root.SC2APIProtocol.UnitInfo();
            if (object.unitType != null)
                message.unitType = object.unitType >>> 0;
            if (object.playerRelative != null)
                message.playerRelative = object.playerRelative >>> 0;
            if (object.health != null)
                message.health = object.health | 0;
            if (object.shields != null)
                message.shields = object.shields | 0;
            if (object.energy != null)
                message.energy = object.energy | 0;
            if (object.transportSlotsTaken != null)
                message.transportSlotsTaken = object.transportSlotsTaken | 0;
            if (object.buildProgress != null)
                message.buildProgress = Number(object.buildProgress);
            if (object.addOn != null) {
                if (typeof object.addOn !== "object")
                    throw TypeError(".SC2APIProtocol.UnitInfo.addOn: object expected");
                message.addOn = $root.SC2APIProtocol.UnitInfo.fromObject(object.addOn);
            }
            return message;
        };
        /**
         * Creates a plain object from an UnitInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.UnitInfo
         * @static
         * @param {SC2APIProtocol.UnitInfo} message UnitInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnitInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unitType = 0;
                object.playerRelative = 0;
                object.health = 0;
                object.shields = 0;
                object.energy = 0;
                object.transportSlotsTaken = 0;
                object.buildProgress = 0;
                object.addOn = null;
            }
            if (message.unitType != null && message.hasOwnProperty("unitType"))
                object.unitType = message.unitType;
            if (message.playerRelative != null && message.hasOwnProperty("playerRelative"))
                object.playerRelative = message.playerRelative;
            if (message.health != null && message.hasOwnProperty("health"))
                object.health = message.health;
            if (message.shields != null && message.hasOwnProperty("shields"))
                object.shields = message.shields;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = message.energy;
            if (message.transportSlotsTaken != null && message.hasOwnProperty("transportSlotsTaken"))
                object.transportSlotsTaken = message.transportSlotsTaken;
            if (message.buildProgress != null && message.hasOwnProperty("buildProgress"))
                object.buildProgress = options.json && !isFinite(message.buildProgress) ? String(message.buildProgress) : message.buildProgress;
            if (message.addOn != null && message.hasOwnProperty("addOn"))
                object.addOn = $root.SC2APIProtocol.UnitInfo.toObject(message.addOn, options);
            return object;
        };
        /**
         * Converts this UnitInfo to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.UnitInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnitInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnitInfo;
    })();
    SC2APIProtocol.SinglePanel = (function () {
        /**
         * Properties of a SinglePanel.
         * @memberof SC2APIProtocol
         * @interface ISinglePanel
         * @property {SC2APIProtocol.IUnitInfo} [unit] SinglePanel unit
         */
        /**
         * Constructs a new SinglePanel.
         * @memberof SC2APIProtocol
         * @classdesc Represents a SinglePanel.
         * @constructor
         * @param {SC2APIProtocol.ISinglePanel=} [properties] Properties to set
         */
        function SinglePanel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SinglePanel unit.
         * @member {(SC2APIProtocol.IUnitInfo|null|undefined)}unit
         * @memberof SC2APIProtocol.SinglePanel
         * @instance
         */
        SinglePanel.prototype.unit = null;
        /**
         * Creates a new SinglePanel instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {SC2APIProtocol.ISinglePanel=} [properties] Properties to set
         * @returns {SC2APIProtocol.SinglePanel} SinglePanel instance
         */
        SinglePanel.create = function create(properties) {
            return new SinglePanel(properties);
        };
        /**
         * Encodes the specified SinglePanel message. Does not implicitly {@link SC2APIProtocol.SinglePanel.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {SC2APIProtocol.ISinglePanel} message SinglePanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SinglePanel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unit != null && message.hasOwnProperty("unit"))
                $root.SC2APIProtocol.UnitInfo.encode(message.unit, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified SinglePanel message, length delimited. Does not implicitly {@link SC2APIProtocol.SinglePanel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {SC2APIProtocol.ISinglePanel} message SinglePanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SinglePanel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a SinglePanel message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.SinglePanel} SinglePanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SinglePanel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.SinglePanel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unit = $root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a SinglePanel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.SinglePanel} SinglePanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SinglePanel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a SinglePanel message.
         * @function verify
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SinglePanel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unit != null && message.hasOwnProperty("unit")) {
                var error = $root.SC2APIProtocol.UnitInfo.verify(message.unit);
                if (error)
                    return "unit." + error;
            }
            return null;
        };
        /**
         * Creates a SinglePanel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.SinglePanel} SinglePanel
         */
        SinglePanel.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.SinglePanel)
                return object;
            var message = new $root.SC2APIProtocol.SinglePanel();
            if (object.unit != null) {
                if (typeof object.unit !== "object")
                    throw TypeError(".SC2APIProtocol.SinglePanel.unit: object expected");
                message.unit = $root.SC2APIProtocol.UnitInfo.fromObject(object.unit);
            }
            return message;
        };
        /**
         * Creates a plain object from a SinglePanel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.SinglePanel
         * @static
         * @param {SC2APIProtocol.SinglePanel} message SinglePanel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SinglePanel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.unit = null;
            if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit = $root.SC2APIProtocol.UnitInfo.toObject(message.unit, options);
            return object;
        };
        /**
         * Converts this SinglePanel to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.SinglePanel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SinglePanel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SinglePanel;
    })();
    SC2APIProtocol.MultiPanel = (function () {
        /**
         * Properties of a MultiPanel.
         * @memberof SC2APIProtocol
         * @interface IMultiPanel
         * @property {Array.<SC2APIProtocol.IUnitInfo>} [units] MultiPanel units
         */
        /**
         * Constructs a new MultiPanel.
         * @memberof SC2APIProtocol
         * @classdesc Represents a MultiPanel.
         * @constructor
         * @param {SC2APIProtocol.IMultiPanel=} [properties] Properties to set
         */
        function MultiPanel(properties) {
            this.units = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MultiPanel units.
         * @member {Array.<SC2APIProtocol.IUnitInfo>}units
         * @memberof SC2APIProtocol.MultiPanel
         * @instance
         */
        MultiPanel.prototype.units = $util.emptyArray;
        /**
         * Creates a new MultiPanel instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {SC2APIProtocol.IMultiPanel=} [properties] Properties to set
         * @returns {SC2APIProtocol.MultiPanel} MultiPanel instance
         */
        MultiPanel.create = function create(properties) {
            return new MultiPanel(properties);
        };
        /**
         * Encodes the specified MultiPanel message. Does not implicitly {@link SC2APIProtocol.MultiPanel.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {SC2APIProtocol.IMultiPanel} message MultiPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiPanel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.units != null && message.units.length)
                for (var i = 0; i < message.units.length; ++i)
                    $root.SC2APIProtocol.UnitInfo.encode(message.units[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified MultiPanel message, length delimited. Does not implicitly {@link SC2APIProtocol.MultiPanel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {SC2APIProtocol.IMultiPanel} message MultiPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiPanel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a MultiPanel message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.MultiPanel} MultiPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiPanel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.MultiPanel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.units && message.units.length))
                            message.units = [];
                        message.units.push($root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a MultiPanel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.MultiPanel} MultiPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiPanel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a MultiPanel message.
         * @function verify
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiPanel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.units != null && message.hasOwnProperty("units")) {
                if (!Array.isArray(message.units))
                    return "units: array expected";
                for (var i = 0; i < message.units.length; ++i) {
                    var error = $root.SC2APIProtocol.UnitInfo.verify(message.units[i]);
                    if (error)
                        return "units." + error;
                }
            }
            return null;
        };
        /**
         * Creates a MultiPanel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.MultiPanel} MultiPanel
         */
        MultiPanel.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.MultiPanel)
                return object;
            var message = new $root.SC2APIProtocol.MultiPanel();
            if (object.units) {
                if (!Array.isArray(object.units))
                    throw TypeError(".SC2APIProtocol.MultiPanel.units: array expected");
                message.units = [];
                for (var i = 0; i < object.units.length; ++i) {
                    if (typeof object.units[i] !== "object")
                        throw TypeError(".SC2APIProtocol.MultiPanel.units: object expected");
                    message.units[i] = $root.SC2APIProtocol.UnitInfo.fromObject(object.units[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a MultiPanel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.MultiPanel
         * @static
         * @param {SC2APIProtocol.MultiPanel} message MultiPanel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiPanel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.units = [];
            if (message.units && message.units.length) {
                object.units = [];
                for (var j = 0; j < message.units.length; ++j)
                    object.units[j] = $root.SC2APIProtocol.UnitInfo.toObject(message.units[j], options);
            }
            return object;
        };
        /**
         * Converts this MultiPanel to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.MultiPanel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiPanel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return MultiPanel;
    })();
    SC2APIProtocol.CargoPanel = (function () {
        /**
         * Properties of a CargoPanel.
         * @memberof SC2APIProtocol
         * @interface ICargoPanel
         * @property {SC2APIProtocol.IUnitInfo} [unit] CargoPanel unit
         * @property {Array.<SC2APIProtocol.IUnitInfo>} [passengers] CargoPanel passengers
         * @property {number} [slotsAvailable] CargoPanel slotsAvailable
         */
        /**
         * Constructs a new CargoPanel.
         * @memberof SC2APIProtocol
         * @classdesc Represents a CargoPanel.
         * @constructor
         * @param {SC2APIProtocol.ICargoPanel=} [properties] Properties to set
         */
        function CargoPanel(properties) {
            this.passengers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CargoPanel unit.
         * @member {(SC2APIProtocol.IUnitInfo|null|undefined)}unit
         * @memberof SC2APIProtocol.CargoPanel
         * @instance
         */
        CargoPanel.prototype.unit = null;
        /**
         * CargoPanel passengers.
         * @member {Array.<SC2APIProtocol.IUnitInfo>}passengers
         * @memberof SC2APIProtocol.CargoPanel
         * @instance
         */
        CargoPanel.prototype.passengers = $util.emptyArray;
        /**
         * CargoPanel slotsAvailable.
         * @member {number}slotsAvailable
         * @memberof SC2APIProtocol.CargoPanel
         * @instance
         */
        CargoPanel.prototype.slotsAvailable = 0;
        /**
         * Creates a new CargoPanel instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {SC2APIProtocol.ICargoPanel=} [properties] Properties to set
         * @returns {SC2APIProtocol.CargoPanel} CargoPanel instance
         */
        CargoPanel.create = function create(properties) {
            return new CargoPanel(properties);
        };
        /**
         * Encodes the specified CargoPanel message. Does not implicitly {@link SC2APIProtocol.CargoPanel.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {SC2APIProtocol.ICargoPanel} message CargoPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CargoPanel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unit != null && message.hasOwnProperty("unit"))
                $root.SC2APIProtocol.UnitInfo.encode(message.unit, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.passengers != null && message.passengers.length)
                for (var i = 0; i < message.passengers.length; ++i)
                    $root.SC2APIProtocol.UnitInfo.encode(message.passengers[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.slotsAvailable != null && message.hasOwnProperty("slotsAvailable"))
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.slotsAvailable);
            return writer;
        };
        /**
         * Encodes the specified CargoPanel message, length delimited. Does not implicitly {@link SC2APIProtocol.CargoPanel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {SC2APIProtocol.ICargoPanel} message CargoPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CargoPanel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a CargoPanel message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.CargoPanel} CargoPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CargoPanel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.CargoPanel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unit = $root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.passengers && message.passengers.length))
                            message.passengers = [];
                        message.passengers.push($root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.slotsAvailable = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a CargoPanel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.CargoPanel} CargoPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CargoPanel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a CargoPanel message.
         * @function verify
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CargoPanel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unit != null && message.hasOwnProperty("unit")) {
                var error = $root.SC2APIProtocol.UnitInfo.verify(message.unit);
                if (error)
                    return "unit." + error;
            }
            if (message.passengers != null && message.hasOwnProperty("passengers")) {
                if (!Array.isArray(message.passengers))
                    return "passengers: array expected";
                for (var i = 0; i < message.passengers.length; ++i) {
                    error = $root.SC2APIProtocol.UnitInfo.verify(message.passengers[i]);
                    if (error)
                        return "passengers." + error;
                }
            }
            if (message.slotsAvailable != null && message.hasOwnProperty("slotsAvailable"))
                if (!$util.isInteger(message.slotsAvailable))
                    return "slotsAvailable: integer expected";
            return null;
        };
        /**
         * Creates a CargoPanel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.CargoPanel} CargoPanel
         */
        CargoPanel.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.CargoPanel)
                return object;
            var message = new $root.SC2APIProtocol.CargoPanel();
            if (object.unit != null) {
                if (typeof object.unit !== "object")
                    throw TypeError(".SC2APIProtocol.CargoPanel.unit: object expected");
                message.unit = $root.SC2APIProtocol.UnitInfo.fromObject(object.unit);
            }
            if (object.passengers) {
                if (!Array.isArray(object.passengers))
                    throw TypeError(".SC2APIProtocol.CargoPanel.passengers: array expected");
                message.passengers = [];
                for (var i = 0; i < object.passengers.length; ++i) {
                    if (typeof object.passengers[i] !== "object")
                        throw TypeError(".SC2APIProtocol.CargoPanel.passengers: object expected");
                    message.passengers[i] = $root.SC2APIProtocol.UnitInfo.fromObject(object.passengers[i]);
                }
            }
            if (object.slotsAvailable != null)
                message.slotsAvailable = object.slotsAvailable | 0;
            return message;
        };
        /**
         * Creates a plain object from a CargoPanel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.CargoPanel
         * @static
         * @param {SC2APIProtocol.CargoPanel} message CargoPanel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CargoPanel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.passengers = [];
            if (options.defaults) {
                object.unit = null;
                object.slotsAvailable = 0;
            }
            if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit = $root.SC2APIProtocol.UnitInfo.toObject(message.unit, options);
            if (message.passengers && message.passengers.length) {
                object.passengers = [];
                for (var j = 0; j < message.passengers.length; ++j)
                    object.passengers[j] = $root.SC2APIProtocol.UnitInfo.toObject(message.passengers[j], options);
            }
            if (message.slotsAvailable != null && message.hasOwnProperty("slotsAvailable"))
                object.slotsAvailable = message.slotsAvailable;
            return object;
        };
        /**
         * Converts this CargoPanel to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.CargoPanel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CargoPanel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CargoPanel;
    })();
    SC2APIProtocol.ProductionPanel = (function () {
        /**
         * Properties of a ProductionPanel.
         * @memberof SC2APIProtocol
         * @interface IProductionPanel
         * @property {SC2APIProtocol.IUnitInfo} [unit] ProductionPanel unit
         * @property {Array.<SC2APIProtocol.IUnitInfo>} [buildQueue] ProductionPanel buildQueue
         */
        /**
         * Constructs a new ProductionPanel.
         * @memberof SC2APIProtocol
         * @classdesc Represents a ProductionPanel.
         * @constructor
         * @param {SC2APIProtocol.IProductionPanel=} [properties] Properties to set
         */
        function ProductionPanel(properties) {
            this.buildQueue = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ProductionPanel unit.
         * @member {(SC2APIProtocol.IUnitInfo|null|undefined)}unit
         * @memberof SC2APIProtocol.ProductionPanel
         * @instance
         */
        ProductionPanel.prototype.unit = null;
        /**
         * ProductionPanel buildQueue.
         * @member {Array.<SC2APIProtocol.IUnitInfo>}buildQueue
         * @memberof SC2APIProtocol.ProductionPanel
         * @instance
         */
        ProductionPanel.prototype.buildQueue = $util.emptyArray;
        /**
         * Creates a new ProductionPanel instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {SC2APIProtocol.IProductionPanel=} [properties] Properties to set
         * @returns {SC2APIProtocol.ProductionPanel} ProductionPanel instance
         */
        ProductionPanel.create = function create(properties) {
            return new ProductionPanel(properties);
        };
        /**
         * Encodes the specified ProductionPanel message. Does not implicitly {@link SC2APIProtocol.ProductionPanel.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {SC2APIProtocol.IProductionPanel} message ProductionPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductionPanel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unit != null && message.hasOwnProperty("unit"))
                $root.SC2APIProtocol.UnitInfo.encode(message.unit, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.buildQueue != null && message.buildQueue.length)
                for (var i = 0; i < message.buildQueue.length; ++i)
                    $root.SC2APIProtocol.UnitInfo.encode(message.buildQueue[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ProductionPanel message, length delimited. Does not implicitly {@link SC2APIProtocol.ProductionPanel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {SC2APIProtocol.IProductionPanel} message ProductionPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductionPanel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes a ProductionPanel message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ProductionPanel} ProductionPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductionPanel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ProductionPanel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unit = $root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.buildQueue && message.buildQueue.length))
                            message.buildQueue = [];
                        message.buildQueue.push($root.SC2APIProtocol.UnitInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes a ProductionPanel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ProductionPanel} ProductionPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductionPanel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies a ProductionPanel message.
         * @function verify
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductionPanel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unit != null && message.hasOwnProperty("unit")) {
                var error = $root.SC2APIProtocol.UnitInfo.verify(message.unit);
                if (error)
                    return "unit." + error;
            }
            if (message.buildQueue != null && message.hasOwnProperty("buildQueue")) {
                if (!Array.isArray(message.buildQueue))
                    return "buildQueue: array expected";
                for (var i = 0; i < message.buildQueue.length; ++i) {
                    error = $root.SC2APIProtocol.UnitInfo.verify(message.buildQueue[i]);
                    if (error)
                        return "buildQueue." + error;
                }
            }
            return null;
        };
        /**
         * Creates a ProductionPanel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ProductionPanel} ProductionPanel
         */
        ProductionPanel.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ProductionPanel)
                return object;
            var message = new $root.SC2APIProtocol.ProductionPanel();
            if (object.unit != null) {
                if (typeof object.unit !== "object")
                    throw TypeError(".SC2APIProtocol.ProductionPanel.unit: object expected");
                message.unit = $root.SC2APIProtocol.UnitInfo.fromObject(object.unit);
            }
            if (object.buildQueue) {
                if (!Array.isArray(object.buildQueue))
                    throw TypeError(".SC2APIProtocol.ProductionPanel.buildQueue: array expected");
                message.buildQueue = [];
                for (var i = 0; i < object.buildQueue.length; ++i) {
                    if (typeof object.buildQueue[i] !== "object")
                        throw TypeError(".SC2APIProtocol.ProductionPanel.buildQueue: object expected");
                    message.buildQueue[i] = $root.SC2APIProtocol.UnitInfo.fromObject(object.buildQueue[i]);
                }
            }
            return message;
        };
        /**
         * Creates a plain object from a ProductionPanel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ProductionPanel
         * @static
         * @param {SC2APIProtocol.ProductionPanel} message ProductionPanel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProductionPanel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buildQueue = [];
            if (options.defaults)
                object.unit = null;
            if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit = $root.SC2APIProtocol.UnitInfo.toObject(message.unit, options);
            if (message.buildQueue && message.buildQueue.length) {
                object.buildQueue = [];
                for (var j = 0; j < message.buildQueue.length; ++j)
                    object.buildQueue[j] = $root.SC2APIProtocol.UnitInfo.toObject(message.buildQueue[j], options);
            }
            return object;
        };
        /**
         * Converts this ProductionPanel to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ProductionPanel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProductionPanel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProductionPanel;
    })();
    SC2APIProtocol.ActionUI = (function () {
        /**
         * Properties of an ActionUI.
         * @memberof SC2APIProtocol
         * @interface IActionUI
         * @property {SC2APIProtocol.IActionControlGroup} [controlGroup] ActionUI controlGroup
         * @property {SC2APIProtocol.IActionSelectArmy} [selectArmy] ActionUI selectArmy
         * @property {SC2APIProtocol.IActionSelectWarpGates} [selectWarpGates] ActionUI selectWarpGates
         * @property {SC2APIProtocol.IActionSelectLarva} [selectLarva] ActionUI selectLarva
         * @property {SC2APIProtocol.IActionSelectIdleWorker} [selectIdleWorker] ActionUI selectIdleWorker
         * @property {SC2APIProtocol.IActionMultiPanel} [multiPanel] ActionUI multiPanel
         * @property {SC2APIProtocol.IActionCargoPanelUnload} [cargoPanel] ActionUI cargoPanel
         * @property {SC2APIProtocol.IActionProductionPanelRemoveFromQueue} [productionPanel] ActionUI productionPanel
         * @property {SC2APIProtocol.IActionToggleAutocast} [toggleAutocast] ActionUI toggleAutocast
         */
        /**
         * Constructs a new ActionUI.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionUI.
         * @constructor
         * @param {SC2APIProtocol.IActionUI=} [properties] Properties to set
         */
        function ActionUI(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionUI controlGroup.
         * @member {(SC2APIProtocol.IActionControlGroup|null|undefined)}controlGroup
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.controlGroup = null;
        /**
         * ActionUI selectArmy.
         * @member {(SC2APIProtocol.IActionSelectArmy|null|undefined)}selectArmy
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.selectArmy = null;
        /**
         * ActionUI selectWarpGates.
         * @member {(SC2APIProtocol.IActionSelectWarpGates|null|undefined)}selectWarpGates
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.selectWarpGates = null;
        /**
         * ActionUI selectLarva.
         * @member {(SC2APIProtocol.IActionSelectLarva|null|undefined)}selectLarva
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.selectLarva = null;
        /**
         * ActionUI selectIdleWorker.
         * @member {(SC2APIProtocol.IActionSelectIdleWorker|null|undefined)}selectIdleWorker
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.selectIdleWorker = null;
        /**
         * ActionUI multiPanel.
         * @member {(SC2APIProtocol.IActionMultiPanel|null|undefined)}multiPanel
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.multiPanel = null;
        /**
         * ActionUI cargoPanel.
         * @member {(SC2APIProtocol.IActionCargoPanelUnload|null|undefined)}cargoPanel
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.cargoPanel = null;
        /**
         * ActionUI productionPanel.
         * @member {(SC2APIProtocol.IActionProductionPanelRemoveFromQueue|null|undefined)}productionPanel
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.productionPanel = null;
        /**
         * ActionUI toggleAutocast.
         * @member {(SC2APIProtocol.IActionToggleAutocast|null|undefined)}toggleAutocast
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        ActionUI.prototype.toggleAutocast = null;
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
        /**
         * ActionUI action.
         * @member {string|undefined} action
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         */
        Object.defineProperty(ActionUI.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["controlGroup", "selectArmy", "selectWarpGates", "selectLarva", "selectIdleWorker", "multiPanel", "cargoPanel", "productionPanel", "toggleAutocast"]),
            set: $util.oneOfSetter($oneOfFields)
        });
        /**
         * Creates a new ActionUI instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {SC2APIProtocol.IActionUI=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionUI} ActionUI instance
         */
        ActionUI.create = function create(properties) {
            return new ActionUI(properties);
        };
        /**
         * Encodes the specified ActionUI message. Does not implicitly {@link SC2APIProtocol.ActionUI.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {SC2APIProtocol.IActionUI} message ActionUI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionUI.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.controlGroup != null && message.hasOwnProperty("controlGroup"))
                $root.SC2APIProtocol.ActionControlGroup.encode(message.controlGroup, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.selectArmy != null && message.hasOwnProperty("selectArmy"))
                $root.SC2APIProtocol.ActionSelectArmy.encode(message.selectArmy, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            if (message.selectWarpGates != null && message.hasOwnProperty("selectWarpGates"))
                $root.SC2APIProtocol.ActionSelectWarpGates.encode(message.selectWarpGates, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
            if (message.selectLarva != null && message.hasOwnProperty("selectLarva"))
                $root.SC2APIProtocol.ActionSelectLarva.encode(message.selectLarva, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
            if (message.selectIdleWorker != null && message.hasOwnProperty("selectIdleWorker"))
                $root.SC2APIProtocol.ActionSelectIdleWorker.encode(message.selectIdleWorker, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
            if (message.multiPanel != null && message.hasOwnProperty("multiPanel"))
                $root.SC2APIProtocol.ActionMultiPanel.encode(message.multiPanel, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
            if (message.cargoPanel != null && message.hasOwnProperty("cargoPanel"))
                $root.SC2APIProtocol.ActionCargoPanelUnload.encode(message.cargoPanel, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
            if (message.productionPanel != null && message.hasOwnProperty("productionPanel"))
                $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.encode(message.productionPanel, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast"))
                $root.SC2APIProtocol.ActionToggleAutocast.encode(message.toggleAutocast, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
            return writer;
        };
        /**
         * Encodes the specified ActionUI message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionUI.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {SC2APIProtocol.IActionUI} message ActionUI message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionUI.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionUI message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionUI} ActionUI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionUI.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionUI();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.controlGroup = $root.SC2APIProtocol.ActionControlGroup.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.selectArmy = $root.SC2APIProtocol.ActionSelectArmy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.selectWarpGates = $root.SC2APIProtocol.ActionSelectWarpGates.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.selectLarva = $root.SC2APIProtocol.ActionSelectLarva.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.selectIdleWorker = $root.SC2APIProtocol.ActionSelectIdleWorker.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.multiPanel = $root.SC2APIProtocol.ActionMultiPanel.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.cargoPanel = $root.SC2APIProtocol.ActionCargoPanelUnload.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.productionPanel = $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.toggleAutocast = $root.SC2APIProtocol.ActionToggleAutocast.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionUI message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionUI} ActionUI
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionUI.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionUI message.
         * @function verify
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionUI.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.controlGroup != null && message.hasOwnProperty("controlGroup")) {
                properties.action = 1;
                var error = $root.SC2APIProtocol.ActionControlGroup.verify(message.controlGroup);
                if (error)
                    return "controlGroup." + error;
            }
            if (message.selectArmy != null && message.hasOwnProperty("selectArmy")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSelectArmy.verify(message.selectArmy);
                if (error)
                    return "selectArmy." + error;
            }
            if (message.selectWarpGates != null && message.hasOwnProperty("selectWarpGates")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSelectWarpGates.verify(message.selectWarpGates);
                if (error)
                    return "selectWarpGates." + error;
            }
            if (message.selectLarva != null && message.hasOwnProperty("selectLarva")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSelectLarva.verify(message.selectLarva);
                if (error)
                    return "selectLarva." + error;
            }
            if (message.selectIdleWorker != null && message.hasOwnProperty("selectIdleWorker")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionSelectIdleWorker.verify(message.selectIdleWorker);
                if (error)
                    return "selectIdleWorker." + error;
            }
            if (message.multiPanel != null && message.hasOwnProperty("multiPanel")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionMultiPanel.verify(message.multiPanel);
                if (error)
                    return "multiPanel." + error;
            }
            if (message.cargoPanel != null && message.hasOwnProperty("cargoPanel")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionCargoPanelUnload.verify(message.cargoPanel);
                if (error)
                    return "cargoPanel." + error;
            }
            if (message.productionPanel != null && message.hasOwnProperty("productionPanel")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.verify(message.productionPanel);
                if (error)
                    return "productionPanel." + error;
            }
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                error = $root.SC2APIProtocol.ActionToggleAutocast.verify(message.toggleAutocast);
                if (error)
                    return "toggleAutocast." + error;
            }
            return null;
        };
        /**
         * Creates an ActionUI message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionUI} ActionUI
         */
        ActionUI.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionUI)
                return object;
            var message = new $root.SC2APIProtocol.ActionUI();
            if (object.controlGroup != null) {
                if (typeof object.controlGroup !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.controlGroup: object expected");
                message.controlGroup = $root.SC2APIProtocol.ActionControlGroup.fromObject(object.controlGroup);
            }
            if (object.selectArmy != null) {
                if (typeof object.selectArmy !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.selectArmy: object expected");
                message.selectArmy = $root.SC2APIProtocol.ActionSelectArmy.fromObject(object.selectArmy);
            }
            if (object.selectWarpGates != null) {
                if (typeof object.selectWarpGates !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.selectWarpGates: object expected");
                message.selectWarpGates = $root.SC2APIProtocol.ActionSelectWarpGates.fromObject(object.selectWarpGates);
            }
            if (object.selectLarva != null) {
                if (typeof object.selectLarva !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.selectLarva: object expected");
                message.selectLarva = $root.SC2APIProtocol.ActionSelectLarva.fromObject(object.selectLarva);
            }
            if (object.selectIdleWorker != null) {
                if (typeof object.selectIdleWorker !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.selectIdleWorker: object expected");
                message.selectIdleWorker = $root.SC2APIProtocol.ActionSelectIdleWorker.fromObject(object.selectIdleWorker);
            }
            if (object.multiPanel != null) {
                if (typeof object.multiPanel !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.multiPanel: object expected");
                message.multiPanel = $root.SC2APIProtocol.ActionMultiPanel.fromObject(object.multiPanel);
            }
            if (object.cargoPanel != null) {
                if (typeof object.cargoPanel !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.cargoPanel: object expected");
                message.cargoPanel = $root.SC2APIProtocol.ActionCargoPanelUnload.fromObject(object.cargoPanel);
            }
            if (object.productionPanel != null) {
                if (typeof object.productionPanel !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.productionPanel: object expected");
                message.productionPanel = $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.fromObject(object.productionPanel);
            }
            if (object.toggleAutocast != null) {
                if (typeof object.toggleAutocast !== "object")
                    throw TypeError(".SC2APIProtocol.ActionUI.toggleAutocast: object expected");
                message.toggleAutocast = $root.SC2APIProtocol.ActionToggleAutocast.fromObject(object.toggleAutocast);
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionUI message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionUI
         * @static
         * @param {SC2APIProtocol.ActionUI} message ActionUI
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionUI.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.controlGroup != null && message.hasOwnProperty("controlGroup")) {
                object.controlGroup = $root.SC2APIProtocol.ActionControlGroup.toObject(message.controlGroup, options);
                if (options.oneofs)
                    object.action = "controlGroup";
            }
            if (message.selectArmy != null && message.hasOwnProperty("selectArmy")) {
                object.selectArmy = $root.SC2APIProtocol.ActionSelectArmy.toObject(message.selectArmy, options);
                if (options.oneofs)
                    object.action = "selectArmy";
            }
            if (message.selectWarpGates != null && message.hasOwnProperty("selectWarpGates")) {
                object.selectWarpGates = $root.SC2APIProtocol.ActionSelectWarpGates.toObject(message.selectWarpGates, options);
                if (options.oneofs)
                    object.action = "selectWarpGates";
            }
            if (message.selectLarva != null && message.hasOwnProperty("selectLarva")) {
                object.selectLarva = $root.SC2APIProtocol.ActionSelectLarva.toObject(message.selectLarva, options);
                if (options.oneofs)
                    object.action = "selectLarva";
            }
            if (message.selectIdleWorker != null && message.hasOwnProperty("selectIdleWorker")) {
                object.selectIdleWorker = $root.SC2APIProtocol.ActionSelectIdleWorker.toObject(message.selectIdleWorker, options);
                if (options.oneofs)
                    object.action = "selectIdleWorker";
            }
            if (message.multiPanel != null && message.hasOwnProperty("multiPanel")) {
                object.multiPanel = $root.SC2APIProtocol.ActionMultiPanel.toObject(message.multiPanel, options);
                if (options.oneofs)
                    object.action = "multiPanel";
            }
            if (message.cargoPanel != null && message.hasOwnProperty("cargoPanel")) {
                object.cargoPanel = $root.SC2APIProtocol.ActionCargoPanelUnload.toObject(message.cargoPanel, options);
                if (options.oneofs)
                    object.action = "cargoPanel";
            }
            if (message.productionPanel != null && message.hasOwnProperty("productionPanel")) {
                object.productionPanel = $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue.toObject(message.productionPanel, options);
                if (options.oneofs)
                    object.action = "productionPanel";
            }
            if (message.toggleAutocast != null && message.hasOwnProperty("toggleAutocast")) {
                object.toggleAutocast = $root.SC2APIProtocol.ActionToggleAutocast.toObject(message.toggleAutocast, options);
                if (options.oneofs)
                    object.action = "toggleAutocast";
            }
            return object;
        };
        /**
         * Converts this ActionUI to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionUI
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionUI.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionUI;
    })();
    SC2APIProtocol.ActionControlGroup = (function () {
        /**
         * Properties of an ActionControlGroup.
         * @memberof SC2APIProtocol
         * @interface IActionControlGroup
         * @property {SC2APIProtocol.ActionControlGroup.ControlGroupAction} [action] ActionControlGroup action
         * @property {number} [controlGroupIndex] ActionControlGroup controlGroupIndex
         */
        /**
         * Constructs a new ActionControlGroup.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionControlGroup.
         * @constructor
         * @param {SC2APIProtocol.IActionControlGroup=} [properties] Properties to set
         */
        function ActionControlGroup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionControlGroup action.
         * @member {SC2APIProtocol.ActionControlGroup.ControlGroupAction}action
         * @memberof SC2APIProtocol.ActionControlGroup
         * @instance
         */
        ActionControlGroup.prototype.action = 1;
        /**
         * ActionControlGroup controlGroupIndex.
         * @member {number}controlGroupIndex
         * @memberof SC2APIProtocol.ActionControlGroup
         * @instance
         */
        ActionControlGroup.prototype.controlGroupIndex = 0;
        /**
         * Creates a new ActionControlGroup instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {SC2APIProtocol.IActionControlGroup=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionControlGroup} ActionControlGroup instance
         */
        ActionControlGroup.create = function create(properties) {
            return new ActionControlGroup(properties);
        };
        /**
         * Encodes the specified ActionControlGroup message. Does not implicitly {@link SC2APIProtocol.ActionControlGroup.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {SC2APIProtocol.IActionControlGroup} message ActionControlGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionControlGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.action);
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.controlGroupIndex);
            return writer;
        };
        /**
         * Encodes the specified ActionControlGroup message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionControlGroup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {SC2APIProtocol.IActionControlGroup} message ActionControlGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionControlGroup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionControlGroup message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionControlGroup} ActionControlGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionControlGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionControlGroup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.action = reader.int32();
                        break;
                    case 2:
                        message.controlGroupIndex = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionControlGroup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionControlGroup} ActionControlGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionControlGroup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionControlGroup message.
         * @function verify
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionControlGroup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                }
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                if (!$util.isInteger(message.controlGroupIndex))
                    return "controlGroupIndex: integer expected";
            return null;
        };
        /**
         * Creates an ActionControlGroup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionControlGroup} ActionControlGroup
         */
        ActionControlGroup.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionControlGroup)
                return object;
            var message = new $root.SC2APIProtocol.ActionControlGroup();
            switch (object.action) {
                case "Recall":
                case 1:
                    message.action = 1;
                    break;
                case "Set":
                case 2:
                    message.action = 2;
                    break;
                case "Append":
                case 3:
                    message.action = 3;
                    break;
                case "SetAndSteal":
                case 4:
                    message.action = 4;
                    break;
                case "AppendAndSteal":
                case 5:
                    message.action = 5;
                    break;
            }
            if (object.controlGroupIndex != null)
                message.controlGroupIndex = object.controlGroupIndex >>> 0;
            return message;
        };
        /**
         * Creates a plain object from an ActionControlGroup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionControlGroup
         * @static
         * @param {SC2APIProtocol.ActionControlGroup} message ActionControlGroup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionControlGroup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = options.enums === String ? "Recall" : 1;
                object.controlGroupIndex = 0;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.SC2APIProtocol.ActionControlGroup.ControlGroupAction[message.action] : message.action;
            if (message.controlGroupIndex != null && message.hasOwnProperty("controlGroupIndex"))
                object.controlGroupIndex = message.controlGroupIndex;
            return object;
        };
        /**
         * Converts this ActionControlGroup to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionControlGroup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionControlGroup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * ControlGroupAction enum.
         * @enum {string}
         * @property {number} Recall=1 Recall value
         * @property {number} Set=2 Set value
         * @property {number} Append=3 Append value
         * @property {number} SetAndSteal=4 SetAndSteal value
         * @property {number} AppendAndSteal=5 AppendAndSteal value
         */
        ActionControlGroup.ControlGroupAction = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Recall"] = 1;
            values[valuesById[2] = "Set"] = 2;
            values[valuesById[3] = "Append"] = 3;
            values[valuesById[4] = "SetAndSteal"] = 4;
            values[valuesById[5] = "AppendAndSteal"] = 5;
            return values;
        })();
        return ActionControlGroup;
    })();
    SC2APIProtocol.ActionSelectArmy = (function () {
        /**
         * Properties of an ActionSelectArmy.
         * @memberof SC2APIProtocol
         * @interface IActionSelectArmy
         * @property {boolean} [selectionAdd] ActionSelectArmy selectionAdd
         */
        /**
         * Constructs a new ActionSelectArmy.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSelectArmy.
         * @constructor
         * @param {SC2APIProtocol.IActionSelectArmy=} [properties] Properties to set
         */
        function ActionSelectArmy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSelectArmy selectionAdd.
         * @member {boolean}selectionAdd
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @instance
         */
        ActionSelectArmy.prototype.selectionAdd = false;
        /**
         * Creates a new ActionSelectArmy instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {SC2APIProtocol.IActionSelectArmy=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSelectArmy} ActionSelectArmy instance
         */
        ActionSelectArmy.create = function create(properties) {
            return new ActionSelectArmy(properties);
        };
        /**
         * Encodes the specified ActionSelectArmy message. Does not implicitly {@link SC2APIProtocol.ActionSelectArmy.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {SC2APIProtocol.IActionSelectArmy} message ActionSelectArmy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectArmy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.selectionAdd);
            return writer;
        };
        /**
         * Encodes the specified ActionSelectArmy message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSelectArmy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {SC2APIProtocol.IActionSelectArmy} message ActionSelectArmy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectArmy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSelectArmy message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSelectArmy} ActionSelectArmy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectArmy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSelectArmy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.selectionAdd = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSelectArmy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSelectArmy} ActionSelectArmy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectArmy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSelectArmy message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSelectArmy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                if (typeof message.selectionAdd !== "boolean")
                    return "selectionAdd: boolean expected";
            return null;
        };
        /**
         * Creates an ActionSelectArmy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSelectArmy} ActionSelectArmy
         */
        ActionSelectArmy.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSelectArmy)
                return object;
            var message = new $root.SC2APIProtocol.ActionSelectArmy();
            if (object.selectionAdd != null)
                message.selectionAdd = Boolean(object.selectionAdd);
            return message;
        };
        /**
         * Creates a plain object from an ActionSelectArmy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @static
         * @param {SC2APIProtocol.ActionSelectArmy} message ActionSelectArmy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSelectArmy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.selectionAdd = false;
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                object.selectionAdd = message.selectionAdd;
            return object;
        };
        /**
         * Converts this ActionSelectArmy to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSelectArmy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSelectArmy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSelectArmy;
    })();
    SC2APIProtocol.ActionSelectWarpGates = (function () {
        /**
         * Properties of an ActionSelectWarpGates.
         * @memberof SC2APIProtocol
         * @interface IActionSelectWarpGates
         * @property {boolean} [selectionAdd] ActionSelectWarpGates selectionAdd
         */
        /**
         * Constructs a new ActionSelectWarpGates.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSelectWarpGates.
         * @constructor
         * @param {SC2APIProtocol.IActionSelectWarpGates=} [properties] Properties to set
         */
        function ActionSelectWarpGates(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSelectWarpGates selectionAdd.
         * @member {boolean}selectionAdd
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @instance
         */
        ActionSelectWarpGates.prototype.selectionAdd = false;
        /**
         * Creates a new ActionSelectWarpGates instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {SC2APIProtocol.IActionSelectWarpGates=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSelectWarpGates} ActionSelectWarpGates instance
         */
        ActionSelectWarpGates.create = function create(properties) {
            return new ActionSelectWarpGates(properties);
        };
        /**
         * Encodes the specified ActionSelectWarpGates message. Does not implicitly {@link SC2APIProtocol.ActionSelectWarpGates.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {SC2APIProtocol.IActionSelectWarpGates} message ActionSelectWarpGates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectWarpGates.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.selectionAdd);
            return writer;
        };
        /**
         * Encodes the specified ActionSelectWarpGates message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSelectWarpGates.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {SC2APIProtocol.IActionSelectWarpGates} message ActionSelectWarpGates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectWarpGates.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSelectWarpGates message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSelectWarpGates} ActionSelectWarpGates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectWarpGates.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSelectWarpGates();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.selectionAdd = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSelectWarpGates message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSelectWarpGates} ActionSelectWarpGates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectWarpGates.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSelectWarpGates message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSelectWarpGates.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                if (typeof message.selectionAdd !== "boolean")
                    return "selectionAdd: boolean expected";
            return null;
        };
        /**
         * Creates an ActionSelectWarpGates message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSelectWarpGates} ActionSelectWarpGates
         */
        ActionSelectWarpGates.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSelectWarpGates)
                return object;
            var message = new $root.SC2APIProtocol.ActionSelectWarpGates();
            if (object.selectionAdd != null)
                message.selectionAdd = Boolean(object.selectionAdd);
            return message;
        };
        /**
         * Creates a plain object from an ActionSelectWarpGates message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @static
         * @param {SC2APIProtocol.ActionSelectWarpGates} message ActionSelectWarpGates
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSelectWarpGates.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.selectionAdd = false;
            if (message.selectionAdd != null && message.hasOwnProperty("selectionAdd"))
                object.selectionAdd = message.selectionAdd;
            return object;
        };
        /**
         * Converts this ActionSelectWarpGates to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSelectWarpGates
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSelectWarpGates.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSelectWarpGates;
    })();
    SC2APIProtocol.ActionSelectLarva = (function () {
        /**
         * Properties of an ActionSelectLarva.
         * @memberof SC2APIProtocol
         * @interface IActionSelectLarva
         */
        /**
         * Constructs a new ActionSelectLarva.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSelectLarva.
         * @constructor
         * @param {SC2APIProtocol.IActionSelectLarva=} [properties] Properties to set
         */
        function ActionSelectLarva(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Creates a new ActionSelectLarva instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {SC2APIProtocol.IActionSelectLarva=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSelectLarva} ActionSelectLarva instance
         */
        ActionSelectLarva.create = function create(properties) {
            return new ActionSelectLarva(properties);
        };
        /**
         * Encodes the specified ActionSelectLarva message. Does not implicitly {@link SC2APIProtocol.ActionSelectLarva.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {SC2APIProtocol.IActionSelectLarva} message ActionSelectLarva message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectLarva.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
        /**
         * Encodes the specified ActionSelectLarva message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSelectLarva.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {SC2APIProtocol.IActionSelectLarva} message ActionSelectLarva message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectLarva.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSelectLarva message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSelectLarva} ActionSelectLarva
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectLarva.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSelectLarva();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSelectLarva message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSelectLarva} ActionSelectLarva
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectLarva.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSelectLarva message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSelectLarva.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
        /**
         * Creates an ActionSelectLarva message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSelectLarva} ActionSelectLarva
         */
        ActionSelectLarva.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSelectLarva)
                return object;
            return new $root.SC2APIProtocol.ActionSelectLarva();
        };
        /**
         * Creates a plain object from an ActionSelectLarva message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @static
         * @param {SC2APIProtocol.ActionSelectLarva} message ActionSelectLarva
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSelectLarva.toObject = function toObject() {
            return {};
        };
        /**
         * Converts this ActionSelectLarva to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSelectLarva
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSelectLarva.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionSelectLarva;
    })();
    SC2APIProtocol.ActionSelectIdleWorker = (function () {
        /**
         * Properties of an ActionSelectIdleWorker.
         * @memberof SC2APIProtocol
         * @interface IActionSelectIdleWorker
         * @property {SC2APIProtocol.ActionSelectIdleWorker.Type} [type] ActionSelectIdleWorker type
         */
        /**
         * Constructs a new ActionSelectIdleWorker.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionSelectIdleWorker.
         * @constructor
         * @param {SC2APIProtocol.IActionSelectIdleWorker=} [properties] Properties to set
         */
        function ActionSelectIdleWorker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionSelectIdleWorker type.
         * @member {SC2APIProtocol.ActionSelectIdleWorker.Type}type
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @instance
         */
        ActionSelectIdleWorker.prototype.type = 1;
        /**
         * Creates a new ActionSelectIdleWorker instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {SC2APIProtocol.IActionSelectIdleWorker=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionSelectIdleWorker} ActionSelectIdleWorker instance
         */
        ActionSelectIdleWorker.create = function create(properties) {
            return new ActionSelectIdleWorker(properties);
        };
        /**
         * Encodes the specified ActionSelectIdleWorker message. Does not implicitly {@link SC2APIProtocol.ActionSelectIdleWorker.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {SC2APIProtocol.IActionSelectIdleWorker} message ActionSelectIdleWorker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectIdleWorker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
            return writer;
        };
        /**
         * Encodes the specified ActionSelectIdleWorker message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionSelectIdleWorker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {SC2APIProtocol.IActionSelectIdleWorker} message ActionSelectIdleWorker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionSelectIdleWorker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionSelectIdleWorker message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionSelectIdleWorker} ActionSelectIdleWorker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectIdleWorker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionSelectIdleWorker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionSelectIdleWorker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionSelectIdleWorker} ActionSelectIdleWorker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionSelectIdleWorker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionSelectIdleWorker message.
         * @function verify
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionSelectIdleWorker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            return null;
        };
        /**
         * Creates an ActionSelectIdleWorker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionSelectIdleWorker} ActionSelectIdleWorker
         */
        ActionSelectIdleWorker.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionSelectIdleWorker)
                return object;
            var message = new $root.SC2APIProtocol.ActionSelectIdleWorker();
            switch (object.type) {
                case "Set":
                case 1:
                    message.type = 1;
                    break;
                case "Add":
                case 2:
                    message.type = 2;
                    break;
                case "All":
                case 3:
                    message.type = 3;
                    break;
                case "AddAll":
                case 4:
                    message.type = 4;
                    break;
            }
            return message;
        };
        /**
         * Creates a plain object from an ActionSelectIdleWorker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @static
         * @param {SC2APIProtocol.ActionSelectIdleWorker} message ActionSelectIdleWorker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionSelectIdleWorker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.type = options.enums === String ? "Set" : 1;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.ActionSelectIdleWorker.Type[message.type] : message.type;
            return object;
        };
        /**
         * Converts this ActionSelectIdleWorker to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionSelectIdleWorker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionSelectIdleWorker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Type enum.
         * @enum {string}
         * @property {number} Set=1 Set value
         * @property {number} Add=2 Add value
         * @property {number} All=3 All value
         * @property {number} AddAll=4 AddAll value
         */
        ActionSelectIdleWorker.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Set"] = 1;
            values[valuesById[2] = "Add"] = 2;
            values[valuesById[3] = "All"] = 3;
            values[valuesById[4] = "AddAll"] = 4;
            return values;
        })();
        return ActionSelectIdleWorker;
    })();
    SC2APIProtocol.ActionMultiPanel = (function () {
        /**
         * Properties of an ActionMultiPanel.
         * @memberof SC2APIProtocol
         * @interface IActionMultiPanel
         * @property {SC2APIProtocol.ActionMultiPanel.Type} [type] ActionMultiPanel type
         * @property {number} [unitIndex] ActionMultiPanel unitIndex
         */
        /**
         * Constructs a new ActionMultiPanel.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionMultiPanel.
         * @constructor
         * @param {SC2APIProtocol.IActionMultiPanel=} [properties] Properties to set
         */
        function ActionMultiPanel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionMultiPanel type.
         * @member {SC2APIProtocol.ActionMultiPanel.Type}type
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @instance
         */
        ActionMultiPanel.prototype.type = 1;
        /**
         * ActionMultiPanel unitIndex.
         * @member {number}unitIndex
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @instance
         */
        ActionMultiPanel.prototype.unitIndex = 0;
        /**
         * Creates a new ActionMultiPanel instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {SC2APIProtocol.IActionMultiPanel=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionMultiPanel} ActionMultiPanel instance
         */
        ActionMultiPanel.create = function create(properties) {
            return new ActionMultiPanel(properties);
        };
        /**
         * Encodes the specified ActionMultiPanel message. Does not implicitly {@link SC2APIProtocol.ActionMultiPanel.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {SC2APIProtocol.IActionMultiPanel} message ActionMultiPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionMultiPanel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type);
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.unitIndex);
            return writer;
        };
        /**
         * Encodes the specified ActionMultiPanel message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionMultiPanel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {SC2APIProtocol.IActionMultiPanel} message ActionMultiPanel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionMultiPanel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionMultiPanel message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionMultiPanel} ActionMultiPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionMultiPanel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionMultiPanel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.unitIndex = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionMultiPanel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionMultiPanel} ActionMultiPanel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionMultiPanel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionMultiPanel message.
         * @function verify
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionMultiPanel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                }
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                if (!$util.isInteger(message.unitIndex))
                    return "unitIndex: integer expected";
            return null;
        };
        /**
         * Creates an ActionMultiPanel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionMultiPanel} ActionMultiPanel
         */
        ActionMultiPanel.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionMultiPanel)
                return object;
            var message = new $root.SC2APIProtocol.ActionMultiPanel();
            switch (object.type) {
                case "SingleSelect":
                case 1:
                    message.type = 1;
                    break;
                case "DeselectUnit":
                case 2:
                    message.type = 2;
                    break;
                case "SelectAllOfType":
                case 3:
                    message.type = 3;
                    break;
                case "DeselectAllOfType":
                case 4:
                    message.type = 4;
                    break;
            }
            if (object.unitIndex != null)
                message.unitIndex = object.unitIndex | 0;
            return message;
        };
        /**
         * Creates a plain object from an ActionMultiPanel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @static
         * @param {SC2APIProtocol.ActionMultiPanel} message ActionMultiPanel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionMultiPanel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "SingleSelect" : 1;
                object.unitIndex = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.SC2APIProtocol.ActionMultiPanel.Type[message.type] : message.type;
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                object.unitIndex = message.unitIndex;
            return object;
        };
        /**
         * Converts this ActionMultiPanel to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionMultiPanel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionMultiPanel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        /**
         * Type enum.
         * @enum {string}
         * @property {number} SingleSelect=1 SingleSelect value
         * @property {number} DeselectUnit=2 DeselectUnit value
         * @property {number} SelectAllOfType=3 SelectAllOfType value
         * @property {number} DeselectAllOfType=4 DeselectAllOfType value
         */
        ActionMultiPanel.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "SingleSelect"] = 1;
            values[valuesById[2] = "DeselectUnit"] = 2;
            values[valuesById[3] = "SelectAllOfType"] = 3;
            values[valuesById[4] = "DeselectAllOfType"] = 4;
            return values;
        })();
        return ActionMultiPanel;
    })();
    SC2APIProtocol.ActionCargoPanelUnload = (function () {
        /**
         * Properties of an ActionCargoPanelUnload.
         * @memberof SC2APIProtocol
         * @interface IActionCargoPanelUnload
         * @property {number} [unitIndex] ActionCargoPanelUnload unitIndex
         */
        /**
         * Constructs a new ActionCargoPanelUnload.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionCargoPanelUnload.
         * @constructor
         * @param {SC2APIProtocol.IActionCargoPanelUnload=} [properties] Properties to set
         */
        function ActionCargoPanelUnload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionCargoPanelUnload unitIndex.
         * @member {number}unitIndex
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @instance
         */
        ActionCargoPanelUnload.prototype.unitIndex = 0;
        /**
         * Creates a new ActionCargoPanelUnload instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {SC2APIProtocol.IActionCargoPanelUnload=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionCargoPanelUnload} ActionCargoPanelUnload instance
         */
        ActionCargoPanelUnload.create = function create(properties) {
            return new ActionCargoPanelUnload(properties);
        };
        /**
         * Encodes the specified ActionCargoPanelUnload message. Does not implicitly {@link SC2APIProtocol.ActionCargoPanelUnload.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {SC2APIProtocol.IActionCargoPanelUnload} message ActionCargoPanelUnload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionCargoPanelUnload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.unitIndex);
            return writer;
        };
        /**
         * Encodes the specified ActionCargoPanelUnload message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionCargoPanelUnload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {SC2APIProtocol.IActionCargoPanelUnload} message ActionCargoPanelUnload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionCargoPanelUnload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionCargoPanelUnload message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionCargoPanelUnload} ActionCargoPanelUnload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionCargoPanelUnload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionCargoPanelUnload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitIndex = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionCargoPanelUnload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionCargoPanelUnload} ActionCargoPanelUnload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionCargoPanelUnload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionCargoPanelUnload message.
         * @function verify
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionCargoPanelUnload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                if (!$util.isInteger(message.unitIndex))
                    return "unitIndex: integer expected";
            return null;
        };
        /**
         * Creates an ActionCargoPanelUnload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionCargoPanelUnload} ActionCargoPanelUnload
         */
        ActionCargoPanelUnload.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionCargoPanelUnload)
                return object;
            var message = new $root.SC2APIProtocol.ActionCargoPanelUnload();
            if (object.unitIndex != null)
                message.unitIndex = object.unitIndex | 0;
            return message;
        };
        /**
         * Creates a plain object from an ActionCargoPanelUnload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @static
         * @param {SC2APIProtocol.ActionCargoPanelUnload} message ActionCargoPanelUnload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionCargoPanelUnload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.unitIndex = 0;
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                object.unitIndex = message.unitIndex;
            return object;
        };
        /**
         * Converts this ActionCargoPanelUnload to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionCargoPanelUnload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionCargoPanelUnload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionCargoPanelUnload;
    })();
    SC2APIProtocol.ActionProductionPanelRemoveFromQueue = (function () {
        /**
         * Properties of an ActionProductionPanelRemoveFromQueue.
         * @memberof SC2APIProtocol
         * @interface IActionProductionPanelRemoveFromQueue
         * @property {number} [unitIndex] ActionProductionPanelRemoveFromQueue unitIndex
         */
        /**
         * Constructs a new ActionProductionPanelRemoveFromQueue.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionProductionPanelRemoveFromQueue.
         * @constructor
         * @param {SC2APIProtocol.IActionProductionPanelRemoveFromQueue=} [properties] Properties to set
         */
        function ActionProductionPanelRemoveFromQueue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionProductionPanelRemoveFromQueue unitIndex.
         * @member {number}unitIndex
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @instance
         */
        ActionProductionPanelRemoveFromQueue.prototype.unitIndex = 0;
        /**
         * Creates a new ActionProductionPanelRemoveFromQueue instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {SC2APIProtocol.IActionProductionPanelRemoveFromQueue=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionProductionPanelRemoveFromQueue} ActionProductionPanelRemoveFromQueue instance
         */
        ActionProductionPanelRemoveFromQueue.create = function create(properties) {
            return new ActionProductionPanelRemoveFromQueue(properties);
        };
        /**
         * Encodes the specified ActionProductionPanelRemoveFromQueue message. Does not implicitly {@link SC2APIProtocol.ActionProductionPanelRemoveFromQueue.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {SC2APIProtocol.IActionProductionPanelRemoveFromQueue} message ActionProductionPanelRemoveFromQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionProductionPanelRemoveFromQueue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.unitIndex);
            return writer;
        };
        /**
         * Encodes the specified ActionProductionPanelRemoveFromQueue message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionProductionPanelRemoveFromQueue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {SC2APIProtocol.IActionProductionPanelRemoveFromQueue} message ActionProductionPanelRemoveFromQueue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionProductionPanelRemoveFromQueue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionProductionPanelRemoveFromQueue message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionProductionPanelRemoveFromQueue} ActionProductionPanelRemoveFromQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionProductionPanelRemoveFromQueue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.unitIndex = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionProductionPanelRemoveFromQueue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionProductionPanelRemoveFromQueue} ActionProductionPanelRemoveFromQueue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionProductionPanelRemoveFromQueue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionProductionPanelRemoveFromQueue message.
         * @function verify
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionProductionPanelRemoveFromQueue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                if (!$util.isInteger(message.unitIndex))
                    return "unitIndex: integer expected";
            return null;
        };
        /**
         * Creates an ActionProductionPanelRemoveFromQueue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionProductionPanelRemoveFromQueue} ActionProductionPanelRemoveFromQueue
         */
        ActionProductionPanelRemoveFromQueue.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue)
                return object;
            var message = new $root.SC2APIProtocol.ActionProductionPanelRemoveFromQueue();
            if (object.unitIndex != null)
                message.unitIndex = object.unitIndex | 0;
            return message;
        };
        /**
         * Creates a plain object from an ActionProductionPanelRemoveFromQueue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @static
         * @param {SC2APIProtocol.ActionProductionPanelRemoveFromQueue} message ActionProductionPanelRemoveFromQueue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionProductionPanelRemoveFromQueue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.unitIndex = 0;
            if (message.unitIndex != null && message.hasOwnProperty("unitIndex"))
                object.unitIndex = message.unitIndex;
            return object;
        };
        /**
         * Converts this ActionProductionPanelRemoveFromQueue to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionProductionPanelRemoveFromQueue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionProductionPanelRemoveFromQueue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionProductionPanelRemoveFromQueue;
    })();
    SC2APIProtocol.ActionToggleAutocast = (function () {
        /**
         * Properties of an ActionToggleAutocast.
         * @memberof SC2APIProtocol
         * @interface IActionToggleAutocast
         * @property {number} [abilityId] ActionToggleAutocast abilityId
         */
        /**
         * Constructs a new ActionToggleAutocast.
         * @memberof SC2APIProtocol
         * @classdesc Represents an ActionToggleAutocast.
         * @constructor
         * @param {SC2APIProtocol.IActionToggleAutocast=} [properties] Properties to set
         */
        function ActionToggleAutocast(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ActionToggleAutocast abilityId.
         * @member {number}abilityId
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @instance
         */
        ActionToggleAutocast.prototype.abilityId = 0;
        /**
         * Creates a new ActionToggleAutocast instance using the specified properties.
         * @function create
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionToggleAutocast=} [properties] Properties to set
         * @returns {SC2APIProtocol.ActionToggleAutocast} ActionToggleAutocast instance
         */
        ActionToggleAutocast.create = function create(properties) {
            return new ActionToggleAutocast(properties);
        };
        /**
         * Encodes the specified ActionToggleAutocast message. Does not implicitly {@link SC2APIProtocol.ActionToggleAutocast.verify|verify} messages.
         * @function encode
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionToggleAutocast} message ActionToggleAutocast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionToggleAutocast.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.abilityId);
            return writer;
        };
        /**
         * Encodes the specified ActionToggleAutocast message, length delimited. Does not implicitly {@link SC2APIProtocol.ActionToggleAutocast.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {SC2APIProtocol.IActionToggleAutocast} message ActionToggleAutocast message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionToggleAutocast.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        /**
         * Decodes an ActionToggleAutocast message from the specified reader or buffer.
         * @function decode
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SC2APIProtocol.ActionToggleAutocast} ActionToggleAutocast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionToggleAutocast.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SC2APIProtocol.ActionToggleAutocast();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.abilityId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        /**
         * Decodes an ActionToggleAutocast message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SC2APIProtocol.ActionToggleAutocast} ActionToggleAutocast
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionToggleAutocast.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies an ActionToggleAutocast message.
         * @function verify
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionToggleAutocast.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                if (!$util.isInteger(message.abilityId))
                    return "abilityId: integer expected";
            return null;
        };
        /**
         * Creates an ActionToggleAutocast message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SC2APIProtocol.ActionToggleAutocast} ActionToggleAutocast
         */
        ActionToggleAutocast.fromObject = function fromObject(object) {
            if (object instanceof $root.SC2APIProtocol.ActionToggleAutocast)
                return object;
            var message = new $root.SC2APIProtocol.ActionToggleAutocast();
            if (object.abilityId != null)
                message.abilityId = object.abilityId | 0;
            return message;
        };
        /**
         * Creates a plain object from an ActionToggleAutocast message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @static
         * @param {SC2APIProtocol.ActionToggleAutocast} message ActionToggleAutocast
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionToggleAutocast.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.abilityId = 0;
            if (message.abilityId != null && message.hasOwnProperty("abilityId"))
                object.abilityId = message.abilityId;
            return object;
        };
        /**
         * Converts this ActionToggleAutocast to JSON.
         * @function toJSON
         * @memberof SC2APIProtocol.ActionToggleAutocast
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionToggleAutocast.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ActionToggleAutocast;
    })();
    return SC2APIProtocol;
})();
module.exports = $root;
//# sourceMappingURL=sc2api.js.map